{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/20190820225155.png","path":"images/20190820225155.png","modified":0,"renderable":0},{"_id":"source/images/红黑树删除修复.png","path":"images/红黑树删除修复.png","modified":0,"renderable":0},{"_id":"source/images/红黑树插入调整.png","path":"images/红黑树插入调整.png","modified":0,"renderable":0},{"_id":"source/resources/MersenneTwister.java","path":"resources/MersenneTwister.java","modified":0,"renderable":0},{"_id":"source/resources/MersenneTwisterFast.java","path":"resources/MersenneTwisterFast.java","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/favicon_bak.png","path":"favicon_bak.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/matery.css","path":"css/matery.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my.css","path":"css/my.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/matery.js","path":"js/matery.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","path":"medias/logo.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/logo_bak.png","path":"medias/logo_bak.png","modified":0,"renderable":1},{"_id":"source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","path":"medias/cover.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":0,"renderable":1},{"_id":"source/medias/banner/17.jpg","path":"medias/banner/17.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":0,"renderable":1},{"_id":"source/medias/banner/12.jpg","path":"medias/banner/12.jpg","modified":0,"renderable":0},{"_id":"source/medias/banner/13.jpg","path":"medias/banner/13.jpg","modified":0,"renderable":0},{"_id":"source/medias/banner/7.jpg","path":"medias/banner/7.jpg","modified":0,"renderable":0},{"_id":"source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":0},{"_id":"source/medias/banner/11.jpg","path":"medias/banner/11.jpg","modified":0,"renderable":0},{"_id":"source/medias/banner/15.jpg","path":"medias/banner/15.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":0,"renderable":1},{"_id":"source/medias/banner/10.jpg","path":"medias/banner/10.jpg","modified":0,"renderable":0},{"_id":"source/medias/banner/14.jpg","path":"medias/banner/14.jpg","modified":0,"renderable":0},{"_id":"source/medias/banner/19.jpg","path":"medias/banner/19.jpg","modified":0,"renderable":0},{"_id":"source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":0},{"_id":"source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":0,"renderable":0},{"_id":"source/medias/banner/8.jpg","path":"medias/banner/8.jpg","modified":0,"renderable":0},{"_id":"source/medias/banner/9.jpg","path":"medias/banner/9.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"source/medias/banner/16.jpg","path":"medias/banner/16.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/material-design-icons/LICENSE.txt","path":"libs/materialize/font/material-design-icons/LICENSE.txt","modified":0,"renderable":1},{"_id":"source/medias/banner/18.jpg","path":"medias/banner/18.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/material-design-icons/Material-Design-Icons.woff2","path":"libs/materialize/font/material-design-icons/Material-Design-Icons.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Bold.eot","path":"libs/materialize/font/roboto/Roboto-Bold.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Light.eot","path":"libs/materialize/font/roboto/Roboto-Light.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Light.woff2","path":"libs/materialize/font/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Medium.woff","path":"libs/materialize/font/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Medium.woff2","path":"libs/materialize/font/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Regular.eot","path":"libs/materialize/font/roboto/Roboto-Regular.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Regular.woff","path":"libs/materialize/font/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Regular.woff2","path":"libs/materialize/font/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Thin.eot","path":"libs/materialize/font/roboto/Roboto-Thin.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Thin.woff","path":"libs/materialize/font/roboto/Roboto-Thin.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Thin.woff2","path":"libs/materialize/font/roboto/Roboto-Thin.woff2","modified":0,"renderable":1},{"_id":"source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/material-design-icons/Material-Design-Icons.eot","path":"libs/materialize/font/material-design-icons/Material-Design-Icons.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/material-design-icons/Material-Design-Icons.ttf","path":"libs/materialize/font/material-design-icons/Material-Design-Icons.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Bold.woff","path":"libs/materialize/font/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Light.woff","path":"libs/materialize/font/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Medium.eot","path":"libs/materialize/font/roboto/Roboto-Medium.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/js/materialize.min.js","path":"libs/materialize/js/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/css/materialize.min.css","path":"libs/materialize/css/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/material-design-icons/Material-Design-Icons.woff","path":"libs/materialize/font/material-design-icons/Material-Design-Icons.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Bold.woff2","path":"libs/materialize/font/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Medium.ttf","path":"libs/materialize/font/roboto/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Regular.ttf","path":"libs/materialize/font/roboto/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Thin.ttf","path":"libs/materialize/font/roboto/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Bold.ttf","path":"libs/materialize/font/roboto/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Light.ttf","path":"libs/materialize/font/roboto/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/material-design-icons/Material-Design-Icons.svg","path":"libs/materialize/font/material-design-icons/Material-Design-Icons.svg","modified":0,"renderable":1},{"_id":"source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":0,"renderable":1},{"_id":"source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"1403b3255973457a8ec76f82d69189e73b592c80","modified":1548512487728},{"_id":"themes/hexo-theme-matery/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1547734409046},{"_id":"themes/hexo-theme-matery/README.md","hash":"ac08c9fb83ab1ee61a7fcf3be00071706b979ad4","modified":1547734409046},{"_id":"themes/hexo-theme-matery/README_CN.md","hash":"b02249657c64f51635775e381c06d6dc8c8e6e95","modified":1547734409046},{"_id":"themes/hexo-theme-matery/_config.yml","hash":"aa916f8367e5a7abda518578e117e1fd0f3998eb","modified":1548519299295},{"_id":"source/_data/friends.json","hash":"4cf30317de06e690dcc811da6a2bfe4c7d367630","modified":1556207320414},{"_id":"source/_posts/Designing Data-Intensive Application.md","hash":"9b582725502c8da6d9555b99d7cf202ab323b7eb","modified":1556294816239},{"_id":"source/_posts/jdk的快速排序.md","hash":"7884e84930e545817825dc2738ff993978bf1f80","modified":1566113809022},{"_id":"source/_posts/springFramework3-1这样的老版本怎么维护啊？.md","hash":"cd2964078f245b1287ca7fee216174cf0d71de73","modified":1568458207726},{"_id":"source/_posts/springMVC源码自探.md","hash":"964ed9a6ba151b122d66e05d5b430f4193a62c50","modified":1555757849880},{"_id":"source/_posts/位运算的那些骚操作.md","hash":"6bc9071006b75bacfc8ae1373827ff3254d5b04e","modified":1548824374132},{"_id":"source/_posts/好了，这下百度不到了怎么办？.md","hash":"926867679a57d6a98114b0b571711be63fe594cc","modified":1568346583801},{"_id":"source/_posts/强大的正则-带你获取你想要的各种数据.md","hash":"e8289285ba66b0f463733051c16cfc0d5bbb8212","modified":1567696005543},{"_id":"source/_posts/技术人员有关技能方面的一点感悟.md","hash":"e5e5ece9546c28a7815397771d779a4cccaa3b5c","modified":1559406009550},{"_id":"source/_posts/查快改慢B-树-改快查慢LSM树.md","hash":"2832cfac4a019a83dc39025a66d56e43137efa35","modified":1548512487739},{"_id":"source/_posts/正则完全总结.md","hash":"07d13554957c3dd6566d11810d75246f6a20942d","modified":1559457784291},{"_id":"source/_posts/究竟应该怎么实现分布式锁 ？.md","hash":"7d1c54c35742e838bc1ffa1d30a2919acf9a748f","modified":1555856953695},{"_id":"source/_posts/红黑树RBTree在jdk中的实现.md","hash":"548552f3995eb133d0f2abd00d233a7def9755f7","modified":1550677164110},{"_id":"source/_posts/聊聊paxos.md","hash":"d8560fe164a083e783fa24e3ceece70281ab5606","modified":1566823225732},{"_id":"source/_posts/记一次生产多线程数据导出bug排查.md","hash":"85bee2399e8f542330587fc2f9ee3bf0d034e1ee","modified":1566310595456},{"_id":"source/_posts/限流方案对比.md","hash":"04faa811a886d149b7e67cd8417f2a2198028c6a","modified":1566113875536},{"_id":"source/about/index.md","hash":"5606c1407c2395f27319334ffc0573b73f24e3f5","modified":1547736433603},{"_id":"source/categories/index.md","hash":"77fb355315ca20d439fa9a9e6cb3ced1576731b7","modified":1547736342804},{"_id":"source/friends/index.md","hash":"d7e7f2d73cb839da5c8d9d038f094ccd88dc9650","modified":1547736462978},{"_id":"source/images/20190820225155.png","hash":"904f645e34fd6e970e6122de1bdf946909b237de","modified":1566312718440},{"_id":"source/images/红黑树删除修复.png","hash":"5094f414c3cbc392b6043cdafe1d708ede18f575","modified":1548512487763},{"_id":"source/images/红黑树插入调整.png","hash":"723e1cf5b1e1c3f40e7a0ab0e4e97c90496e471b","modified":1548512487782},{"_id":"source/resources/MersenneTwister.java","hash":"0aec3560a730b33fc2c7a67632533f32b8e2c6d3","modified":1555432914948},{"_id":"source/resources/MersenneTwisterFast.java","hash":"6874ef5fb8ff8300e7fea25aa1380a18ba61637f","modified":1555432914949},{"_id":"source/tags/index.md","hash":"78b9966192a7cc8f676b66ef1f83c09b337af7c9","modified":1547736380500},{"_id":"themes/hexo-theme-matery/languages/default.yml","hash":"5c4d45dfaa8408174bb58d0b1872ffbf52331e84","modified":1547734409046},{"_id":"themes/hexo-theme-matery/languages/zh-CN.yml","hash":"b3c6e50c1caa6d8af0ebf815a1894de927e1fe79","modified":1547734409046},{"_id":"themes/hexo-theme-matery/layout/about.ejs","hash":"0a8942e2fa070d7d08ef0779267e1e05ff8e3065","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/archive.ejs","hash":"76bbb94fd35870699b7a9741b2eafd2df4275506","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/category.ejs","hash":"2a414afa71f94edba24851c0732c884d1f163f13","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/friends.ejs","hash":"b5ebe0ce1f08e6c5f417a55a6e98c728d35019c1","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/index.ejs","hash":"e4a9d2892dcce4b599c6c0a253caf10e4d0f9cd6","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/layout.ejs","hash":"6e09402569e8e4bd15c7a3ab786b190e5b759409","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/post.ejs","hash":"caa7f0c717560423e7e993cf2d6952b450139f75","modified":1547734409076},{"_id":"themes/hexo-theme-matery/layout/tag.ejs","hash":"c9589d0e192910550decfcf962c896aca7254db5","modified":1547734409076},{"_id":"themes/hexo-theme-matery/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1547734409076},{"_id":"themes/hexo-theme-matery/source/favicon.png","hash":"a0a8c8801a6a0d81bce295248d4d10fb85e0f457","modified":1555430988644},{"_id":"themes/hexo-theme-matery/source/favicon_bak.png","hash":"20674c497b75fc889194b47fd18ecea12303d8ec","modified":1547734409076},{"_id":"themes/hexo-theme-matery/layout/_partial/back-top.ejs","hash":"cb99dc352397ec5d0765794d7b8884972e61973b","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover.ejs","hash":"023d6f717390452d6de4a1da8797b8891a591e5e","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/disqus.ejs","hash":"42dda8e67f7f09d148347887e52f18aea546df26","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/footer.ejs","hash":"f59d3d45a339e330784c0e060bb02fc7f13da8b7","modified":1548163093520},{"_id":"themes/hexo-theme-matery/layout/_partial/gitalk.ejs","hash":"2f2f19ff29862ce056f2ed909f0f0b6b57b4c0bb","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/github-link.ejs","hash":"fd4034bca2eb3987dcf113e6477260bee97eb1e7","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/gitment.ejs","hash":"d8c40dbc8106b5bc53ceb727ad968c1d8f234261","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/head.ejs","hash":"27952311e17475ae5ce4d8d462458bcbac3bf620","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/header.ejs","hash":"b05d20668c396116b7375ed469e2c62860722ba6","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/mobile-nav.ejs","hash":"a873099c04cc18476dabd0e39639b10793fc2142","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/navigation.ejs","hash":"c8583c296876d422a7d5ebba692460610da215e7","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/paging.ejs","hash":"dfdeea9c59d157acb851d4bf44bf95f81787523c","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/post-cover.ejs","hash":"f7271dd1eb8f4fd29cc49f8f226de0b9b797e74a","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail-toc.ejs","hash":"2fa40dc53312c76e6a20ae107cb4188b653eac47","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail.ejs","hash":"db61739b1ae4e1487abd808ee2dedb848d678486","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/post-statis.ejs","hash":"3b42900247d5ea4ea5b68e2be44420a0d54785ad","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/prev-next.ejs","hash":"2d72c5c2da3ae1bccd3ed5f2e691c9fc0d224e75","modified":1547734409056},{"_id":"themes/hexo-theme-matery/layout/_partial/reward.ejs","hash":"e20f68a0e099b9467ffdfbc187ece212fecef4eb","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/_partial/search.ejs","hash":"06493fc4f3b256dd67b8399d929fa80d29de1486","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/_partial/share.ejs","hash":"0f2e1e27d21492cf228e786daead985b1e1dcea4","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/_partial/social-link.ejs","hash":"607762f39cc6bed5e86c514979bfdd96861daee8","modified":1548163093520},{"_id":"themes/hexo-theme-matery/layout/_partial/valine.ejs","hash":"8671cff27aef7298b2518dd57fe0671959f21701","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/_widget/category-cloud.ejs","hash":"319587adc3a46518077af68e3558cd9c4b2d61eb","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/_widget/category-radar.ejs","hash":"f166abe86d5e4279758d48b8a6827f58c0facaaa","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/_widget/my-gallery.ejs","hash":"441f5a685350d0a765a01596de20bcf74a52a763","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/_widget/my-projects.ejs","hash":"c7a1e65b4a75ecdbf460ea1b4fe0643fd47ec1eb","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/_widget/my-skills.ejs","hash":"66666b851899ac0c7088f3612b993268e5cf5464","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/_widget/post-calendar.ejs","hash":"7bb46650940dc7265a9331536b722754d1d3d53a","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/_widget/post-charts.ejs","hash":"6d40e0107499dd280e5b8bc6b433a41057ce2390","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/_widget/recommend.ejs","hash":"47730e36f2694c976838dd59d982e021743ca8c7","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-cloud.ejs","hash":"468a8419f2af3baff2dda2e3fab9461804a75a32","modified":1547734409066},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-wordcloud.ejs","hash":"0afac0d330db3053c22b3082c299aa0d8c9b1c7a","modified":1547734409066},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1547734409076},{"_id":"themes/hexo-theme-matery/source/css/matery.css","hash":"d550cc25e4ecf49a99fb05606c2be7315b01a0e0","modified":1555432611732},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1547734409076},{"_id":"themes/hexo-theme-matery/source/css/my.css","hash":"37683a9f11c68903a53e2b8593ca8c095a721896","modified":1547734409076},{"_id":"themes/hexo-theme-matery/source/js/matery.js","hash":"c08f0c4d43da6c4632f31f96d3885754298bba32","modified":1547734409076},{"_id":"themes/hexo-theme-matery/source/js/search.js","hash":"77ecae23dd3edd8ad962c5b12954652bb2f7a1b6","modified":1547734409076},{"_id":"themes/hexo-theme-matery/source/medias/avatar.jpg","hash":"b7f8ca0c682f95d93f002c845aafbcb508ec2b0f","modified":1547734409156},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","hash":"a0a8c8801a6a0d81bce295248d4d10fb85e0f457","modified":1555430988644},{"_id":"themes/hexo-theme-matery/source/medias/logo_bak.png","hash":"4050259723bd418648ec40028a8020364e57a6a3","modified":1547734409186},{"_id":"source/medias/banner/0.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1547811739379},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1547734409096},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1547734409076},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1547734409076},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1547734409106},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","hash":"021898a16279ac2ffe75af4f902fab2a0a39f11a","modified":1547734409106},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1547734409116},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1547734409106},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1547734409146},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","hash":"f646f2bb75bcd1eb65b2788ac7bf15d4fd243ce9","modified":1547734409156},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1547734409106},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1547734409156},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1547734409146},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1547734409146},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1547734409166},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/21.jpg","hash":"d70b088850c3565e5b5bb9eb8fe4abe688c964cf","modified":1547734409176},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/22.jpg","hash":"bf5b59d193e5ca089a7fff034c222bfa2c4dc41f","modified":1547734409176},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/23.jpg","hash":"ed5ac9f616d3b99af5188a10b1761884c37e93e5","modified":1547734409176},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","hash":"c3c1f36a1b1886037db604f151f335cd4599e970","modified":1547734409186},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","hash":"a0246a4a560438938489cdd154e35f172b3f31b0","modified":1547734409186},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","hash":"5a46ca4ab4c4ab2101a2af77a31a8878bccc483c","modified":1547734409186},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.png","hash":"fe93385aa92fe328e01c8221a80b039be9e4e140","modified":1547734409186},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.jpg","hash":"1abc719b95d1b26f1f898e6b0a9b7609146e332f","modified":1547734409186},{"_id":"source/medias/banner/17.jpg","hash":"9549c6072b3d4232b1a7c6e1e06dc641e30a291b","modified":1547811739547},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1547734409076},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","hash":"5a13983930b019450e4fe01a407c64b3dd316be4","modified":1547734409106},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"7a551393b8360731104fdef1af36a6f3638f5855","modified":1547734409106},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","hash":"1f2ec55fe7825475fde2601573bb622f0bf2acba","modified":1547734409156},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","hash":"6979c760beb550b681a06a8f11688f2d1591a70e","modified":1547734409156},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","hash":"2066cdda98ad0035071cd4aa7bd696eb078c0b6d","modified":1547734409166},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","hash":"838e704942de076c60894d14e5f280e2724b6f68","modified":1547734409166},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","hash":"d16e28bd23ea3a63643826dde5eea6b7a9bdda5d","modified":1547734409166},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","hash":"047be4239dd7e0be83243ee6b49a392a61f16b9a","modified":1547734409166},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/14.jpg","hash":"8aeb816faca2d5eaea4cce9e881d6ff87b8c7cf1","modified":1547734409176},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","hash":"9ed45f95b83626e3d91d6c405eb8bfe6fcb9736a","modified":1547734409166},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/16.jpg","hash":"9cac6b80b0cc8959fc8aabfbd1adcab79ebebfc9","modified":1547734409176},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/18.jpg","hash":"ae23fdfaa59bc57b7ed49e90c5d59e4b68e1eea5","modified":1547734409176},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","hash":"66706dfde7d910182c2f1dbadd0e9e917630b8dd","modified":1547734409176},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/19.jpg","hash":"57bc7c804b78b5cceb4eb1f9e51b734b75151b71","modified":1547734409176},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/15.jpg","hash":"5cf9fc64d5d74ab6ba69bb8bff580fdc22ba32d0","modified":1547734409176},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","hash":"16f1d89cdba4dce935ac0f12599e0fcfda543a93","modified":1547734409176},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","hash":"5e879652e032f02961a331b598a50b60ebe80a39","modified":1547734409186},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","hash":"c63ff64bdd5f6c82da8804c7248fc519d23eaf0b","modified":1547734409186},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/20.jpg","hash":"8271c4a327632b566ea62f546c083d08a0528e72","modified":1547734409176},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","hash":"4eea5bdb5724ef1ed65790e481eda0d2fb176bf0","modified":1547734409186},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","hash":"815c84778b721e3606c2bd7c099c7de7c53251ba","modified":1547734409186},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","hash":"9d5dd7e092c8eaf6266e2498cff72e6c98790a05","modified":1547734409106},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1547734409106},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1547734409116},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1547734409116},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1547734409076},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1547734409116},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1547734409116},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1547734409106},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1547734409106},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1547734409116},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1547734409116},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1547734409116},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1547734409146},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1547734409146},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1547734409146},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1547734409146},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1547734409146},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","hash":"04c6b2782ce4610c429563110f6a20a47432fc4c","modified":1547734409156},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","hash":"8d3c8391ff161eec70f66d69e5545a9468cc52ef","modified":1547734409156},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1547734409166},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","hash":"62e9586a8cec91a160f147c424a3d1d1aea360f9","modified":1547734409166},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","hash":"c3d5ab183b39a7140941b8375e29498f9d24f343","modified":1547734409156},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","hash":"4a08deec1dd5b4f1490e8fc23adfb75a0f88b0c4","modified":1547734409166},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/17.jpg","hash":"f168ca5b046d10a878a7b0bcfab540e2c4428887","modified":1547734409176},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1547734409156},{"_id":"source/medias/banner/12.jpg","hash":"3d751670fd5933392f07763e5acceafd454eaf9d","modified":1547811739448},{"_id":"source/medias/banner/13.jpg","hash":"3d42593a39bf36b72e8ba22722dd136be6574c84","modified":1547811739462},{"_id":"source/medias/banner/7.jpg","hash":"b10a065f246a3cb09b4afe41fd97bf0d970cf4df","modified":1543582456949},{"_id":"source/medias/banner/6.jpg","hash":"de576214450e7a85812620f3a1f9832f204f1293","modified":1543582615702},{"_id":"source/medias/banner/11.jpg","hash":"8052f2a2a230c7452e957b5a107b17c0f6d8167b","modified":1547811739422},{"_id":"source/medias/banner/15.jpg","hash":"865d101a4a03255f3295d4019be050d514058569","modified":1547811739515},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1547734409096},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1547734409096},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1547734409146},{"_id":"source/medias/banner/10.jpg","hash":"439577de1e3dc86ae937074bb47daa9b2c44cbbb","modified":1547811739406},{"_id":"source/medias/banner/14.jpg","hash":"8c581b44d2538053eb502a954644e4f3c031b45b","modified":1547811739497},{"_id":"source/medias/banner/19.jpg","hash":"8edec90455bcd2d7db8b799649435d26c97f36f4","modified":1548162924789},{"_id":"source/medias/banner/2.jpg","hash":"5e379764620148f53ee8c68a80dda207df72f221","modified":1555431877337},{"_id":"source/medias/banner/3.jpg","hash":"6ca7ae198a3f44e53fd09784d22ecfdff9c6db61","modified":1543582612959},{"_id":"source/medias/banner/8.jpg","hash":"67b4fa23b3ee9e624e02f304da39b81a652c998e","modified":1547811739623},{"_id":"source/medias/banner/9.jpg","hash":"2babc0df32efe4f1149d200c558e3af476cb638a","modified":1547811739639},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1547734409086},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1547734409086},{"_id":"source/medias/banner/16.jpg","hash":"d692b0a4fb37f11a4388ceb600adfeb427d182f9","modified":1547811739545},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/material-design-icons/LICENSE.txt","hash":"b7085b5c1dc3f56f81a8bf93290e2a3f24e4d8ed","modified":1547734409116},{"_id":"source/medias/banner/18.jpg","hash":"7096f48ecf0f99491ca0cd7f8b280f47765e6c15","modified":1547811739584},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/material-design-icons/Material-Design-Icons.woff2","hash":"2355cb4f824d070bc42c4ce6b97cab71af1f4ca2","modified":1547734409126},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1547734409126},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1547734409126},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1547734409136},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1547734409136},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1547734409136},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1547734409136},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1547734409136},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1547734409136},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1547734409136},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1547734409146},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1547734409146},{"_id":"source/medias/banner/1.jpg","hash":"d52b83474c37e60c240174b9c1c02ac03e1f9e00","modified":1543582550389},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1547734409096},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/material-design-icons/Material-Design-Icons.eot","hash":"fc1bc1337f3313ead42b22a67a142d4e0d356b3a","modified":1547734409116},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/material-design-icons/Material-Design-Icons.ttf","hash":"2cb66ac73a2d32ae8d2f807f705eff26fcf93323","modified":1547734409126},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1547734409126},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1547734409136},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1547734409136},{"_id":"themes/hexo-theme-matery/source/libs/materialize/js/materialize.min.js","hash":"338a96318e7c9452cec509fcf8dea1511db660b2","modified":1547734409146},{"_id":"themes/hexo-theme-matery/source/libs/materialize/css/materialize.min.css","hash":"4eaae73c0c2e342523d391057945e3c366020e3e","modified":1547734409116},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/material-design-icons/Material-Design-Icons.woff","hash":"ee77184556f7b66fcb8ee9496f81ac62f792d7dc","modified":1547734409126},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1547734409126},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1547734409136},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1547734409136},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1547734409146},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","hash":"56850c3139cbd72a0eff0c35d8fac32c9c66dd6a","modified":1547734409166},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1547734409126},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1547734409136},{"_id":"themes/hexo-theme-matery/source/libs/materialize/font/material-design-icons/Material-Design-Icons.svg","hash":"c5ff32ccf63106152dac687395d2e3551d9fcadb","modified":1547734409126},{"_id":"source/medias/banner/5.jpg","hash":"05a5621415a1ac2a19d09bc2e0deefd121cacb92","modified":1543582777226},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1547734409106},{"_id":"source/medias/banner/4.jpg","hash":"ee02c016e1dd8367edcf4ac9d65818b26d484c3d","modified":1500794617709},{"_id":"themes/hexo-theme-matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1547734409086}],"Category":[{"name":"springMVC","_id":"ck0hkxqh80007ektvm7vcvndt"},{"name":"算法","_id":"ck0hkxqhh000dektvtn5sb4j1"},{"name":"mysql","_id":"ck0hkxqhm000jektv6d2z55uk"},{"name":"分布式","_id":"ck0hkxqhs000qektveb55ytkp"},{"name":"数据结构","_id":"ck0hkxqhw000vektvhanhasfu"},{"name":"数据结构","parent":"ck0hkxqhm000jektv6d2z55uk","_id":"ck0hkxqhz000zektv28cw5m84"},{"name":"设计思想","_id":"ck0hkxqmk0029ektvio96apm6"}],"Data":[{"_id":"friends","data":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}],"Page":[{"title":"about","date":"2018-09-30T09:25:30.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-09-30 17:25:30\ntype: \"about\"\nlayout: \"about\"\n---\n","updated":"2019-01-17T14:47:13.603Z","path":"about/index.html","comments":1,"_id":"ck0hkxqgq0001ektvewmqaga1","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"categories","date":"2019-01-17T14:42:08.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-01-17 22:42:08\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2019-01-17T14:45:42.804Z","path":"categories/index.html","comments":1,"_id":"ck0hkxqgw0003ektv0qrg50gc","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"friends","date":"2019-01-17T14:47:23.000Z","type":"friends","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2019-01-17 22:47:23\ntype: \"friends\"\nlayout: \"friends\"\n---\n","updated":"2019-01-17T14:47:42.978Z","path":"friends/index.html","comments":1,"_id":"ck0hkxqh60006ektv7m4g12y1","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"tags","date":"2019-01-13T09:42:49.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-01-13 17:42:49\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2019-01-17T14:46:20.500Z","path":"tags/index.html","comments":1,"_id":"ck0hkxqha0009ektvjz72es1i","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script>","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":""}],"Post":[{"title":"springFramework3.1这样的老版本怎么维护啊？","date":"2019-09-05T15:08:04.000Z","_content":"\n### 能活下来的老项目是宝\n我们不可能一直是使用最新的技术，是项目总会成为过去，而项目能活下来也是不容易的,都是有他的价值的，而这个时候如果让你顶上去维护\n老项目你能行么？你能行么？\n\n### 起因\n最近由于技术栈的变更导致的, 项目先是出了一个bug，也就是从activeMq转变为rabbitMQ这一块。遇到了一个坑。是有关延时队列的使用，\n由于rabbiMq的延时队列是使用死信队列实现的，而这个队列是一个单向阻塞队列，如果一个延时长的任务先入队，那么后面延时短的任务要\n等到前面的元素出队列以后才能继续出队。这样会造成后面消息无法按时出队,于是网上搜索了下解决方案，\n很快就搜索到了，使用一个rabbitMq延时插件可以实现想要的功能，但是问题却也随之来了\n\n### springFramework3.1老项目\n老项目的配置都是使用xml维护的，而网上的解决方案都是基于springboot的解决方案，spring Framework的解决延时队列的方案我是没有找到\n于是我只好将对应配置的配置项的xml标签都看了一遍，根本就没有对应解决方案的标签CustomExchange，于是我想着使用@bean 标签去注入，结果发现无法注入，\n因为这个spring的版本太低了，于是到![官方文档](https://docs.spring.io/spring/docs/3.1.1.RELEASE/spring-framework-reference/html/)\n查看了下相关的资料，发现这个版本是刚刚出 @bean 这个注解的时候，这个时候的这个注解功能还处于特别低级的情况。\n因为官方文档上面写的基本都还是在使用xml配置。这个时候是我们熟知的@bean @configuration注解刚刚出道的时候。\n\n### 无法注入\n我按照官网的方法使用@configuration 和@bean 去注入，都没法注入bean，启动的时候一直报无法找到factory method异常导致的无法启动，\n于是我开始仔细看这两个注解目前版本的的功能究竟是什么，结果是这样的：\n> @configuration注解基本没什么用处,因为你要使用的话的需要用注解扫描的方式启动项目才可以\n\n直到后来我将注意力转移到@bean的使用的时候看到一句话：  \n> 4.12.4 Using the @Bean annotation\n@Bean is a method-level annotation and a direct analog of the XML <bean/> element. \nThe annotation supports some of the attributes offered by <bean/>, such as: init-method, destroy-method, autowiring and name.\nYou can use the @Bean annotation in a @Configuration-annotated or in a @Component-annotated class.  \n\n答案在最后面一句上：你也可以使用@Component注解的java类上使用@bean注解，\n这样做了之后还是没有注入我想要的自定义的bean，于是我推测既然是基于xml扫描的配置启动是不是还要在xml里面声明一下这个java类，\n声明之后终于可以按预期run起来了。而且可以完好的依赖成功后运行处想要的效果，到此，终于解决了这个问题。\n\n### 总结\n老项目的维护还是需要耐心，虽然最后的解决方案，看上去还是比较简单的，但是总不可能凭空产生这样的结果，当我们网上搜索不到答案的时候\n\n\n","source":"_posts/springFramework3-1这样的老版本怎么维护啊？.md","raw":"---\ntitle: springFramework3.1这样的老版本怎么维护啊？\ndate: 2019-09-05 23:08:04\ntags: [springFramework3.1, rabbitMq]\n---\n\n### 能活下来的老项目是宝\n我们不可能一直是使用最新的技术，是项目总会成为过去，而项目能活下来也是不容易的,都是有他的价值的，而这个时候如果让你顶上去维护\n老项目你能行么？你能行么？\n\n### 起因\n最近由于技术栈的变更导致的, 项目先是出了一个bug，也就是从activeMq转变为rabbitMQ这一块。遇到了一个坑。是有关延时队列的使用，\n由于rabbiMq的延时队列是使用死信队列实现的，而这个队列是一个单向阻塞队列，如果一个延时长的任务先入队，那么后面延时短的任务要\n等到前面的元素出队列以后才能继续出队。这样会造成后面消息无法按时出队,于是网上搜索了下解决方案，\n很快就搜索到了，使用一个rabbitMq延时插件可以实现想要的功能，但是问题却也随之来了\n\n### springFramework3.1老项目\n老项目的配置都是使用xml维护的，而网上的解决方案都是基于springboot的解决方案，spring Framework的解决延时队列的方案我是没有找到\n于是我只好将对应配置的配置项的xml标签都看了一遍，根本就没有对应解决方案的标签CustomExchange，于是我想着使用@bean 标签去注入，结果发现无法注入，\n因为这个spring的版本太低了，于是到![官方文档](https://docs.spring.io/spring/docs/3.1.1.RELEASE/spring-framework-reference/html/)\n查看了下相关的资料，发现这个版本是刚刚出 @bean 这个注解的时候，这个时候的这个注解功能还处于特别低级的情况。\n因为官方文档上面写的基本都还是在使用xml配置。这个时候是我们熟知的@bean @configuration注解刚刚出道的时候。\n\n### 无法注入\n我按照官网的方法使用@configuration 和@bean 去注入，都没法注入bean，启动的时候一直报无法找到factory method异常导致的无法启动，\n于是我开始仔细看这两个注解目前版本的的功能究竟是什么，结果是这样的：\n> @configuration注解基本没什么用处,因为你要使用的话的需要用注解扫描的方式启动项目才可以\n\n直到后来我将注意力转移到@bean的使用的时候看到一句话：  \n> 4.12.4 Using the @Bean annotation\n@Bean is a method-level annotation and a direct analog of the XML <bean/> element. \nThe annotation supports some of the attributes offered by <bean/>, such as: init-method, destroy-method, autowiring and name.\nYou can use the @Bean annotation in a @Configuration-annotated or in a @Component-annotated class.  \n\n答案在最后面一句上：你也可以使用@Component注解的java类上使用@bean注解，\n这样做了之后还是没有注入我想要的自定义的bean，于是我推测既然是基于xml扫描的配置启动是不是还要在xml里面声明一下这个java类，\n声明之后终于可以按预期run起来了。而且可以完好的依赖成功后运行处想要的效果，到此，终于解决了这个问题。\n\n### 总结\n老项目的维护还是需要耐心，虽然最后的解决方案，看上去还是比较简单的，但是总不可能凭空产生这样的结果，当我们网上搜索不到答案的时候\n\n\n","slug":"springFramework3-1这样的老版本怎么维护啊？","published":1,"updated":"2019-09-14T10:50:07.726Z","_id":"ck0hkxqgj0000ektvbzvxya7j","comments":1,"layout":"post","photos":[],"link":"","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"能活下来的老项目是宝\"><a href=\"#能活下来的老项目是宝\" class=\"headerlink\" title=\"能活下来的老项目是宝\"></a>能活下来的老项目是宝</h3><p>我们不可能一直是使用最新的技术，是项目总会成为过去，而项目能活下来也是不容易的,都是有他的价值的，而这个时候如果让你顶上去维护<br>老项目你能行么？你能行么？</p>\n<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>最近由于技术栈的变更导致的, 项目先是出了一个bug，也就是从activeMq转变为rabbitMQ这一块。遇到了一个坑。是有关延时队列的使用，<br>由于rabbiMq的延时队列是使用死信队列实现的，而这个队列是一个单向阻塞队列，如果一个延时长的任务先入队，那么后面延时短的任务要<br>等到前面的元素出队列以后才能继续出队。这样会造成后面消息无法按时出队,于是网上搜索了下解决方案，<br>很快就搜索到了，使用一个rabbitMq延时插件可以实现想要的功能，但是问题却也随之来了</p>\n<h3 id=\"springFramework3-1老项目\"><a href=\"#springFramework3-1老项目\" class=\"headerlink\" title=\"springFramework3.1老项目\"></a>springFramework3.1老项目</h3><p>老项目的配置都是使用xml维护的，而网上的解决方案都是基于springboot的解决方案，spring Framework的解决延时队列的方案我是没有找到<br>于是我只好将对应配置的配置项的xml标签都看了一遍，根本就没有对应解决方案的标签CustomExchange，于是我想着使用@bean 标签去注入，结果发现无法注入，<br>因为这个spring的版本太低了，于是到<img src=\"https://docs.spring.io/spring/docs/3.1.1.RELEASE/spring-framework-reference/html/\" alt=\"官方文档\"><br>查看了下相关的资料，发现这个版本是刚刚出 @bean 这个注解的时候，这个时候的这个注解功能还处于特别低级的情况。<br>因为官方文档上面写的基本都还是在使用xml配置。这个时候是我们熟知的@bean @configuration注解刚刚出道的时候。</p>\n<h3 id=\"无法注入\"><a href=\"#无法注入\" class=\"headerlink\" title=\"无法注入\"></a>无法注入</h3><p>我按照官网的方法使用@configuration 和@bean 去注入，都没法注入bean，启动的时候一直报无法找到factory method异常导致的无法启动，<br>于是我开始仔细看这两个注解目前版本的的功能究竟是什么，结果是这样的：</p>\n<blockquote>\n<p>@configuration注解基本没什么用处,因为你要使用的话的需要用注解扫描的方式启动项目才可以</p>\n</blockquote>\n<p>直到后来我将注意力转移到@bean的使用的时候看到一句话：  </p>\n<blockquote>\n<p>4.12.4 Using the @Bean annotation<br>@Bean is a method-level annotation and a direct analog of the XML <bean> element.<br>The annotation supports some of the attributes offered by <bean>, such as: init-method, destroy-method, autowiring and name.<br>You can use the @Bean annotation in a @Configuration-annotated or in a @Component-annotated class.  </bean></bean></p>\n</blockquote>\n<p>答案在最后面一句上：你也可以使用@Component注解的java类上使用@bean注解，<br>这样做了之后还是没有注入我想要的自定义的bean，于是我推测既然是基于xml扫描的配置启动是不是还要在xml里面声明一下这个java类，<br>声明之后终于可以按预期run起来了。而且可以完好的依赖成功后运行处想要的效果，到此，终于解决了这个问题。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>老项目的维护还是需要耐心，虽然最后的解决方案，看上去还是比较简单的，但是总不可能凭空产生这样的结果，当我们网上搜索不到答案的时候</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h3 id=\"能活下来的老项目是宝\"><a href=\"#能活下来的老项目是宝\" class=\"headerlink\" title=\"能活下来的老项目是宝\"></a>能活下来的老项目是宝</h3><p>我们不可能一直是使用最新的技术，是项目总会成为过去，而项目能活下来也是不容易的,都是有他的价值的，而这个时候如果让你顶上去维护<br>老项目你能行么？你能行么？</p>\n<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>最近由于技术栈的变更导致的, 项目先是出了一个bug，也就是从activeMq转变为rabbitMQ这一块。遇到了一个坑。是有关延时队列的使用，<br>由于rabbiMq的延时队列是使用死信队列实现的，而这个队列是一个单向阻塞队列，如果一个延时长的任务先入队，那么后面延时短的任务要<br>等到前面的元素出队列以后才能继续出队。这样会造成后面消息无法按时出队,于是网上搜索了下解决方案，<br>很快就搜索到了，使用一个rabbitMq延时插件可以实现想要的功能，但是问题却也随之来了</p>\n<h3 id=\"springFramework3-1老项目\"><a href=\"#springFramework3-1老项目\" class=\"headerlink\" title=\"springFramework3.1老项目\"></a>springFramework3.1老项目</h3><p>老项目的配置都是使用xml维护的，而网上的解决方案都是基于springboot的解决方案，spring Framework的解决延时队列的方案我是没有找到<br>于是我只好将对应配置的配置项的xml标签都看了一遍，根本就没有对应解决方案的标签CustomExchange，于是我想着使用@bean 标签去注入，结果发现无法注入，<br>因为这个spring的版本太低了，于是到<img src=\"https://docs.spring.io/spring/docs/3.1.1.RELEASE/spring-framework-reference/html/\" alt=\"官方文档\"><br>查看了下相关的资料，发现这个版本是刚刚出 @bean 这个注解的时候，这个时候的这个注解功能还处于特别低级的情况。<br>因为官方文档上面写的基本都还是在使用xml配置。这个时候是我们熟知的@bean @configuration注解刚刚出道的时候。</p>\n<h3 id=\"无法注入\"><a href=\"#无法注入\" class=\"headerlink\" title=\"无法注入\"></a>无法注入</h3><p>我按照官网的方法使用@configuration 和@bean 去注入，都没法注入bean，启动的时候一直报无法找到factory method异常导致的无法启动，<br>于是我开始仔细看这两个注解目前版本的的功能究竟是什么，结果是这样的：</p>\n<blockquote>\n<p>@configuration注解基本没什么用处,因为你要使用的话的需要用注解扫描的方式启动项目才可以</p>\n</blockquote>\n<p>直到后来我将注意力转移到@bean的使用的时候看到一句话：  </p>\n<blockquote>\n<p>4.12.4 Using the @Bean annotation<br>@Bean is a method-level annotation and a direct analog of the XML <bean> element.<br>The annotation supports some of the attributes offered by <bean>, such as: init-method, destroy-method, autowiring and name.<br>You can use the @Bean annotation in a @Configuration-annotated or in a @Component-annotated class.  </bean></bean></p>\n</blockquote>\n<p>答案在最后面一句上：你也可以使用@Component注解的java类上使用@bean注解，<br>这样做了之后还是没有注入我想要的自定义的bean，于是我推测既然是基于xml扫描的配置启动是不是还要在xml里面声明一下这个java类，<br>声明之后终于可以按预期run起来了。而且可以完好的依赖成功后运行处想要的效果，到此，终于解决了这个问题。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>老项目的维护还是需要耐心，虽然最后的解决方案，看上去还是比较简单的，但是总不可能凭空产生这样的结果，当我们网上搜索不到答案的时候</p>\n"},{"title":"springMVC 源码自探","date":"2019-01-17T07:28:30.000Z","_content":"## springMVC 源码自探\n\n![I love it when a plan comes together.](http://ww1.sinaimg.cn/large/006Cwrd9gy1fxskn2tpksj31hc0u0guq.jpg)\n### 前言\n弄清楚springMVC流程对我们写rest接口有莫大的好处，因为和它绑定在一起的还有这些重要的东西：\n> 1. http/https的知识。http请求的组成。\n2. 消息转化(参数是**如何解析**的，**什么时候解析**的，我们给常用的注解是如何实现的)\n3. springMVC拦截器的实现原理\n4. 其他，如消息监控的植入actuator,zipkin等。\n\n### spring的启动\n>spring启动的时候会扫描各个controller，并默认以单例的形式生成各个handler(controller类),handlerMethod().\n\n### 一个rest请求的到来\n#### 入口\n> 如果入口是从最开始说的话其实是从tomcat的各个过滤器(filter)顺序调用过来的，再由httpServlet拉起springMVC框架的service方法\n确定方法类型后执行doPost，或者doGet。下面只会会将几个重要过程领出来聊一聊\n\n#### DispatcherServlet.doDispatch()\n>先从10个handlerMappings中的找到对应的handlerMapping,然后从这个handlerMapping通过urlPath，找到对应方法的handler\n 并将拦截器加入handler组装成HandlerExecutionChain，如果执行HandlerExecutionChain的时候拦截器返回false方法会在止到这里直接返回。\n 拦截器如果通过，找到能够使用这个handler(Method Handler)的handlerAdapter（一般是这个:RequestMappingHandlerAdapter）\n （原本有三个找到对应的支持的） 供以后使用，也就是下面的这个方法：\n#### ServletInvocableHandlerMethod.invokeAndHandle()\n>执行里面的方法，并处理返回值\n a. 设置响应状态，\n b. 设置mavContainer处理状态设置为未处理完毕。\n c. 并对返回接口进行处理,responseBody的注解会在这里使用(用于找到返回值的handler)，并进行消息转化(json)\n#### InvocableHandlerMethod.invokeForRequest() \n>这里会解析并映射入参，这里会有各种解析参数的解析器，找到对应的解析器后然后会根据参数名字到request里面取值。\n后放入到对应的参数列表里面再将参数放入代理方法执行invoke，并返回业务代码里的返回值。\nspringMVC的字段名在request里面是这样的：如果是get方法一般就是上面的parameterMap里面的。\n ","source":"_posts/springMVC源码自探.md","raw":"title: springMVC 源码自探\ndate: 2019-01-17 15:28:30\ntags: [源码, springMVC]\ncategories: [springMVC]\n---\n## springMVC 源码自探\n\n![I love it when a plan comes together.](http://ww1.sinaimg.cn/large/006Cwrd9gy1fxskn2tpksj31hc0u0guq.jpg)\n### 前言\n弄清楚springMVC流程对我们写rest接口有莫大的好处，因为和它绑定在一起的还有这些重要的东西：\n> 1. http/https的知识。http请求的组成。\n2. 消息转化(参数是**如何解析**的，**什么时候解析**的，我们给常用的注解是如何实现的)\n3. springMVC拦截器的实现原理\n4. 其他，如消息监控的植入actuator,zipkin等。\n\n### spring的启动\n>spring启动的时候会扫描各个controller，并默认以单例的形式生成各个handler(controller类),handlerMethod().\n\n### 一个rest请求的到来\n#### 入口\n> 如果入口是从最开始说的话其实是从tomcat的各个过滤器(filter)顺序调用过来的，再由httpServlet拉起springMVC框架的service方法\n确定方法类型后执行doPost，或者doGet。下面只会会将几个重要过程领出来聊一聊\n\n#### DispatcherServlet.doDispatch()\n>先从10个handlerMappings中的找到对应的handlerMapping,然后从这个handlerMapping通过urlPath，找到对应方法的handler\n 并将拦截器加入handler组装成HandlerExecutionChain，如果执行HandlerExecutionChain的时候拦截器返回false方法会在止到这里直接返回。\n 拦截器如果通过，找到能够使用这个handler(Method Handler)的handlerAdapter（一般是这个:RequestMappingHandlerAdapter）\n （原本有三个找到对应的支持的） 供以后使用，也就是下面的这个方法：\n#### ServletInvocableHandlerMethod.invokeAndHandle()\n>执行里面的方法，并处理返回值\n a. 设置响应状态，\n b. 设置mavContainer处理状态设置为未处理完毕。\n c. 并对返回接口进行处理,responseBody的注解会在这里使用(用于找到返回值的handler)，并进行消息转化(json)\n#### InvocableHandlerMethod.invokeForRequest() \n>这里会解析并映射入参，这里会有各种解析参数的解析器，找到对应的解析器后然后会根据参数名字到request里面取值。\n后放入到对应的参数列表里面再将参数放入代理方法执行invoke，并返回业务代码里的返回值。\nspringMVC的字段名在request里面是这样的：如果是get方法一般就是上面的parameterMap里面的。\n ","slug":"springMVC源码自探","published":1,"updated":"2019-04-20T10:57:29.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0hkxqgs0002ektv1n7ny2jx","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"springMVC-源码自探\"><a href=\"#springMVC-源码自探\" class=\"headerlink\" title=\"springMVC 源码自探\"></a>springMVC 源码自探</h2><p><img src=\"http://ww1.sinaimg.cn/large/006Cwrd9gy1fxskn2tpksj31hc0u0guq.jpg\" alt=\"I love it when a plan comes together.\"></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>弄清楚springMVC流程对我们写rest接口有莫大的好处，因为和它绑定在一起的还有这些重要的东西：</p>\n<blockquote>\n<ol>\n<li>http/https的知识。http请求的组成。</li>\n<li>消息转化(参数是<strong>如何解析</strong>的，<strong>什么时候解析</strong>的，我们给常用的注解是如何实现的)</li>\n<li>springMVC拦截器的实现原理</li>\n<li>其他，如消息监控的植入actuator,zipkin等。</li>\n</ol>\n</blockquote>\n<h3 id=\"spring的启动\"><a href=\"#spring的启动\" class=\"headerlink\" title=\"spring的启动\"></a>spring的启动</h3><blockquote>\n<p>spring启动的时候会扫描各个controller，并默认以单例的形式生成各个handler(controller类),handlerMethod().</p>\n</blockquote>\n<h3 id=\"一个rest请求的到来\"><a href=\"#一个rest请求的到来\" class=\"headerlink\" title=\"一个rest请求的到来\"></a>一个rest请求的到来</h3><h4 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h4><blockquote>\n<p>如果入口是从最开始说的话其实是从tomcat的各个过滤器(filter)顺序调用过来的，再由httpServlet拉起springMVC框架的service方法<br>确定方法类型后执行doPost，或者doGet。下面只会会将几个重要过程领出来聊一聊</p>\n</blockquote>\n<h4 id=\"DispatcherServlet-doDispatch\"><a href=\"#DispatcherServlet-doDispatch\" class=\"headerlink\" title=\"DispatcherServlet.doDispatch()\"></a>DispatcherServlet.doDispatch()</h4><blockquote>\n<p>先从10个handlerMappings中的找到对应的handlerMapping,然后从这个handlerMapping通过urlPath，找到对应方法的handler<br> 并将拦截器加入handler组装成HandlerExecutionChain，如果执行HandlerExecutionChain的时候拦截器返回false方法会在止到这里直接返回。<br> 拦截器如果通过，找到能够使用这个handler(Method Handler)的handlerAdapter（一般是这个:RequestMappingHandlerAdapter）<br> （原本有三个找到对应的支持的） 供以后使用，也就是下面的这个方法：</p>\n</blockquote>\n<h4 id=\"ServletInvocableHandlerMethod-invokeAndHandle\"><a href=\"#ServletInvocableHandlerMethod-invokeAndHandle\" class=\"headerlink\" title=\"ServletInvocableHandlerMethod.invokeAndHandle()\"></a>ServletInvocableHandlerMethod.invokeAndHandle()</h4><blockquote>\n<p>执行里面的方法，并处理返回值<br> a. 设置响应状态，<br> b. 设置mavContainer处理状态设置为未处理完毕。<br> c. 并对返回接口进行处理,responseBody的注解会在这里使用(用于找到返回值的handler)，并进行消息转化(json)</p>\n</blockquote>\n<h4 id=\"InvocableHandlerMethod-invokeForRequest\"><a href=\"#InvocableHandlerMethod-invokeForRequest\" class=\"headerlink\" title=\"InvocableHandlerMethod.invokeForRequest()\"></a>InvocableHandlerMethod.invokeForRequest()</h4><blockquote>\n<p>这里会解析并映射入参，这里会有各种解析参数的解析器，找到对应的解析器后然后会根据参数名字到request里面取值。<br>后放入到对应的参数列表里面再将参数放入代理方法执行invoke，并返回业务代码里的返回值。<br>springMVC的字段名在request里面是这样的：如果是get方法一般就是上面的parameterMap里面的。</p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"springMVC-源码自探\"><a href=\"#springMVC-源码自探\" class=\"headerlink\" title=\"springMVC 源码自探\"></a>springMVC 源码自探</h2><p><img src=\"http://ww1.sinaimg.cn/large/006Cwrd9gy1fxskn2tpksj31hc0u0guq.jpg\" alt=\"I love it when a plan comes together.\"></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>弄清楚springMVC流程对我们写rest接口有莫大的好处，因为和它绑定在一起的还有这些重要的东西：</p>\n<blockquote>\n<ol>\n<li>http/https的知识。http请求的组成。</li>\n<li>消息转化(参数是<strong>如何解析</strong>的，<strong>什么时候解析</strong>的，我们给常用的注解是如何实现的)</li>\n<li>springMVC拦截器的实现原理</li>\n<li>其他，如消息监控的植入actuator,zipkin等。</li>\n</ol>\n</blockquote>\n<h3 id=\"spring的启动\"><a href=\"#spring的启动\" class=\"headerlink\" title=\"spring的启动\"></a>spring的启动</h3><blockquote>\n<p>spring启动的时候会扫描各个controller，并默认以单例的形式生成各个handler(controller类),handlerMethod().</p>\n</blockquote>\n<h3 id=\"一个rest请求的到来\"><a href=\"#一个rest请求的到来\" class=\"headerlink\" title=\"一个rest请求的到来\"></a>一个rest请求的到来</h3><h4 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h4><blockquote>\n<p>如果入口是从最开始说的话其实是从tomcat的各个过滤器(filter)顺序调用过来的，再由httpServlet拉起springMVC框架的service方法<br>确定方法类型后执行doPost，或者doGet。下面只会会将几个重要过程领出来聊一聊</p>\n</blockquote>\n<h4 id=\"DispatcherServlet-doDispatch\"><a href=\"#DispatcherServlet-doDispatch\" class=\"headerlink\" title=\"DispatcherServlet.doDispatch()\"></a>DispatcherServlet.doDispatch()</h4><blockquote>\n<p>先从10个handlerMappings中的找到对应的handlerMapping,然后从这个handlerMapping通过urlPath，找到对应方法的handler<br> 并将拦截器加入handler组装成HandlerExecutionChain，如果执行HandlerExecutionChain的时候拦截器返回false方法会在止到这里直接返回。<br> 拦截器如果通过，找到能够使用这个handler(Method Handler)的handlerAdapter（一般是这个:RequestMappingHandlerAdapter）<br> （原本有三个找到对应的支持的） 供以后使用，也就是下面的这个方法：</p>\n</blockquote>\n<h4 id=\"ServletInvocableHandlerMethod-invokeAndHandle\"><a href=\"#ServletInvocableHandlerMethod-invokeAndHandle\" class=\"headerlink\" title=\"ServletInvocableHandlerMethod.invokeAndHandle()\"></a>ServletInvocableHandlerMethod.invokeAndHandle()</h4><blockquote>\n<p>执行里面的方法，并处理返回值<br> a. 设置响应状态，<br> b. 设置mavContainer处理状态设置为未处理完毕。<br> c. 并对返回接口进行处理,responseBody的注解会在这里使用(用于找到返回值的handler)，并进行消息转化(json)</p>\n</blockquote>\n<h4 id=\"InvocableHandlerMethod-invokeForRequest\"><a href=\"#InvocableHandlerMethod-invokeForRequest\" class=\"headerlink\" title=\"InvocableHandlerMethod.invokeForRequest()\"></a>InvocableHandlerMethod.invokeForRequest()</h4><blockquote>\n<p>这里会解析并映射入参，这里会有各种解析参数的解析器，找到对应的解析器后然后会根据参数名字到request里面取值。<br>后放入到对应的参数列表里面再将参数放入代理方法执行invoke，并返回业务代码里的返回值。<br>springMVC的字段名在request里面是这样的：如果是get方法一般就是上面的parameterMap里面的。</p>\n</blockquote>\n"},{"title":"位运算的那些骚操作","date":"2019-01-28T04:58:21.000Z","_content":"\n## 前言\n> 今天读到了大佬**[石杉]**的一篇有关算法的文章，决定记录一下这种花操作，虽然之前刷leetCode看到过这样的操作，但是还是容易忘记，所以在这里整理下。后面也思考了有关这个算法的一些扩展。\n\n\n## 起因\n>一道说简单又不那么好对付的算法题：数组里有一个不同的数，剩余里都是两两相同，找出这个数，时间复杂度O(n),空间复杂度常数O(1).\n示例:\n输入: [2,2,1]    \n输出: 1\n\n### 解答\n>咋一看其实是很简单的，随便用个map，或者排序一下就可以，但是空间复杂度为O(1)的,这就不能用map了。时间复杂度是O(n),所以不能排序。\n好像把我们的所有方法都赶尽杀绝了，突然脑袋一片空白。。。\n\n>还是直接说答案吧，技巧是使用未操作。每个数异或自己，为零。剩余的就是那个单独的数了\n\n```java\n  // 代码简单就不贴了\n```\n\n## 进阶\n>数组里有两个不同的数，剩余里都是两两相同，找出这两个数，时间复杂度O(n),空间复杂度常数O(1).\n示例:\n输入: [2,2,1,3]    \n输出: 1,3\n\n### 解答\n> 如果还是使用刚刚的方法好像是没戏了，因为最后只留下了一个数。那怎么解答啊？\n答案的起点其实也是在这里，最后剩下的这个数也是有信息的，那就是这两个数异或一定不为0，抓住这个信息。\n我们利用不为0的那个位，将数组**按这位是否是1**(比如是第三位)，拆分开来。那么就形成了两个题目1的情况了，得解。\n\n```java\npublic class findDiff{\n\tpublic static void main(String[] args) {\n      int[] arr = new int[50];\n      for (int i = 0; i < arr.length>>1; i++) {\n        arr[2*i] = i;\n        arr[2*i +1] = i;\n      }\n      // 修改其中一个，生成两个不同的数\n      arr[23] = 365;\n      method(arr);\n   }\n    \n  public static void method (int[] arr) {\n    int result = 0;\n    for (int i : arr) {\n      result ^= i;\n    }\n    int bitIndex = 0;\n    while (((result >> bitIndex) & 1) == 0){\n      bitIndex ++;\n    }\n    // 找到那个为1 的位\n    int left = 0, right = arr.length - 1;\n    int temp = arr[0];\n    while (left <= right){\n      int i = 1 & (temp >> bitIndex);\n      if (i == 1){\n        // 填进来，取后一位\n        arr[left] = temp;\n        temp = arr[++left];\n      } else { // 将当前的数交换出来\n        int temp1 = temp;\n        temp = arr[right];\n        arr[right] = temp1;\n        right --;\n      }\n    }\n    int leftNumber = 0;\n    for (int i = 0; i < left; i++) {\n      leftNumber ^= arr[i];\n    }\n    int rightNumber = 0;\n    for (int i = arr.length - 1; i >= left; i--) {\n      rightNumber ^= arr[i];\n    }\n    System.out.println(leftNumber+ \",\" + rightNumber);\n  }\n}\n```\n\n## 继续推广\n>数组里有3个不同的数，剩余里都是两两相同，找出这三个数，时间复杂度O(n),空间复杂度常数O(1).\n示例:\n输入: [2,2,1,3,5]    \n输出: 1,3，5\n\n### 解答\n> 如果还是使用刚刚的2方法好像是没戏了，因为两个数的抑或可能覆盖另外一个数的值。那有要怎么办啊。\n答案的起点其实也是在这里，最后剩下的这个数也是有信息的，那就是这两个数异或一定不为0，抓住这个信息。\n\n\n\n\n","source":"_posts/位运算的那些骚操作.md","raw":"---\ntitle: 位运算的那些骚操作\ndate: 2019-01-28 12:58:21\ntags: [算法, leetcode]\ncategories: [算法]\n---\n\n## 前言\n> 今天读到了大佬**[石杉]**的一篇有关算法的文章，决定记录一下这种花操作，虽然之前刷leetCode看到过这样的操作，但是还是容易忘记，所以在这里整理下。后面也思考了有关这个算法的一些扩展。\n\n\n## 起因\n>一道说简单又不那么好对付的算法题：数组里有一个不同的数，剩余里都是两两相同，找出这个数，时间复杂度O(n),空间复杂度常数O(1).\n示例:\n输入: [2,2,1]    \n输出: 1\n\n### 解答\n>咋一看其实是很简单的，随便用个map，或者排序一下就可以，但是空间复杂度为O(1)的,这就不能用map了。时间复杂度是O(n),所以不能排序。\n好像把我们的所有方法都赶尽杀绝了，突然脑袋一片空白。。。\n\n>还是直接说答案吧，技巧是使用未操作。每个数异或自己，为零。剩余的就是那个单独的数了\n\n```java\n  // 代码简单就不贴了\n```\n\n## 进阶\n>数组里有两个不同的数，剩余里都是两两相同，找出这两个数，时间复杂度O(n),空间复杂度常数O(1).\n示例:\n输入: [2,2,1,3]    \n输出: 1,3\n\n### 解答\n> 如果还是使用刚刚的方法好像是没戏了，因为最后只留下了一个数。那怎么解答啊？\n答案的起点其实也是在这里，最后剩下的这个数也是有信息的，那就是这两个数异或一定不为0，抓住这个信息。\n我们利用不为0的那个位，将数组**按这位是否是1**(比如是第三位)，拆分开来。那么就形成了两个题目1的情况了，得解。\n\n```java\npublic class findDiff{\n\tpublic static void main(String[] args) {\n      int[] arr = new int[50];\n      for (int i = 0; i < arr.length>>1; i++) {\n        arr[2*i] = i;\n        arr[2*i +1] = i;\n      }\n      // 修改其中一个，生成两个不同的数\n      arr[23] = 365;\n      method(arr);\n   }\n    \n  public static void method (int[] arr) {\n    int result = 0;\n    for (int i : arr) {\n      result ^= i;\n    }\n    int bitIndex = 0;\n    while (((result >> bitIndex) & 1) == 0){\n      bitIndex ++;\n    }\n    // 找到那个为1 的位\n    int left = 0, right = arr.length - 1;\n    int temp = arr[0];\n    while (left <= right){\n      int i = 1 & (temp >> bitIndex);\n      if (i == 1){\n        // 填进来，取后一位\n        arr[left] = temp;\n        temp = arr[++left];\n      } else { // 将当前的数交换出来\n        int temp1 = temp;\n        temp = arr[right];\n        arr[right] = temp1;\n        right --;\n      }\n    }\n    int leftNumber = 0;\n    for (int i = 0; i < left; i++) {\n      leftNumber ^= arr[i];\n    }\n    int rightNumber = 0;\n    for (int i = arr.length - 1; i >= left; i--) {\n      rightNumber ^= arr[i];\n    }\n    System.out.println(leftNumber+ \",\" + rightNumber);\n  }\n}\n```\n\n## 继续推广\n>数组里有3个不同的数，剩余里都是两两相同，找出这三个数，时间复杂度O(n),空间复杂度常数O(1).\n示例:\n输入: [2,2,1,3,5]    \n输出: 1,3，5\n\n### 解答\n> 如果还是使用刚刚的2方法好像是没戏了，因为两个数的抑或可能覆盖另外一个数的值。那有要怎么办啊。\n答案的起点其实也是在这里，最后剩下的这个数也是有信息的，那就是这两个数异或一定不为0，抓住这个信息。\n\n\n\n\n","slug":"位运算的那些骚操作","published":1,"updated":"2019-01-30T04:59:34.132Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0hkxqh30005ektv3wgz6qi7","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>今天读到了大佬<strong>[石杉]</strong>的一篇有关算法的文章，决定记录一下这种花操作，虽然之前刷leetCode看到过这样的操作，但是还是容易忘记，所以在这里整理下。后面也思考了有关这个算法的一些扩展。</p>\n</blockquote>\n<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><blockquote>\n<p>一道说简单又不那么好对付的算法题：数组里有一个不同的数，剩余里都是两两相同，找出这个数，时间复杂度O(n),空间复杂度常数O(1).<br>示例:<br>输入: [2,2,1]<br>输出: 1</p>\n</blockquote>\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><blockquote>\n<p>咋一看其实是很简单的，随便用个map，或者排序一下就可以，但是空间复杂度为O(1)的,这就不能用map了。时间复杂度是O(n),所以不能排序。<br>好像把我们的所有方法都赶尽杀绝了，突然脑袋一片空白。。。</p>\n</blockquote>\n<blockquote>\n<p>还是直接说答案吧，技巧是使用未操作。每个数异或自己，为零。剩余的就是那个单独的数了</p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token comment\" spellcheck=\"true\">// 代码简单就不贴了</span>\n</code></pre>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><blockquote>\n<p>数组里有两个不同的数，剩余里都是两两相同，找出这两个数，时间复杂度O(n),空间复杂度常数O(1).<br>示例:<br>输入: [2,2,1,3]<br>输出: 1,3</p>\n</blockquote>\n<h3 id=\"解答-1\"><a href=\"#解答-1\" class=\"headerlink\" title=\"解答\"></a>解答</h3><blockquote>\n<p>如果还是使用刚刚的方法好像是没戏了，因为最后只留下了一个数。那怎么解答啊？<br>答案的起点其实也是在这里，最后剩下的这个数也是有信息的，那就是这两个数异或一定不为0，抓住这个信息。<br>我们利用不为0的那个位，将数组<strong>按这位是否是1</strong>(比如是第三位)，拆分开来。那么就形成了两个题目1的情况了，得解。</p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">findDiff</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">50</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token operator\">>></span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        arr<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token operator\">*</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        arr<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token operator\">*</span>i <span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 修改其中一个，生成两个不同的数</span>\n      arr<span class=\"token punctuation\">[</span><span class=\"token number\">23</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">365</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">method</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">method</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">:</span> arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      result <span class=\"token operator\">^=</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> bitIndex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>result <span class=\"token operator\">>></span> bitIndex<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      bitIndex <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 找到那个为1 的位</span>\n    <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> right <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;=</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>temp <span class=\"token operator\">>></span> bitIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 填进来，取后一位</span>\n        arr<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n        temp <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 将当前的数交换出来</span>\n        <span class=\"token keyword\">int</span> temp1 <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n        temp <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        arr<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp1<span class=\"token punctuation\">;</span>\n        right <span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> leftNumber <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> left<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      leftNumber <span class=\"token operator\">^=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">int</span> rightNumber <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> left<span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      rightNumber <span class=\"token operator\">^=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>leftNumber<span class=\"token operator\">+</span> <span class=\"token string\">\",\"</span> <span class=\"token operator\">+</span> rightNumber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"继续推广\"><a href=\"#继续推广\" class=\"headerlink\" title=\"继续推广\"></a>继续推广</h2><blockquote>\n<p>数组里有3个不同的数，剩余里都是两两相同，找出这三个数，时间复杂度O(n),空间复杂度常数O(1).<br>示例:<br>输入: [2,2,1,3,5]<br>输出: 1,3，5</p>\n</blockquote>\n<h3 id=\"解答-2\"><a href=\"#解答-2\" class=\"headerlink\" title=\"解答\"></a>解答</h3><blockquote>\n<p>如果还是使用刚刚的2方法好像是没戏了，因为两个数的抑或可能覆盖另外一个数的值。那有要怎么办啊。<br>答案的起点其实也是在这里，最后剩下的这个数也是有信息的，那就是这两个数异或一定不为0，抓住这个信息。</p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>今天读到了大佬<strong>[石杉]</strong>的一篇有关算法的文章，决定记录一下这种花操作，虽然之前刷leetCode看到过这样的操作，但是还是容易忘记，所以在这里整理下。后面也思考了有关这个算法的一些扩展。</p>\n</blockquote>\n<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><blockquote>\n<p>一道说简单又不那么好对付的算法题：数组里有一个不同的数，剩余里都是两两相同，找出这个数，时间复杂度O(n),空间复杂度常数O(1).<br>示例:<br>输入: [2,2,1]<br>输出: 1</p>\n</blockquote>\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><blockquote>\n<p>咋一看其实是很简单的，随便用个map，或者排序一下就可以，但是空间复杂度为O(1)的,这就不能用map了。时间复杂度是O(n),所以不能排序。<br>好像把我们的所有方法都赶尽杀绝了，突然脑袋一片空白。。。</p>\n</blockquote>\n<blockquote>\n<p>还是直接说答案吧，技巧是使用未操作。每个数异或自己，为零。剩余的就是那个单独的数了</p>\n</blockquote>\n<pre><code class=\"java\">  // 代码简单就不贴了\n</code></pre>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><blockquote>\n<p>数组里有两个不同的数，剩余里都是两两相同，找出这两个数，时间复杂度O(n),空间复杂度常数O(1).<br>示例:<br>输入: [2,2,1,3]<br>输出: 1,3</p>\n</blockquote>\n<h3 id=\"解答-1\"><a href=\"#解答-1\" class=\"headerlink\" title=\"解答\"></a>解答</h3><blockquote>\n<p>如果还是使用刚刚的方法好像是没戏了，因为最后只留下了一个数。那怎么解答啊？<br>答案的起点其实也是在这里，最后剩下的这个数也是有信息的，那就是这两个数异或一定不为0，抓住这个信息。<br>我们利用不为0的那个位，将数组<strong>按这位是否是1</strong>(比如是第三位)，拆分开来。那么就形成了两个题目1的情况了，得解。</p>\n</blockquote>\n<pre><code class=\"java\">public class findDiff{\n    public static void main(String[] args) {\n      int[] arr = new int[50];\n      for (int i = 0; i &lt; arr.length&gt;&gt;1; i++) {\n        arr[2*i] = i;\n        arr[2*i +1] = i;\n      }\n      // 修改其中一个，生成两个不同的数\n      arr[23] = 365;\n      method(arr);\n   }\n\n  public static void method (int[] arr) {\n    int result = 0;\n    for (int i : arr) {\n      result ^= i;\n    }\n    int bitIndex = 0;\n    while (((result &gt;&gt; bitIndex) &amp; 1) == 0){\n      bitIndex ++;\n    }\n    // 找到那个为1 的位\n    int left = 0, right = arr.length - 1;\n    int temp = arr[0];\n    while (left &lt;= right){\n      int i = 1 &amp; (temp &gt;&gt; bitIndex);\n      if (i == 1){\n        // 填进来，取后一位\n        arr[left] = temp;\n        temp = arr[++left];\n      } else { // 将当前的数交换出来\n        int temp1 = temp;\n        temp = arr[right];\n        arr[right] = temp1;\n        right --;\n      }\n    }\n    int leftNumber = 0;\n    for (int i = 0; i &lt; left; i++) {\n      leftNumber ^= arr[i];\n    }\n    int rightNumber = 0;\n    for (int i = arr.length - 1; i &gt;= left; i--) {\n      rightNumber ^= arr[i];\n    }\n    System.out.println(leftNumber+ &quot;,&quot; + rightNumber);\n  }\n}\n</code></pre>\n<h2 id=\"继续推广\"><a href=\"#继续推广\" class=\"headerlink\" title=\"继续推广\"></a>继续推广</h2><blockquote>\n<p>数组里有3个不同的数，剩余里都是两两相同，找出这三个数，时间复杂度O(n),空间复杂度常数O(1).<br>示例:<br>输入: [2,2,1,3,5]<br>输出: 1,3，5</p>\n</blockquote>\n<h3 id=\"解答-2\"><a href=\"#解答-2\" class=\"headerlink\" title=\"解答\"></a>解答</h3><blockquote>\n<p>如果还是使用刚刚的2方法好像是没戏了，因为两个数的抑或可能覆盖另外一个数的值。那有要怎么办啊。<br>答案的起点其实也是在这里，最后剩下的这个数也是有信息的，那就是这两个数异或一定不为0，抓住这个信息。</p>\n</blockquote>\n"},{"title":"好了，这下百度(google)不到了怎么办？","date":"2019-09-12T14:25:30.000Z","_content":"\n### 背景\n突然觉得作为一名程序员要面对的东西好多啊,不仅要时刻学习日新月异新的技术栈,还要兼顾老的技术，维护项目，\n这不公司技术栈的迁移变更遇到了一堆问题，不知道是不幸还是有幸，这个活落到我头上了。况且我对这个项目一点不了解，可是没有可是，\n必须解决它，干。\n\n### springCloud的引入(问题的由来)\n将原有的服务改造并引入到springCloud的技术栈，这个简单，配置配好，版本对应好，将jar包的冲突解决后就没啥问题了，\n由于之前都是改造的jar服务，可是这次改造的项目是web项目，也就是war包，一般是拿到tomcat里面启动的，本来改造好后，\n写好Dockerfile镜像，以为可以完好运行的并部署的。可是本地可以完好的运行。但是一部署上去docker日志里面就一直报这个错误：\n>tomcat start failure, fail to create bean servletEndpoint 以及一系列的堆栈信息。\n\n有一点绝望，**本地可以启动成功但是docker里面启动却在这里报什么tomcat启动失败**，实在是郁闷，于是乎开始百度。google。\n\n### 常规解\n按惯例，拿到报错现场的看看是否包含本地项目代码的堆栈，或者什么常规配置的占位符，依赖等等的常见问题，发现没有本地项目代码的堆栈，\n看了下maven树，也不是什么找不到xxx class的maven冲突的问题而且报的错误我也没见过，也不眼熟，，(开始有点慌了,都是些什么项目心里开始嘀咕)，\n于是按着惯例的第二步，拿着最精确的报错信息去百度,百度不到再google，哇，各种各样有一点关联的方法等我都试验了一下，没有任何作用，怎么办？\n有点绝望，都没有没有像我这样的报错，陆续拿了一些其他的错误信息，去百度，看了很多博客都没有找到一丝相关的信息。怎么办？\n\n### 冷静解\n直到我开始觉得百度google没什么意义了，索性放弃搜索了，求自己吧，由于对spring和springboot，还有springCloud的原理\n和启动过程有一定的了解(跟踪过源码启动过程)，我开始自己冷静的分析看问题究竟出在哪里，\n- 第一步：看项目是启动到那个地方出的问题，前面的都完成了那些操作，(能够找到注册中心，并且可以拉取配置)\n- 第二步：查看问题是出在哪一步，仔细查看堆栈信息，将各个报错的信息依次排开依逐个次分析排除，分析堆栈链，按照图片排开是这样\n- 第三步：直到我看到初始化一个bean的时候看他所在的包是在cloud bus里面，但是我看这个cloud bus却又没有在我们项目里面用过。于是我将这个maven包给去除了，\n- 第四步: 重新发布，发现报错信息变化了，这说明确实是找到点子上了，于是再按照相同的方法又走了一遍，又排除了一个maven包，本地启动完好，部署，启动，bingo。\n\n### 思考\n虽然问题解决了，但是有一个大大问号：为什么本地可以启动而部署到docker里面使用java -jar xxx.war的方式启动却会报错呢？\n我也还在继续找这个问题的答案，到时候会公布出来。通过这个案例，我们可以发现得到一些启发：springboot的项目里面没事不要乱加一些jar包\n这会导致springboot 的autoConfigure自动配置一些相关的组件导致不可预测的错误，特别是但是对一个项目完全未知的时候。当然了，\n出错了也大可按照我这种方式来去排除错误啦！\n\n","source":"_posts/好了，这下百度不到了怎么办？.md","raw":"---\ntitle: 好了，这下百度(google)不到了怎么办？\ndate: 2019-09-12 22:25:30\ntags: [springboot, springCloud]\n---\n\n### 背景\n突然觉得作为一名程序员要面对的东西好多啊,不仅要时刻学习日新月异新的技术栈,还要兼顾老的技术，维护项目，\n这不公司技术栈的迁移变更遇到了一堆问题，不知道是不幸还是有幸，这个活落到我头上了。况且我对这个项目一点不了解，可是没有可是，\n必须解决它，干。\n\n### springCloud的引入(问题的由来)\n将原有的服务改造并引入到springCloud的技术栈，这个简单，配置配好，版本对应好，将jar包的冲突解决后就没啥问题了，\n由于之前都是改造的jar服务，可是这次改造的项目是web项目，也就是war包，一般是拿到tomcat里面启动的，本来改造好后，\n写好Dockerfile镜像，以为可以完好运行的并部署的。可是本地可以完好的运行。但是一部署上去docker日志里面就一直报这个错误：\n>tomcat start failure, fail to create bean servletEndpoint 以及一系列的堆栈信息。\n\n有一点绝望，**本地可以启动成功但是docker里面启动却在这里报什么tomcat启动失败**，实在是郁闷，于是乎开始百度。google。\n\n### 常规解\n按惯例，拿到报错现场的看看是否包含本地项目代码的堆栈，或者什么常规配置的占位符，依赖等等的常见问题，发现没有本地项目代码的堆栈，\n看了下maven树，也不是什么找不到xxx class的maven冲突的问题而且报的错误我也没见过，也不眼熟，，(开始有点慌了,都是些什么项目心里开始嘀咕)，\n于是按着惯例的第二步，拿着最精确的报错信息去百度,百度不到再google，哇，各种各样有一点关联的方法等我都试验了一下，没有任何作用，怎么办？\n有点绝望，都没有没有像我这样的报错，陆续拿了一些其他的错误信息，去百度，看了很多博客都没有找到一丝相关的信息。怎么办？\n\n### 冷静解\n直到我开始觉得百度google没什么意义了，索性放弃搜索了，求自己吧，由于对spring和springboot，还有springCloud的原理\n和启动过程有一定的了解(跟踪过源码启动过程)，我开始自己冷静的分析看问题究竟出在哪里，\n- 第一步：看项目是启动到那个地方出的问题，前面的都完成了那些操作，(能够找到注册中心，并且可以拉取配置)\n- 第二步：查看问题是出在哪一步，仔细查看堆栈信息，将各个报错的信息依次排开依逐个次分析排除，分析堆栈链，按照图片排开是这样\n- 第三步：直到我看到初始化一个bean的时候看他所在的包是在cloud bus里面，但是我看这个cloud bus却又没有在我们项目里面用过。于是我将这个maven包给去除了，\n- 第四步: 重新发布，发现报错信息变化了，这说明确实是找到点子上了，于是再按照相同的方法又走了一遍，又排除了一个maven包，本地启动完好，部署，启动，bingo。\n\n### 思考\n虽然问题解决了，但是有一个大大问号：为什么本地可以启动而部署到docker里面使用java -jar xxx.war的方式启动却会报错呢？\n我也还在继续找这个问题的答案，到时候会公布出来。通过这个案例，我们可以发现得到一些启发：springboot的项目里面没事不要乱加一些jar包\n这会导致springboot 的autoConfigure自动配置一些相关的组件导致不可预测的错误，特别是但是对一个项目完全未知的时候。当然了，\n出错了也大可按照我这种方式来去排除错误啦！\n\n","slug":"好了，这下百度不到了怎么办？","published":1,"updated":"2019-09-13T03:49:43.801Z","_id":"ck0hkxqh90008ektvxjfhi4qq","comments":1,"layout":"post","photos":[],"link":"","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>突然觉得作为一名程序员要面对的东西好多啊,不仅要时刻学习日新月异新的技术栈,还要兼顾老的技术，维护项目，<br>这不公司技术栈的迁移变更遇到了一堆问题，不知道是不幸还是有幸，这个活落到我头上了。况且我对这个项目一点不了解，可是没有可是，<br>必须解决它，干。</p>\n<h3 id=\"springCloud的引入-问题的由来\"><a href=\"#springCloud的引入-问题的由来\" class=\"headerlink\" title=\"springCloud的引入(问题的由来)\"></a>springCloud的引入(问题的由来)</h3><p>将原有的服务改造并引入到springCloud的技术栈，这个简单，配置配好，版本对应好，将jar包的冲突解决后就没啥问题了，<br>由于之前都是改造的jar服务，可是这次改造的项目是web项目，也就是war包，一般是拿到tomcat里面启动的，本来改造好后，<br>写好Dockerfile镜像，以为可以完好运行的并部署的。可是本地可以完好的运行。但是一部署上去docker日志里面就一直报这个错误：</p>\n<blockquote>\n<p>tomcat start failure, fail to create bean servletEndpoint 以及一系列的堆栈信息。</p>\n</blockquote>\n<p>有一点绝望，<strong>本地可以启动成功但是docker里面启动却在这里报什么tomcat启动失败</strong>，实在是郁闷，于是乎开始百度。google。</p>\n<h3 id=\"常规解\"><a href=\"#常规解\" class=\"headerlink\" title=\"常规解\"></a>常规解</h3><p>按惯例，拿到报错现场的看看是否包含本地项目代码的堆栈，或者什么常规配置的占位符，依赖等等的常见问题，发现没有本地项目代码的堆栈，<br>看了下maven树，也不是什么找不到xxx class的maven冲突的问题而且报的错误我也没见过，也不眼熟，，(开始有点慌了,都是些什么项目心里开始嘀咕)，<br>于是按着惯例的第二步，拿着最精确的报错信息去百度,百度不到再google，哇，各种各样有一点关联的方法等我都试验了一下，没有任何作用，怎么办？<br>有点绝望，都没有没有像我这样的报错，陆续拿了一些其他的错误信息，去百度，看了很多博客都没有找到一丝相关的信息。怎么办？</p>\n<h3 id=\"冷静解\"><a href=\"#冷静解\" class=\"headerlink\" title=\"冷静解\"></a>冷静解</h3><p>直到我开始觉得百度google没什么意义了，索性放弃搜索了，求自己吧，由于对spring和springboot，还有springCloud的原理<br>和启动过程有一定的了解(跟踪过源码启动过程)，我开始自己冷静的分析看问题究竟出在哪里，</p>\n<ul>\n<li>第一步：看项目是启动到那个地方出的问题，前面的都完成了那些操作，(能够找到注册中心，并且可以拉取配置)</li>\n<li>第二步：查看问题是出在哪一步，仔细查看堆栈信息，将各个报错的信息依次排开依逐个次分析排除，分析堆栈链，按照图片排开是这样</li>\n<li>第三步：直到我看到初始化一个bean的时候看他所在的包是在cloud bus里面，但是我看这个cloud bus却又没有在我们项目里面用过。于是我将这个maven包给去除了，</li>\n<li>第四步: 重新发布，发现报错信息变化了，这说明确实是找到点子上了，于是再按照相同的方法又走了一遍，又排除了一个maven包，本地启动完好，部署，启动，bingo。</li>\n</ul>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p>虽然问题解决了，但是有一个大大问号：为什么本地可以启动而部署到docker里面使用java -jar xxx.war的方式启动却会报错呢？<br>我也还在继续找这个问题的答案，到时候会公布出来。通过这个案例，我们可以发现得到一些启发：springboot的项目里面没事不要乱加一些jar包<br>这会导致springboot 的autoConfigure自动配置一些相关的组件导致不可预测的错误，特别是但是对一个项目完全未知的时候。当然了，<br>出错了也大可按照我这种方式来去排除错误啦！</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>突然觉得作为一名程序员要面对的东西好多啊,不仅要时刻学习日新月异新的技术栈,还要兼顾老的技术，维护项目，<br>这不公司技术栈的迁移变更遇到了一堆问题，不知道是不幸还是有幸，这个活落到我头上了。况且我对这个项目一点不了解，可是没有可是，<br>必须解决它，干。</p>\n<h3 id=\"springCloud的引入-问题的由来\"><a href=\"#springCloud的引入-问题的由来\" class=\"headerlink\" title=\"springCloud的引入(问题的由来)\"></a>springCloud的引入(问题的由来)</h3><p>将原有的服务改造并引入到springCloud的技术栈，这个简单，配置配好，版本对应好，将jar包的冲突解决后就没啥问题了，<br>由于之前都是改造的jar服务，可是这次改造的项目是web项目，也就是war包，一般是拿到tomcat里面启动的，本来改造好后，<br>写好Dockerfile镜像，以为可以完好运行的并部署的。可是本地可以完好的运行。但是一部署上去docker日志里面就一直报这个错误：</p>\n<blockquote>\n<p>tomcat start failure, fail to create bean servletEndpoint 以及一系列的堆栈信息。</p>\n</blockquote>\n<p>有一点绝望，<strong>本地可以启动成功但是docker里面启动却在这里报什么tomcat启动失败</strong>，实在是郁闷，于是乎开始百度。google。</p>\n<h3 id=\"常规解\"><a href=\"#常规解\" class=\"headerlink\" title=\"常规解\"></a>常规解</h3><p>按惯例，拿到报错现场的看看是否包含本地项目代码的堆栈，或者什么常规配置的占位符，依赖等等的常见问题，发现没有本地项目代码的堆栈，<br>看了下maven树，也不是什么找不到xxx class的maven冲突的问题而且报的错误我也没见过，也不眼熟，，(开始有点慌了,都是些什么项目心里开始嘀咕)，<br>于是按着惯例的第二步，拿着最精确的报错信息去百度,百度不到再google，哇，各种各样有一点关联的方法等我都试验了一下，没有任何作用，怎么办？<br>有点绝望，都没有没有像我这样的报错，陆续拿了一些其他的错误信息，去百度，看了很多博客都没有找到一丝相关的信息。怎么办？</p>\n<h3 id=\"冷静解\"><a href=\"#冷静解\" class=\"headerlink\" title=\"冷静解\"></a>冷静解</h3><p>直到我开始觉得百度google没什么意义了，索性放弃搜索了，求自己吧，由于对spring和springboot，还有springCloud的原理<br>和启动过程有一定的了解(跟踪过源码启动过程)，我开始自己冷静的分析看问题究竟出在哪里，</p>\n<ul>\n<li>第一步：看项目是启动到那个地方出的问题，前面的都完成了那些操作，(能够找到注册中心，并且可以拉取配置)</li>\n<li>第二步：查看问题是出在哪一步，仔细查看堆栈信息，将各个报错的信息依次排开依逐个次分析排除，分析堆栈链，按照图片排开是这样</li>\n<li>第三步：直到我看到初始化一个bean的时候看他所在的包是在cloud bus里面，但是我看这个cloud bus却又没有在我们项目里面用过。于是我将这个maven包给去除了，</li>\n<li>第四步: 重新发布，发现报错信息变化了，这说明确实是找到点子上了，于是再按照相同的方法又走了一遍，又排除了一个maven包，本地启动完好，部署，启动，bingo。</li>\n</ul>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p>虽然问题解决了，但是有一个大大问号：为什么本地可以启动而部署到docker里面使用java -jar xxx.war的方式启动却会报错呢？<br>我也还在继续找这个问题的答案，到时候会公布出来。通过这个案例，我们可以发现得到一些启发：springboot的项目里面没事不要乱加一些jar包<br>这会导致springboot 的autoConfigure自动配置一些相关的组件导致不可预测的错误，特别是但是对一个项目完全未知的时候。当然了，<br>出错了也大可按照我这种方式来去排除错误啦！</p>\n"},{"title":"强大的正则:带你获取你想要的各种数据","date":"2019-08-18T07:51:46.000Z","_content":"\n### 说明\n作为程序员，爬虫虽然强大，但是记得规范自己的行为，不要做违法的事情。\n\n### 普通的标签爬取\n普通的标签爬取是最基本的爬取工作直接复制粘贴就可以拿到自己想要的数据了，\n但是很多网站并不会然你这么轻松的就获取到它的数据，很多网站爬取的时候就只是一堆js字符串，我们并不能通过标签拿到\n对应的数据。这种情况写就需要要我们拿出最厉害的杀手锏了：正则！\n\n### 正则的威力\n网页一般都会有他么自己的特点，我们需要做的就是分析它的特点，拿到对应的链接或者内容，但是有一些网站渲染的时候我们拿不到对应的html，拿到的\n只是一堆js字符串，这样我们没法通过xpath或者selector去找到我们想要的内容，我们只好使出杀手锏正则了，说到正则我想大多数人的第一映像应该是\n像号码邮箱这样的校验正则。这只是最基本的应用，厉害的地方就是可以从一堆奇怪的字符串里面提取出自己想要的内容。下面讲两个十分实用的正则。\n\n### 贪心与非贪心，反向引用\n利用正则爬取数据的最核心应该就是贪心与非贪心的应用了，因为网页里面有重复的字符串太常见了，我们首先得找出唯一的字符串，一般情况下是使用**非贪心(.*?)**\n来定位到数据的开始再使用**非贪心(.*?)** 定位到数据的结尾，然后使用 **获取匹配**的替换符号($1, $2, $3)将数据提取出来即可。\n例如我要爬取这段字符串里面的\\<img src=\"www.baidu.com\" alt=\"图片链接\"\\> 的链接只需要使用这个正则\\<img src=\"(.*?)\" alt=\"图片链接\"\\>然后用  $1替换即可。\n\n### 正向预查与反向预查找\n有时候可能有很多种情况都瞒住我们的正则，但是我们只需要和某些字相关的匹配项，我们可以使用预查找，意思就是后面或者前面得是我指定的那些值的匹配项我才需要：\n例如：aaabbbaaacccaaaddd 如果我只要后面是ccc的那个aaa字符串我们可以使用\n**正向预查**：aaa(?=ccc)来匹配，这个只会匹配第二个aaa，又或者我们只要前面是ccc的那个aaa我们可以使用\n**反向预查**：aaa(?<=ccc)这样会匹配第三个aaa，也就是aaa的左边是ccc的那个aaa。\n\n### 来实战一把：\n比如我爬取一个微博的博文链接，爬取下来的全部都是这样的js字符串：![](/images/20190820225155.png)\n我没有办法使用xpath或者selector去获取内容，使用正则获取原网页的图片并替换之后获取到如下内容：\n\"https://wx4.sinaimg.cn/large/76ad419cly1g1f1gxgaiuj20gg088myo.jpg\"。\n\n","source":"_posts/强大的正则-带你获取你想要的各种数据.md","raw":"---\ntitle: '强大的正则:带你获取你想要的各种数据'\ndate: 2019-08-18 15:51:46\ntags: [正则]\n---\n\n### 说明\n作为程序员，爬虫虽然强大，但是记得规范自己的行为，不要做违法的事情。\n\n### 普通的标签爬取\n普通的标签爬取是最基本的爬取工作直接复制粘贴就可以拿到自己想要的数据了，\n但是很多网站并不会然你这么轻松的就获取到它的数据，很多网站爬取的时候就只是一堆js字符串，我们并不能通过标签拿到\n对应的数据。这种情况写就需要要我们拿出最厉害的杀手锏了：正则！\n\n### 正则的威力\n网页一般都会有他么自己的特点，我们需要做的就是分析它的特点，拿到对应的链接或者内容，但是有一些网站渲染的时候我们拿不到对应的html，拿到的\n只是一堆js字符串，这样我们没法通过xpath或者selector去找到我们想要的内容，我们只好使出杀手锏正则了，说到正则我想大多数人的第一映像应该是\n像号码邮箱这样的校验正则。这只是最基本的应用，厉害的地方就是可以从一堆奇怪的字符串里面提取出自己想要的内容。下面讲两个十分实用的正则。\n\n### 贪心与非贪心，反向引用\n利用正则爬取数据的最核心应该就是贪心与非贪心的应用了，因为网页里面有重复的字符串太常见了，我们首先得找出唯一的字符串，一般情况下是使用**非贪心(.*?)**\n来定位到数据的开始再使用**非贪心(.*?)** 定位到数据的结尾，然后使用 **获取匹配**的替换符号($1, $2, $3)将数据提取出来即可。\n例如我要爬取这段字符串里面的\\<img src=\"www.baidu.com\" alt=\"图片链接\"\\> 的链接只需要使用这个正则\\<img src=\"(.*?)\" alt=\"图片链接\"\\>然后用  $1替换即可。\n\n### 正向预查与反向预查找\n有时候可能有很多种情况都瞒住我们的正则，但是我们只需要和某些字相关的匹配项，我们可以使用预查找，意思就是后面或者前面得是我指定的那些值的匹配项我才需要：\n例如：aaabbbaaacccaaaddd 如果我只要后面是ccc的那个aaa字符串我们可以使用\n**正向预查**：aaa(?=ccc)来匹配，这个只会匹配第二个aaa，又或者我们只要前面是ccc的那个aaa我们可以使用\n**反向预查**：aaa(?<=ccc)这样会匹配第三个aaa，也就是aaa的左边是ccc的那个aaa。\n\n### 来实战一把：\n比如我爬取一个微博的博文链接，爬取下来的全部都是这样的js字符串：![](/images/20190820225155.png)\n我没有办法使用xpath或者selector去获取内容，使用正则获取原网页的图片并替换之后获取到如下内容：\n\"https://wx4.sinaimg.cn/large/76ad419cly1g1f1gxgaiuj20gg088myo.jpg\"。\n\n","slug":"强大的正则-带你获取你想要的各种数据","published":1,"updated":"2019-09-05T15:06:45.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0hkxqhb000aektvbf2vuz6o","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>作为程序员，爬虫虽然强大，但是记得规范自己的行为，不要做违法的事情。</p>\n<h3 id=\"普通的标签爬取\"><a href=\"#普通的标签爬取\" class=\"headerlink\" title=\"普通的标签爬取\"></a>普通的标签爬取</h3><p>普通的标签爬取是最基本的爬取工作直接复制粘贴就可以拿到自己想要的数据了，<br>但是很多网站并不会然你这么轻松的就获取到它的数据，很多网站爬取的时候就只是一堆js字符串，我们并不能通过标签拿到<br>对应的数据。这种情况写就需要要我们拿出最厉害的杀手锏了：正则！</p>\n<h3 id=\"正则的威力\"><a href=\"#正则的威力\" class=\"headerlink\" title=\"正则的威力\"></a>正则的威力</h3><p>网页一般都会有他么自己的特点，我们需要做的就是分析它的特点，拿到对应的链接或者内容，但是有一些网站渲染的时候我们拿不到对应的html，拿到的<br>只是一堆js字符串，这样我们没法通过xpath或者selector去找到我们想要的内容，我们只好使出杀手锏正则了，说到正则我想大多数人的第一映像应该是<br>像号码邮箱这样的校验正则。这只是最基本的应用，厉害的地方就是可以从一堆奇怪的字符串里面提取出自己想要的内容。下面讲两个十分实用的正则。</p>\n<h3 id=\"贪心与非贪心，反向引用\"><a href=\"#贪心与非贪心，反向引用\" class=\"headerlink\" title=\"贪心与非贪心，反向引用\"></a>贪心与非贪心，反向引用</h3><p>利用正则爬取数据的最核心应该就是贪心与非贪心的应用了，因为网页里面有重复的字符串太常见了，我们首先得找出唯一的字符串，一般情况下是使用<strong>非贪心(.*?)</strong><br>来定位到数据的开始再使用<strong>非贪心(.*?)</strong> 定位到数据的结尾，然后使用 <strong>获取匹配</strong>的替换符号($1, $2, $3)将数据提取出来即可。<br>例如我要爬取这段字符串里面的\\&lt;img src=”<a href=\"http://www.baidu.com&quot;\" target=\"_blank\" rel=\"noopener\">www.baidu.com&quot;</a> alt=”图片链接”> 的链接只需要使用这个正则\\&lt;img src=”(.*?)” alt=”图片链接”>然后用  $1替换即可。</p>\n<h3 id=\"正向预查与反向预查找\"><a href=\"#正向预查与反向预查找\" class=\"headerlink\" title=\"正向预查与反向预查找\"></a>正向预查与反向预查找</h3><p>有时候可能有很多种情况都瞒住我们的正则，但是我们只需要和某些字相关的匹配项，我们可以使用预查找，意思就是后面或者前面得是我指定的那些值的匹配项我才需要：<br>例如：aaabbbaaacccaaaddd 如果我只要后面是ccc的那个aaa字符串我们可以使用<br><strong>正向预查</strong>：aaa(?=ccc)来匹配，这个只会匹配第二个aaa，又或者我们只要前面是ccc的那个aaa我们可以使用<br><strong>反向预查</strong>：aaa(?&lt;=ccc)这样会匹配第三个aaa，也就是aaa的左边是ccc的那个aaa。</p>\n<h3 id=\"来实战一把：\"><a href=\"#来实战一把：\" class=\"headerlink\" title=\"来实战一把：\"></a>来实战一把：</h3><p>比如我爬取一个微博的博文链接，爬取下来的全部都是这样的js字符串：<img src=\"/images/20190820225155.png\" alt=\"\"><br>我没有办法使用xpath或者selector去获取内容，使用正则获取原网页的图片并替换之后获取到如下内容：<br>“<a href=\"https://wx4.sinaimg.cn/large/76ad419cly1g1f1gxgaiuj20gg088myo.jpg&quot;。\" target=\"_blank\" rel=\"noopener\">https://wx4.sinaimg.cn/large/76ad419cly1g1f1gxgaiuj20gg088myo.jpg&quot;。</a></p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>作为程序员，爬虫虽然强大，但是记得规范自己的行为，不要做违法的事情。</p>\n<h3 id=\"普通的标签爬取\"><a href=\"#普通的标签爬取\" class=\"headerlink\" title=\"普通的标签爬取\"></a>普通的标签爬取</h3><p>普通的标签爬取是最基本的爬取工作直接复制粘贴就可以拿到自己想要的数据了，<br>但是很多网站并不会然你这么轻松的就获取到它的数据，很多网站爬取的时候就只是一堆js字符串，我们并不能通过标签拿到<br>对应的数据。这种情况写就需要要我们拿出最厉害的杀手锏了：正则！</p>\n<h3 id=\"正则的威力\"><a href=\"#正则的威力\" class=\"headerlink\" title=\"正则的威力\"></a>正则的威力</h3><p>网页一般都会有他么自己的特点，我们需要做的就是分析它的特点，拿到对应的链接或者内容，但是有一些网站渲染的时候我们拿不到对应的html，拿到的<br>只是一堆js字符串，这样我们没法通过xpath或者selector去找到我们想要的内容，我们只好使出杀手锏正则了，说到正则我想大多数人的第一映像应该是<br>像号码邮箱这样的校验正则。这只是最基本的应用，厉害的地方就是可以从一堆奇怪的字符串里面提取出自己想要的内容。下面讲两个十分实用的正则。</p>\n<h3 id=\"贪心与非贪心，反向引用\"><a href=\"#贪心与非贪心，反向引用\" class=\"headerlink\" title=\"贪心与非贪心，反向引用\"></a>贪心与非贪心，反向引用</h3><p>利用正则爬取数据的最核心应该就是贪心与非贪心的应用了，因为网页里面有重复的字符串太常见了，我们首先得找出唯一的字符串，一般情况下是使用<strong>非贪心(.*?)</strong><br>来定位到数据的开始再使用<strong>非贪心(.*?)</strong> 定位到数据的结尾，然后使用 <strong>获取匹配</strong>的替换符号($1, $2, $3)将数据提取出来即可。<br>例如我要爬取这段字符串里面的\\&lt;img src=”<a href=\"http://www.baidu.com&quot;\" target=\"_blank\" rel=\"noopener\">www.baidu.com&quot;</a> alt=”图片链接”> 的链接只需要使用这个正则\\&lt;img src=”(.*?)” alt=”图片链接”>然后用  $1替换即可。</p>\n<h3 id=\"正向预查与反向预查找\"><a href=\"#正向预查与反向预查找\" class=\"headerlink\" title=\"正向预查与反向预查找\"></a>正向预查与反向预查找</h3><p>有时候可能有很多种情况都瞒住我们的正则，但是我们只需要和某些字相关的匹配项，我们可以使用预查找，意思就是后面或者前面得是我指定的那些值的匹配项我才需要：<br>例如：aaabbbaaacccaaaddd 如果我只要后面是ccc的那个aaa字符串我们可以使用<br><strong>正向预查</strong>：aaa(?=ccc)来匹配，这个只会匹配第二个aaa，又或者我们只要前面是ccc的那个aaa我们可以使用<br><strong>反向预查</strong>：aaa(?&lt;=ccc)这样会匹配第三个aaa，也就是aaa的左边是ccc的那个aaa。</p>\n<h3 id=\"来实战一把：\"><a href=\"#来实战一把：\" class=\"headerlink\" title=\"来实战一把：\"></a>来实战一把：</h3><p>比如我爬取一个微博的博文链接，爬取下来的全部都是这样的js字符串：<img src=\"/images/20190820225155.png\" alt=\"\"><br>我没有办法使用xpath或者selector去获取内容，使用正则获取原网页的图片并替换之后获取到如下内容：<br>“<a href=\"https://wx4.sinaimg.cn/large/76ad419cly1g1f1gxgaiuj20gg088myo.jpg&quot;。\" target=\"_blank\" rel=\"noopener\">https://wx4.sinaimg.cn/large/76ad419cly1g1f1gxgaiuj20gg088myo.jpg&quot;。</a></p>\n"},{"title":"技术人员有关技能方面的一点感悟","date":"2019-06-01T15:42:39.000Z","_content":"## 前言\n作为一名技术人员随着，随着接触的技术越来越多，越来越杂，我便发现要想彻底掌握一项技能，\n是需要循序渐进有,有理有序的进行，每当接触一门新的技术点的手时候，这几点需要我们值得注意。\n\n## 是什么？\n> 初步了解技术，需要知道，东西的概念，与基本知识，由那些东西组成，将一些基本概念映入脑海，以后用的时候就是这些东西了.\n\n## 怎么用？\n> 知道如何去使用,严格的使用步骤是什么，会不会有什么坑，自己去实践一遍，看看用的情况怎么样，测一下，他所说的一些亮点，是不是那么回事。\n> 这时候还不能急着去看什么原理啥的，看了有什么用？你能写出来？都还不能用，原理有何用？也就吹吹嘴皮子，干不了实事。\n\n## 什么时候用？\n> 能用才是开始，但是我们需要知道什么时候用，不是拿来就乱用，要明白这个技能，是用来解决什么问题的，在这期间\n> 会涉及到这个东西的优点.他的优点往往就是他的用处。\n\n## 缺点是什么？\n> 知道什么时候用，还需要知道避免什么时候用，这就是这个东西的缺点，可能用了还不如不用。就拿并发的一些工具类ConcurrentHashMap来说，如果经过逃逸分析，这个map本身就不会逃逸，\n那你还在用，反而会降低性能，虽然开启jvm的逃逸分析后可能会同步消除，但是稍微复杂点，也消除不了。\n\n## 原理你知道么？\n> 到目前我们已经知道这个是什么，也知道什么时候该用什么时候不要用，各种优缺点了，这个时候我们最好是去了解他的原理。\n> 这个看上去是一个乏味的工作，但是不仅仅对在面试上有用，对我们我们学习一些新的技能也很有帮助，因为很有可能他们的原理就相同或者类似，\n就像我们记忆单词的词根一样，这还会对之前的那些东西进行进一步升华。就好比我学习并发工具类的源码的时候，发现那些工具类基本都使用aqs来实现他们的同步功能，\n使用volatile + CAS， 尾插入，等思想。知道这些我们自己都可以不用工具类来实现对应的功能。比如让你不要使用工具类来达到异步转同步，你怎么做？\n不让我用工具类，那我就像他们一样写不久完事了？声明一个volatile变量，自旋判断即可，但是如果需要考虑性能，可能就要更复杂些了，比如需要响应中断，\n需要防止饥饿，防止过度消耗cpu，等等。那我们就需要做更多的工作，还要验证自己工具类的实用性。这些的工作量是比较大的。也需要我们队原理了解的更加全面。\n","source":"_posts/技术人员有关技能方面的一点感悟.md","raw":"---\ntitle: 技术人员有关技能方面的一点感悟\ndate: 2019-06-01 23:42:39\ntags:\n---\n## 前言\n作为一名技术人员随着，随着接触的技术越来越多，越来越杂，我便发现要想彻底掌握一项技能，\n是需要循序渐进有,有理有序的进行，每当接触一门新的技术点的手时候，这几点需要我们值得注意。\n\n## 是什么？\n> 初步了解技术，需要知道，东西的概念，与基本知识，由那些东西组成，将一些基本概念映入脑海，以后用的时候就是这些东西了.\n\n## 怎么用？\n> 知道如何去使用,严格的使用步骤是什么，会不会有什么坑，自己去实践一遍，看看用的情况怎么样，测一下，他所说的一些亮点，是不是那么回事。\n> 这时候还不能急着去看什么原理啥的，看了有什么用？你能写出来？都还不能用，原理有何用？也就吹吹嘴皮子，干不了实事。\n\n## 什么时候用？\n> 能用才是开始，但是我们需要知道什么时候用，不是拿来就乱用，要明白这个技能，是用来解决什么问题的，在这期间\n> 会涉及到这个东西的优点.他的优点往往就是他的用处。\n\n## 缺点是什么？\n> 知道什么时候用，还需要知道避免什么时候用，这就是这个东西的缺点，可能用了还不如不用。就拿并发的一些工具类ConcurrentHashMap来说，如果经过逃逸分析，这个map本身就不会逃逸，\n那你还在用，反而会降低性能，虽然开启jvm的逃逸分析后可能会同步消除，但是稍微复杂点，也消除不了。\n\n## 原理你知道么？\n> 到目前我们已经知道这个是什么，也知道什么时候该用什么时候不要用，各种优缺点了，这个时候我们最好是去了解他的原理。\n> 这个看上去是一个乏味的工作，但是不仅仅对在面试上有用，对我们我们学习一些新的技能也很有帮助，因为很有可能他们的原理就相同或者类似，\n就像我们记忆单词的词根一样，这还会对之前的那些东西进行进一步升华。就好比我学习并发工具类的源码的时候，发现那些工具类基本都使用aqs来实现他们的同步功能，\n使用volatile + CAS， 尾插入，等思想。知道这些我们自己都可以不用工具类来实现对应的功能。比如让你不要使用工具类来达到异步转同步，你怎么做？\n不让我用工具类，那我就像他们一样写不久完事了？声明一个volatile变量，自旋判断即可，但是如果需要考虑性能，可能就要更复杂些了，比如需要响应中断，\n需要防止饥饿，防止过度消耗cpu，等等。那我们就需要做更多的工作，还要验证自己工具类的实用性。这些的工作量是比较大的。也需要我们队原理了解的更加全面。\n","slug":"技术人员有关技能方面的一点感悟","published":1,"updated":"2019-06-01T16:20:09.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0hkxqhf000cektv2no5vnfh","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>作为一名技术人员随着，随着接触的技术越来越多，越来越杂，我便发现要想彻底掌握一项技能，<br>是需要循序渐进有,有理有序的进行，每当接触一门新的技术点的手时候，这几点需要我们值得注意。</p>\n<h2 id=\"是什么？\"><a href=\"#是什么？\" class=\"headerlink\" title=\"是什么？\"></a>是什么？</h2><blockquote>\n<p>初步了解技术，需要知道，东西的概念，与基本知识，由那些东西组成，将一些基本概念映入脑海，以后用的时候就是这些东西了.</p>\n</blockquote>\n<h2 id=\"怎么用？\"><a href=\"#怎么用？\" class=\"headerlink\" title=\"怎么用？\"></a>怎么用？</h2><blockquote>\n<p>知道如何去使用,严格的使用步骤是什么，会不会有什么坑，自己去实践一遍，看看用的情况怎么样，测一下，他所说的一些亮点，是不是那么回事。<br>这时候还不能急着去看什么原理啥的，看了有什么用？你能写出来？都还不能用，原理有何用？也就吹吹嘴皮子，干不了实事。</p>\n</blockquote>\n<h2 id=\"什么时候用？\"><a href=\"#什么时候用？\" class=\"headerlink\" title=\"什么时候用？\"></a>什么时候用？</h2><blockquote>\n<p>能用才是开始，但是我们需要知道什么时候用，不是拿来就乱用，要明白这个技能，是用来解决什么问题的，在这期间<br>会涉及到这个东西的优点.他的优点往往就是他的用处。</p>\n</blockquote>\n<h2 id=\"缺点是什么？\"><a href=\"#缺点是什么？\" class=\"headerlink\" title=\"缺点是什么？\"></a>缺点是什么？</h2><blockquote>\n<p>知道什么时候用，还需要知道避免什么时候用，这就是这个东西的缺点，可能用了还不如不用。就拿并发的一些工具类ConcurrentHashMap来说，如果经过逃逸分析，这个map本身就不会逃逸，<br>那你还在用，反而会降低性能，虽然开启jvm的逃逸分析后可能会同步消除，但是稍微复杂点，也消除不了。</p>\n</blockquote>\n<h2 id=\"原理你知道么？\"><a href=\"#原理你知道么？\" class=\"headerlink\" title=\"原理你知道么？\"></a>原理你知道么？</h2><blockquote>\n<p>到目前我们已经知道这个是什么，也知道什么时候该用什么时候不要用，各种优缺点了，这个时候我们最好是去了解他的原理。<br>这个看上去是一个乏味的工作，但是不仅仅对在面试上有用，对我们我们学习一些新的技能也很有帮助，因为很有可能他们的原理就相同或者类似，<br>就像我们记忆单词的词根一样，这还会对之前的那些东西进行进一步升华。就好比我学习并发工具类的源码的时候，发现那些工具类基本都使用aqs来实现他们的同步功能，<br>使用volatile + CAS， 尾插入，等思想。知道这些我们自己都可以不用工具类来实现对应的功能。比如让你不要使用工具类来达到异步转同步，你怎么做？<br>不让我用工具类，那我就像他们一样写不久完事了？声明一个volatile变量，自旋判断即可，但是如果需要考虑性能，可能就要更复杂些了，比如需要响应中断，<br>需要防止饥饿，防止过度消耗cpu，等等。那我们就需要做更多的工作，还要验证自己工具类的实用性。这些的工作量是比较大的。也需要我们队原理了解的更加全面。</p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>作为一名技术人员随着，随着接触的技术越来越多，越来越杂，我便发现要想彻底掌握一项技能，<br>是需要循序渐进有,有理有序的进行，每当接触一门新的技术点的手时候，这几点需要我们值得注意。</p>\n<h2 id=\"是什么？\"><a href=\"#是什么？\" class=\"headerlink\" title=\"是什么？\"></a>是什么？</h2><blockquote>\n<p>初步了解技术，需要知道，东西的概念，与基本知识，由那些东西组成，将一些基本概念映入脑海，以后用的时候就是这些东西了.</p>\n</blockquote>\n<h2 id=\"怎么用？\"><a href=\"#怎么用？\" class=\"headerlink\" title=\"怎么用？\"></a>怎么用？</h2><blockquote>\n<p>知道如何去使用,严格的使用步骤是什么，会不会有什么坑，自己去实践一遍，看看用的情况怎么样，测一下，他所说的一些亮点，是不是那么回事。<br>这时候还不能急着去看什么原理啥的，看了有什么用？你能写出来？都还不能用，原理有何用？也就吹吹嘴皮子，干不了实事。</p>\n</blockquote>\n<h2 id=\"什么时候用？\"><a href=\"#什么时候用？\" class=\"headerlink\" title=\"什么时候用？\"></a>什么时候用？</h2><blockquote>\n<p>能用才是开始，但是我们需要知道什么时候用，不是拿来就乱用，要明白这个技能，是用来解决什么问题的，在这期间<br>会涉及到这个东西的优点.他的优点往往就是他的用处。</p>\n</blockquote>\n<h2 id=\"缺点是什么？\"><a href=\"#缺点是什么？\" class=\"headerlink\" title=\"缺点是什么？\"></a>缺点是什么？</h2><blockquote>\n<p>知道什么时候用，还需要知道避免什么时候用，这就是这个东西的缺点，可能用了还不如不用。就拿并发的一些工具类ConcurrentHashMap来说，如果经过逃逸分析，这个map本身就不会逃逸，<br>那你还在用，反而会降低性能，虽然开启jvm的逃逸分析后可能会同步消除，但是稍微复杂点，也消除不了。</p>\n</blockquote>\n<h2 id=\"原理你知道么？\"><a href=\"#原理你知道么？\" class=\"headerlink\" title=\"原理你知道么？\"></a>原理你知道么？</h2><blockquote>\n<p>到目前我们已经知道这个是什么，也知道什么时候该用什么时候不要用，各种优缺点了，这个时候我们最好是去了解他的原理。<br>这个看上去是一个乏味的工作，但是不仅仅对在面试上有用，对我们我们学习一些新的技能也很有帮助，因为很有可能他们的原理就相同或者类似，<br>就像我们记忆单词的词根一样，这还会对之前的那些东西进行进一步升华。就好比我学习并发工具类的源码的时候，发现那些工具类基本都使用aqs来实现他们的同步功能，<br>使用volatile + CAS， 尾插入，等思想。知道这些我们自己都可以不用工具类来实现对应的功能。比如让你不要使用工具类来达到异步转同步，你怎么做？<br>不让我用工具类，那我就像他们一样写不久完事了？声明一个volatile变量，自旋判断即可，但是如果需要考虑性能，可能就要更复杂些了，比如需要响应中断，<br>需要防止饥饿，防止过度消耗cpu，等等。那我们就需要做更多的工作，还要验证自己工具类的实用性。这些的工作量是比较大的。也需要我们队原理了解的更加全面。</p>\n</blockquote>\n"},{"title":"查快改慢B+树,改快查慢LSM树","date":"2019-01-23T03:47:24.000Z","_content":"![](https://bing.ioliu.cn/photo/EyeFireworks_EN-AU4834024020)\n## 前言\n>书本[**数据结构与算法**]()里面就提到过B树在索引上的应用,而实际应用中一直有许多牛人又对这个数据结构持续做了多优，然这个结构一直有。\n\n---\n### 索引文件\n数据库的索引其实指的是**索引文件**，而B+树是我们索引文件**储存方式**。用于给存储引擎(这里指innodb)查找指定的数据，这里有必要温习一下数据库查根据where条件查找数据的过程，过程发生在storage engine层：\n>1. index Key\n    - 首先将index key条件满足的索引记录区间确定，再索引上使用index filter进行过滤\n>2. index Filter\n    - 将满足的index filter条件的索引记录才去回表取出整行记录返回server层\n    - 不满足index filter条件的索引记录丢弃，不回表、也不会返回server层 \n>3. Table Filter\n>   - 非索引层面的数据过滤，server 层对返回的数据，使用table filter条件做最后的过滤。\n---    \n### B+树\n#### 结构特征\n>1. 有序,B+树上层页面中的记录，存储的是下层页面中的最小值(Low Key)；\n2. B+树的所有数据，均存储在B+树的叶节点\n3. B+树叶节点的所有页面，通过双向链表链接起来\n####   优势\n>- 支持范围查找，所以需要有序 \n- 多叉树结构，降低了索引结构的深度，避免传统二叉树结构中绝大部分的随机访问操作，从而有效减少了磁盘磁头的寻道次数，降低了外存访问延迟对性能的影响本身的时间效率比较高，减少io次数。\n- B+树上层页面中的记录，存储的是下层页面中的最小值(Low Key)；\n- B+树的所有数据，均存储在B+树的叶节点  \n#### 缺点\n>- mysql的B+树会在大量的**随机io**的时候性能下降，特别是随机插入，有可能导致多次页分裂，影响整体查询修改效率。\n>- 每次的页分裂会导致本页面的空间利用率下降，使得空间利用率向50%靠近。 \n\n---\n### LSM树\nLSM（Log-Structured Merge-Trees）与B+树相比，牺牲了部分读的性能来换取写的性能(通过批量写入)。 Hbase、LevelDB、rocksDB采用 LSM 树的结构。LSM可以快速建立索引。\n#### 结构特征\nLSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。\n#### 优势\n>- lsm数是基于 \n- 多叉树结构，降低了索引结构的深度，避免传统二叉树结构中绝大部分的随机访问操作，从而有效减少了磁盘磁头的寻道次数，降低了外存访问延迟对性能的影响本身的时间效率比较高，减少io次数\n- B+树上层页面中的记录，存储的是下层页面中的最小值(Low Key)；\n- B+树的所有数据，均存储在B+树的叶节点  \n#### 缺点\n>- mysql的B+树会在大量的随机**io**的时候性能下降，特别是随机插入，有可能导致多次页分裂，影响查询效率。\n- 每次的页分裂会导致页面的空间利用率下降到50% \n#### 优化\n>- 布隆过滤器代替二分法查找\n\n","source":"_posts/查快改慢B-树-改快查慢LSM树.md","raw":"---\ntitle: '查快改慢B+树,改快查慢LSM树'\ndate: 2019-01-23 11:47:24\ntags: [数据结构, mysql, 索引]\ncategories: [mysql, 数据结构]\n---\n![](https://bing.ioliu.cn/photo/EyeFireworks_EN-AU4834024020)\n## 前言\n>书本[**数据结构与算法**]()里面就提到过B树在索引上的应用,而实际应用中一直有许多牛人又对这个数据结构持续做了多优，然这个结构一直有。\n\n---\n### 索引文件\n数据库的索引其实指的是**索引文件**，而B+树是我们索引文件**储存方式**。用于给存储引擎(这里指innodb)查找指定的数据，这里有必要温习一下数据库查根据where条件查找数据的过程，过程发生在storage engine层：\n>1. index Key\n    - 首先将index key条件满足的索引记录区间确定，再索引上使用index filter进行过滤\n>2. index Filter\n    - 将满足的index filter条件的索引记录才去回表取出整行记录返回server层\n    - 不满足index filter条件的索引记录丢弃，不回表、也不会返回server层 \n>3. Table Filter\n>   - 非索引层面的数据过滤，server 层对返回的数据，使用table filter条件做最后的过滤。\n---    \n### B+树\n#### 结构特征\n>1. 有序,B+树上层页面中的记录，存储的是下层页面中的最小值(Low Key)；\n2. B+树的所有数据，均存储在B+树的叶节点\n3. B+树叶节点的所有页面，通过双向链表链接起来\n####   优势\n>- 支持范围查找，所以需要有序 \n- 多叉树结构，降低了索引结构的深度，避免传统二叉树结构中绝大部分的随机访问操作，从而有效减少了磁盘磁头的寻道次数，降低了外存访问延迟对性能的影响本身的时间效率比较高，减少io次数。\n- B+树上层页面中的记录，存储的是下层页面中的最小值(Low Key)；\n- B+树的所有数据，均存储在B+树的叶节点  \n#### 缺点\n>- mysql的B+树会在大量的**随机io**的时候性能下降，特别是随机插入，有可能导致多次页分裂，影响整体查询修改效率。\n>- 每次的页分裂会导致本页面的空间利用率下降，使得空间利用率向50%靠近。 \n\n---\n### LSM树\nLSM（Log-Structured Merge-Trees）与B+树相比，牺牲了部分读的性能来换取写的性能(通过批量写入)。 Hbase、LevelDB、rocksDB采用 LSM 树的结构。LSM可以快速建立索引。\n#### 结构特征\nLSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。\n#### 优势\n>- lsm数是基于 \n- 多叉树结构，降低了索引结构的深度，避免传统二叉树结构中绝大部分的随机访问操作，从而有效减少了磁盘磁头的寻道次数，降低了外存访问延迟对性能的影响本身的时间效率比较高，减少io次数\n- B+树上层页面中的记录，存储的是下层页面中的最小值(Low Key)；\n- B+树的所有数据，均存储在B+树的叶节点  \n#### 缺点\n>- mysql的B+树会在大量的随机**io**的时候性能下降，特别是随机插入，有可能导致多次页分裂，影响查询效率。\n- 每次的页分裂会导致页面的空间利用率下降到50% \n#### 优化\n>- 布隆过滤器代替二分法查找\n\n","slug":"查快改慢B-树-改快查慢LSM树","published":1,"updated":"2019-01-26T14:21:27.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0hkxqhi000eektv890au0hl","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><img src=\"https://bing.ioliu.cn/photo/EyeFireworks_EN-AU4834024020\" alt=\"\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>书本<a href=\"\"><strong>数据结构与算法</strong></a>里面就提到过B树在索引上的应用,而实际应用中一直有许多牛人又对这个数据结构持续做了多优，然这个结构一直有。</p>\n</blockquote>\n<hr>\n<h3 id=\"索引文件\"><a href=\"#索引文件\" class=\"headerlink\" title=\"索引文件\"></a>索引文件</h3><p>数据库的索引其实指的是<strong>索引文件</strong>，而B+树是我们索引文件<strong>储存方式</strong>。用于给存储引擎(这里指innodb)查找指定的数据，这里有必要温习一下数据库查根据where条件查找数据的过程，过程发生在storage engine层：</p>\n<blockquote>\n<ol>\n<li>index Key<ul>\n<li>首先将index key条件满足的索引记录区间确定，再索引上使用index filter进行过滤</li>\n</ul>\n</li>\n<li>index Filter<ul>\n<li>将满足的index filter条件的索引记录才去回表取出整行记录返回server层</li>\n<li>不满足index filter条件的索引记录丢弃，不回表、也不会返回server层 </li>\n</ul>\n</li>\n<li>Table Filter<ul>\n<li>非索引层面的数据过滤，server 层对返回的数据，使用table filter条件做最后的过滤。</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<hr>\n<h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h3><h4 id=\"结构特征\"><a href=\"#结构特征\" class=\"headerlink\" title=\"结构特征\"></a>结构特征</h4><blockquote>\n<ol>\n<li>有序,B+树上层页面中的记录，存储的是下层页面中的最小值(Low Key)；</li>\n<li>B+树的所有数据，均存储在B+树的叶节点</li>\n<li>B+树叶节点的所有页面，通过双向链表链接起来</li>\n</ol>\n</blockquote>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><blockquote>\n<ul>\n<li>支持范围查找，所以需要有序 </li>\n<li>多叉树结构，降低了索引结构的深度，避免传统二叉树结构中绝大部分的随机访问操作，从而有效减少了磁盘磁头的寻道次数，降低了外存访问延迟对性能的影响本身的时间效率比较高，减少io次数。</li>\n<li>B+树上层页面中的记录，存储的是下层页面中的最小值(Low Key)；</li>\n<li>B+树的所有数据，均存储在B+树的叶节点  </li>\n</ul>\n</blockquote>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><blockquote>\n<ul>\n<li>mysql的B+树会在大量的<strong>随机io</strong>的时候性能下降，特别是随机插入，有可能导致多次页分裂，影响整体查询修改效率。</li>\n<li>每次的页分裂会导致本页面的空间利用率下降，使得空间利用率向50%靠近。 </li>\n</ul>\n</blockquote>\n<hr>\n<h3 id=\"LSM树\"><a href=\"#LSM树\" class=\"headerlink\" title=\"LSM树\"></a>LSM树</h3><p>LSM（Log-Structured Merge-Trees）与B+树相比，牺牲了部分读的性能来换取写的性能(通过批量写入)。 Hbase、LevelDB、rocksDB采用 LSM 树的结构。LSM可以快速建立索引。</p>\n<h4 id=\"结构特征-1\"><a href=\"#结构特征-1\" class=\"headerlink\" title=\"结构特征\"></a>结构特征</h4><p>LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</p>\n<h4 id=\"优势-1\"><a href=\"#优势-1\" class=\"headerlink\" title=\"优势\"></a>优势</h4><blockquote>\n<ul>\n<li>lsm数是基于 </li>\n<li>多叉树结构，降低了索引结构的深度，避免传统二叉树结构中绝大部分的随机访问操作，从而有效减少了磁盘磁头的寻道次数，降低了外存访问延迟对性能的影响本身的时间效率比较高，减少io次数</li>\n<li>B+树上层页面中的记录，存储的是下层页面中的最小值(Low Key)；</li>\n<li>B+树的所有数据，均存储在B+树的叶节点  </li>\n</ul>\n</blockquote>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><blockquote>\n<ul>\n<li>mysql的B+树会在大量的随机<strong>io</strong>的时候性能下降，特别是随机插入，有可能导致多次页分裂，影响查询效率。</li>\n<li>每次的页分裂会导致页面的空间利用率下降到50% </li>\n</ul>\n</blockquote>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><blockquote>\n<ul>\n<li>布隆过滤器代替二分法查找</li>\n</ul>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<p><img src=\"https://bing.ioliu.cn/photo/EyeFireworks_EN-AU4834024020\" alt=\"\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>书本<a href=\"\"><strong>数据结构与算法</strong></a>里面就提到过B树在索引上的应用,而实际应用中一直有许多牛人又对这个数据结构持续做了多优，然这个结构一直有。</p>\n</blockquote>\n<hr>\n<h3 id=\"索引文件\"><a href=\"#索引文件\" class=\"headerlink\" title=\"索引文件\"></a>索引文件</h3><p>数据库的索引其实指的是<strong>索引文件</strong>，而B+树是我们索引文件<strong>储存方式</strong>。用于给存储引擎(这里指innodb)查找指定的数据，这里有必要温习一下数据库查根据where条件查找数据的过程，过程发生在storage engine层：</p>\n<blockquote>\n<ol>\n<li>index Key<ul>\n<li>首先将index key条件满足的索引记录区间确定，再索引上使用index filter进行过滤</li>\n</ul>\n</li>\n<li>index Filter<ul>\n<li>将满足的index filter条件的索引记录才去回表取出整行记录返回server层</li>\n<li>不满足index filter条件的索引记录丢弃，不回表、也不会返回server层 </li>\n</ul>\n</li>\n<li>Table Filter<ul>\n<li>非索引层面的数据过滤，server 层对返回的数据，使用table filter条件做最后的过滤。</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<hr>\n<h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h3><h4 id=\"结构特征\"><a href=\"#结构特征\" class=\"headerlink\" title=\"结构特征\"></a>结构特征</h4><blockquote>\n<ol>\n<li>有序,B+树上层页面中的记录，存储的是下层页面中的最小值(Low Key)；</li>\n<li>B+树的所有数据，均存储在B+树的叶节点</li>\n<li>B+树叶节点的所有页面，通过双向链表链接起来</li>\n</ol>\n</blockquote>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><blockquote>\n<ul>\n<li>支持范围查找，所以需要有序 </li>\n<li>多叉树结构，降低了索引结构的深度，避免传统二叉树结构中绝大部分的随机访问操作，从而有效减少了磁盘磁头的寻道次数，降低了外存访问延迟对性能的影响本身的时间效率比较高，减少io次数。</li>\n<li>B+树上层页面中的记录，存储的是下层页面中的最小值(Low Key)；</li>\n<li>B+树的所有数据，均存储在B+树的叶节点  </li>\n</ul>\n</blockquote>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><blockquote>\n<ul>\n<li>mysql的B+树会在大量的<strong>随机io</strong>的时候性能下降，特别是随机插入，有可能导致多次页分裂，影响整体查询修改效率。</li>\n<li>每次的页分裂会导致本页面的空间利用率下降，使得空间利用率向50%靠近。 </li>\n</ul>\n</blockquote>\n<hr>\n<h3 id=\"LSM树\"><a href=\"#LSM树\" class=\"headerlink\" title=\"LSM树\"></a>LSM树</h3><p>LSM（Log-Structured Merge-Trees）与B+树相比，牺牲了部分读的性能来换取写的性能(通过批量写入)。 Hbase、LevelDB、rocksDB采用 LSM 树的结构。LSM可以快速建立索引。</p>\n<h4 id=\"结构特征-1\"><a href=\"#结构特征-1\" class=\"headerlink\" title=\"结构特征\"></a>结构特征</h4><p>LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</p>\n<h4 id=\"优势-1\"><a href=\"#优势-1\" class=\"headerlink\" title=\"优势\"></a>优势</h4><blockquote>\n<ul>\n<li>lsm数是基于 </li>\n<li>多叉树结构，降低了索引结构的深度，避免传统二叉树结构中绝大部分的随机访问操作，从而有效减少了磁盘磁头的寻道次数，降低了外存访问延迟对性能的影响本身的时间效率比较高，减少io次数</li>\n<li>B+树上层页面中的记录，存储的是下层页面中的最小值(Low Key)；</li>\n<li>B+树的所有数据，均存储在B+树的叶节点  </li>\n</ul>\n</blockquote>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><blockquote>\n<ul>\n<li>mysql的B+树会在大量的随机<strong>io</strong>的时候性能下降，特别是随机插入，有可能导致多次页分裂，影响查询效率。</li>\n<li>每次的页分裂会导致页面的空间利用率下降到50% </li>\n</ul>\n</blockquote>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><blockquote>\n<ul>\n<li>布隆过滤器代替二分法查找</li>\n</ul>\n</blockquote>\n"},{"title":"正则完全总结","date":"2019-06-01T06:41:58.000Z","_content":"### 前言\n正则的实用与强大勿用多说，不仅平时找文本，替换文本有实用的效果，写代码的格式校验，文本\n匹配爬虫的文本匹配，重复匹配，都是相当的好用。  \n\n>正则前前后后看的遍数有个3,4遍了，这次做一个总结，因为这次基本将所有的东西都纳入进来了。\n\n### 普通字符与元字符\n> 正则表达式其实就是有两部分组成，普通字符就是我们的字面文字，\n元字符是用来实现正则功能的文字，就像一个工具字符。如果要匹配元字符这样的字面文本，加个转义就可以了。\n#### 普通字符\n``` regexp\n  String regexp = \"123\";\n  String text = \"123456\"\n  不加其他元字符，这个就只是匹配 \"123\"，甚至我都不会以为这个一个正则，只是一个普通的查找。\n```\n普通字符匹配，就是直观的匹配,一般我们需要将某些文本内的独有的，有特征的文本找出来，来供我们进行匹配。普字符是什么就匹配什么。\n\n#### 元字符\n> 元字符基本就是正则的核心，学习正则就是了解所有的这些元字符，他用所有他定义的元字符来实现它指定的功能。元字符有大致分为6种，用来实现不同的功能。\n\n##### 非打印字符\n> 打印出来不是我们所写的那样的字符,而是定义好了的一些效果的字符。\n\n|符号|描述|\n|:---:|:---|\n|\\n\t|换行符|\n|\\r\t|回车符|\n|\\s\t|匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。|\n|\\S\t|匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。|\n\n等等。\n\n##### 特殊字符\n> 有特殊含义的功能字符\n\n|特殊字符|描述|\n|:---:|:---|\n|$|匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配字面 $ 字符本身，使用 \\\\$。|\n|( )|标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，使用 \\\\( 和 \\\\)。|\n|*|匹配前面的子表达式零次或多次。要匹配字面 * 字符，使用 \\\\\\*。|\n|+|匹配前面的子表达式一次或多次。要匹配字面 + 字符，使用 \\\\\\+。|\n|.|匹配除换行符 \\n 之外的任何单字符。要匹配 . ，使用 \\\\. 。|\n|[|标记一个中括号表达式的开始。要匹配 [，使用 \\\\[。|\n|?|匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配字面 ? 字符，使用 \\\\?。|\n|\\\\|将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。如，'n' 匹配'n'。'\\n' 换行符。序列 '\\\\' 匹配 \"\\\"，而 '\\(' 则匹配 \"(\"。|\n|^|匹配输入字符串的开始位置，不过在方括号表达式中使用，此时它表示非。要匹配字面 ^ 字符本身，使用 \\\\^。|\n|{|标记限定符表达式的开始。要匹配 {，使用 \\\\{。|\n| &#124; |指明两项之间的一个选择。要匹配 &#124; ，使用 \\\\&#124;。|\n\n##### 限定符\n> 用来表示个数的\n\n|字符\t|描述|\n|:---:|:---|\n|*|匹配紧贴前面的单个字母或者表达式0次或多次。|\n|+|匹配紧贴前面的单个字母或者表达式1次或多次。|\n|?|匹配紧贴前面的单个字母或者表达式0次或1次。|\n|{n}|n 是一个非负整数。匹配确定的 n 次。|\n|{n,}|n 是一个非负整数。至少匹配n次。|\n|{n,m}|m 和 n 均为非负整数，匹配前面字符或者表达式连续出现n到m次|\n\n##### 定位符\n> 表示匹配项和空格，或者换行符的关系\n\n|字符|描述|\n|:---:|:---|\n|^\t|匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。|\n|$\t|匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。|\n|\\b\t|匹配一个单词边界，即字与空格间的位置。|\n|\\B\t|非单词边界匹配。|\n\n##### 选择\n> 表示匹配项和旁边字符的关系,分 **分获取匹配和**和**非获取匹配** 配合括号使用\n\n用圆括号将所有选择项括起来的时候，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。\n其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，\n后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。\n\n##### 反向引用\n> 对已经获取到缓冲区的匹配项的引用，最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。\n和替换功能里面的$1 符号类似。\n\n所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。\n每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。\n\n### 贪心与非贪心\n> 当匹配两个字符中间夹着的匹配项的时候如果有多个匹配项，正则模式使用的是贪心模式，也就是内容匹配最多的那种\n>通过在 *,+ 或 ? 限定符之后放置 ?，该表达式从\"贪心\"表达式转换为\"非贪心\"表达式或者最小匹配。\n\n### 获取与非获取匹配\n> 使用括号的时候会将括号里面的匹配项放入正则的缓冲区域里面(最多99项),这是获取匹配。\n\n|符号|说明|\n|:---:|:---|\n|(pattern)|匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\\(' 或 '\\)'。|\n|(?:pattern)|匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (\\\\&#124;) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y\\\\&#124;ies) 就是一个比 'industry\\\\&#124;industries' 更简略的表达式。|\n\n### 正反向肯定否定预查找\n    \n|表达式模板|说明|\n|:---|:---|\n|(?=pattern)|匹配给定字符后面的字符是括号里面期望项目，如1(?=2),表示匹配1后面是2的1而不是别的，12匹配成功，13匹配失败|\n|(?!pattern)|匹配给定字符后面的字符不是是括号里面期望项目,如1(?!=2),表示匹配1后面不是2的1，12匹配失败，13匹配成功|\n|(?<=pattern)|匹配给定字符前面的字符是括号里面期望项目，与上面的类似|\n|(?<!pattern)|匹配给定字符前面的字符不是是括号里面期望项目，与上面的类似|\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/正则完全总结.md","raw":"---\ntitle: 正则完全总结\ndate: 2019-06-01 14:41:58\ntags: [正则]\n---\n### 前言\n正则的实用与强大勿用多说，不仅平时找文本，替换文本有实用的效果，写代码的格式校验，文本\n匹配爬虫的文本匹配，重复匹配，都是相当的好用。  \n\n>正则前前后后看的遍数有个3,4遍了，这次做一个总结，因为这次基本将所有的东西都纳入进来了。\n\n### 普通字符与元字符\n> 正则表达式其实就是有两部分组成，普通字符就是我们的字面文字，\n元字符是用来实现正则功能的文字，就像一个工具字符。如果要匹配元字符这样的字面文本，加个转义就可以了。\n#### 普通字符\n``` regexp\n  String regexp = \"123\";\n  String text = \"123456\"\n  不加其他元字符，这个就只是匹配 \"123\"，甚至我都不会以为这个一个正则，只是一个普通的查找。\n```\n普通字符匹配，就是直观的匹配,一般我们需要将某些文本内的独有的，有特征的文本找出来，来供我们进行匹配。普字符是什么就匹配什么。\n\n#### 元字符\n> 元字符基本就是正则的核心，学习正则就是了解所有的这些元字符，他用所有他定义的元字符来实现它指定的功能。元字符有大致分为6种，用来实现不同的功能。\n\n##### 非打印字符\n> 打印出来不是我们所写的那样的字符,而是定义好了的一些效果的字符。\n\n|符号|描述|\n|:---:|:---|\n|\\n\t|换行符|\n|\\r\t|回车符|\n|\\s\t|匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。|\n|\\S\t|匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。|\n\n等等。\n\n##### 特殊字符\n> 有特殊含义的功能字符\n\n|特殊字符|描述|\n|:---:|:---|\n|$|匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配字面 $ 字符本身，使用 \\\\$。|\n|( )|标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，使用 \\\\( 和 \\\\)。|\n|*|匹配前面的子表达式零次或多次。要匹配字面 * 字符，使用 \\\\\\*。|\n|+|匹配前面的子表达式一次或多次。要匹配字面 + 字符，使用 \\\\\\+。|\n|.|匹配除换行符 \\n 之外的任何单字符。要匹配 . ，使用 \\\\. 。|\n|[|标记一个中括号表达式的开始。要匹配 [，使用 \\\\[。|\n|?|匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配字面 ? 字符，使用 \\\\?。|\n|\\\\|将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。如，'n' 匹配'n'。'\\n' 换行符。序列 '\\\\' 匹配 \"\\\"，而 '\\(' 则匹配 \"(\"。|\n|^|匹配输入字符串的开始位置，不过在方括号表达式中使用，此时它表示非。要匹配字面 ^ 字符本身，使用 \\\\^。|\n|{|标记限定符表达式的开始。要匹配 {，使用 \\\\{。|\n| &#124; |指明两项之间的一个选择。要匹配 &#124; ，使用 \\\\&#124;。|\n\n##### 限定符\n> 用来表示个数的\n\n|字符\t|描述|\n|:---:|:---|\n|*|匹配紧贴前面的单个字母或者表达式0次或多次。|\n|+|匹配紧贴前面的单个字母或者表达式1次或多次。|\n|?|匹配紧贴前面的单个字母或者表达式0次或1次。|\n|{n}|n 是一个非负整数。匹配确定的 n 次。|\n|{n,}|n 是一个非负整数。至少匹配n次。|\n|{n,m}|m 和 n 均为非负整数，匹配前面字符或者表达式连续出现n到m次|\n\n##### 定位符\n> 表示匹配项和空格，或者换行符的关系\n\n|字符|描述|\n|:---:|:---|\n|^\t|匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。|\n|$\t|匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。|\n|\\b\t|匹配一个单词边界，即字与空格间的位置。|\n|\\B\t|非单词边界匹配。|\n\n##### 选择\n> 表示匹配项和旁边字符的关系,分 **分获取匹配和**和**非获取匹配** 配合括号使用\n\n用圆括号将所有选择项括起来的时候，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。\n其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，\n后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。\n\n##### 反向引用\n> 对已经获取到缓冲区的匹配项的引用，最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。\n和替换功能里面的$1 符号类似。\n\n所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。\n每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。\n\n### 贪心与非贪心\n> 当匹配两个字符中间夹着的匹配项的时候如果有多个匹配项，正则模式使用的是贪心模式，也就是内容匹配最多的那种\n>通过在 *,+ 或 ? 限定符之后放置 ?，该表达式从\"贪心\"表达式转换为\"非贪心\"表达式或者最小匹配。\n\n### 获取与非获取匹配\n> 使用括号的时候会将括号里面的匹配项放入正则的缓冲区域里面(最多99项),这是获取匹配。\n\n|符号|说明|\n|:---:|:---|\n|(pattern)|匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\\(' 或 '\\)'。|\n|(?:pattern)|匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (\\\\&#124;) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y\\\\&#124;ies) 就是一个比 'industry\\\\&#124;industries' 更简略的表达式。|\n\n### 正反向肯定否定预查找\n    \n|表达式模板|说明|\n|:---|:---|\n|(?=pattern)|匹配给定字符后面的字符是括号里面期望项目，如1(?=2),表示匹配1后面是2的1而不是别的，12匹配成功，13匹配失败|\n|(?!pattern)|匹配给定字符后面的字符不是是括号里面期望项目,如1(?!=2),表示匹配1后面不是2的1，12匹配失败，13匹配成功|\n|(?<=pattern)|匹配给定字符前面的字符是括号里面期望项目，与上面的类似|\n|(?<!pattern)|匹配给定字符前面的字符不是是括号里面期望项目，与上面的类似|\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"正则完全总结","published":1,"updated":"2019-06-02T06:43:04.291Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0hkxqhl000gektvu7hqyanu","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>正则的实用与强大勿用多说，不仅平时找文本，替换文本有实用的效果，写代码的格式校验，文本<br>匹配爬虫的文本匹配，重复匹配，都是相当的好用。  </p>\n<blockquote>\n<p>正则前前后后看的遍数有个3,4遍了，这次做一个总结，因为这次基本将所有的东西都纳入进来了。</p>\n</blockquote>\n<h3 id=\"普通字符与元字符\"><a href=\"#普通字符与元字符\" class=\"headerlink\" title=\"普通字符与元字符\"></a>普通字符与元字符</h3><blockquote>\n<p>正则表达式其实就是有两部分组成，普通字符就是我们的字面文字，<br>元字符是用来实现正则功能的文字，就像一个工具字符。如果要匹配元字符这样的字面文本，加个转义就可以了。</p>\n</blockquote>\n<h4 id=\"普通字符\"><a href=\"#普通字符\" class=\"headerlink\" title=\"普通字符\"></a>普通字符</h4><pre class=\" language-regexp\"><code class=\"language-regexp\">  String regexp = \"123\";\n  String text = \"123456\"\n  不加其他元字符，这个就只是匹配 \"123\"，甚至我都不会以为这个一个正则，只是一个普通的查找。\n</code></pre>\n<p>普通字符匹配，就是直观的匹配,一般我们需要将某些文本内的独有的，有特征的文本找出来，来供我们进行匹配。普字符是什么就匹配什么。</p>\n<h4 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h4><blockquote>\n<p>元字符基本就是正则的核心，学习正则就是了解所有的这些元字符，他用所有他定义的元字符来实现它指定的功能。元字符有大致分为6种，用来实现不同的功能。</p>\n</blockquote>\n<h5 id=\"非打印字符\"><a href=\"#非打印字符\" class=\"headerlink\" title=\"非打印字符\"></a>非打印字符</h5><blockquote>\n<p>打印出来不是我们所写的那样的字符,而是定义好了的一些效果的字符。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">符号</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">\\n</td>\n<td style=\"text-align:left\">换行符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\r</td>\n<td style=\"text-align:left\">回车符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\s</td>\n<td style=\"text-align:left\">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\S</td>\n<td style=\"text-align:left\">匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。</td>\n</tr>\n</tbody>\n</table>\n<p>等等。</p>\n<h5 id=\"特殊字符\"><a href=\"#特殊字符\" class=\"headerlink\" title=\"特殊字符\"></a>特殊字符</h5><blockquote>\n<p>有特殊含义的功能字符</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">特殊字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$</td>\n<td style=\"text-align:left\">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配字面 $ 字符本身，使用 \\$。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">( )</td>\n<td style=\"text-align:left\">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，使用 \\( 和 \\)。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">*</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或多次。要匹配字面 <em> 字符，使用 \\\\</em>。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">+</td>\n<td style=\"text-align:left\">匹配前面的子表达式一次或多次。要匹配字面 + 字符，使用 \\+。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">.</td>\n<td style=\"text-align:left\">匹配除换行符 \\n 之外的任何单字符。要匹配 . ，使用 \\. 。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[</td>\n<td style=\"text-align:left\">标记一个中括号表达式的开始。要匹配 [，使用 \\[。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配字面 ? 字符，使用 \\?。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\</td>\n<td style=\"text-align:left\">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。如，’n’ 匹配’n’。’\\n’ 换行符。序列 ‘\\‘ 匹配 “\\”，而 ‘(‘ 则匹配 “(“。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">^</td>\n<td style=\"text-align:left\">匹配输入字符串的开始位置，不过在方括号表达式中使用，此时它表示非。要匹配字面 ^ 字符本身，使用 \\^。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{</td>\n<td style=\"text-align:left\">标记限定符表达式的开始。要匹配 {，使用 \\{。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">&#124;</td>\n<td style=\"text-align:left\">指明两项之间的一个选择。要匹配 &#124; ，使用 \\&#124;。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"限定符\"><a href=\"#限定符\" class=\"headerlink\" title=\"限定符\"></a>限定符</h5><blockquote>\n<p>用来表示个数的</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">*</td>\n<td style=\"text-align:left\">匹配紧贴前面的单个字母或者表达式0次或多次。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">+</td>\n<td style=\"text-align:left\">匹配紧贴前面的单个字母或者表达式1次或多次。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?</td>\n<td style=\"text-align:left\">匹配紧贴前面的单个字母或者表达式0次或1次。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n}</td>\n<td style=\"text-align:left\">n 是一个非负整数。匹配确定的 n 次。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n,}</td>\n<td style=\"text-align:left\">n 是一个非负整数。至少匹配n次。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n,m}</td>\n<td style=\"text-align:left\">m 和 n 均为非负整数，匹配前面字符或者表达式连续出现n到m次</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"定位符\"><a href=\"#定位符\" class=\"headerlink\" title=\"定位符\"></a>定位符</h5><blockquote>\n<p>表示匹配项和空格，或者换行符的关系</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">^</td>\n<td style=\"text-align:left\">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$</td>\n<td style=\"text-align:left\">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\b</td>\n<td style=\"text-align:left\">匹配一个单词边界，即字与空格间的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\B</td>\n<td style=\"text-align:left\">非单词边界匹配。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h5><blockquote>\n<p>表示匹配项和旁边字符的关系,分 <strong>分获取匹配和</strong>和<strong>非获取匹配</strong> 配合括号使用</p>\n</blockquote>\n<p>用圆括号将所有选择项括起来的时候，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。<br>其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，<br>后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p>\n<h5 id=\"反向引用\"><a href=\"#反向引用\" class=\"headerlink\" title=\"反向引用\"></a>反向引用</h5><blockquote>\n<p>对已经获取到缓冲区的匹配项的引用，最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。<br>和替换功能里面的$1 符号类似。</p>\n</blockquote>\n<p>所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。<br>每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。</p>\n<h3 id=\"贪心与非贪心\"><a href=\"#贪心与非贪心\" class=\"headerlink\" title=\"贪心与非贪心\"></a>贪心与非贪心</h3><blockquote>\n<p>当匹配两个字符中间夹着的匹配项的时候如果有多个匹配项，正则模式使用的是贪心模式，也就是内容匹配最多的那种<br>通过在 *,+ 或 ? 限定符之后放置 ?，该表达式从”贪心”表达式转换为”非贪心”表达式或者最小匹配。</p>\n</blockquote>\n<h3 id=\"获取与非获取匹配\"><a href=\"#获取与非获取匹配\" class=\"headerlink\" title=\"获取与非获取匹配\"></a>获取与非获取匹配</h3><blockquote>\n<p>使用括号的时候会将括号里面的匹配项放入正则的缓冲区域里面(最多99项),这是获取匹配。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">符号</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">(pattern)</td>\n<td style=\"text-align:left\">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(?:pattern)</td>\n<td style=\"text-align:left\">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (\\&#124;) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y\\&#124;ies) 就是一个比 ‘industry\\&#124;industries’ 更简略的表达式。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"正反向肯定否定预查找\"><a href=\"#正反向肯定否定预查找\" class=\"headerlink\" title=\"正反向肯定否定预查找\"></a>正反向肯定否定预查找</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">表达式模板</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">(?=pattern)</td>\n<td style=\"text-align:left\">匹配给定字符后面的字符是括号里面期望项目，如1(?=2),表示匹配1后面是2的1而不是别的，12匹配成功，13匹配失败</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(?!pattern)</td>\n<td style=\"text-align:left\">匹配给定字符后面的字符不是是括号里面期望项目,如1(?!=2),表示匹配1后面不是2的1，12匹配失败，13匹配成功</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(?&lt;=pattern)</td>\n<td style=\"text-align:left\">匹配给定字符前面的字符是括号里面期望项目，与上面的类似</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(?&lt;!pattern)</td>\n<td style=\"text-align:left\">匹配给定字符前面的字符不是是括号里面期望项目，与上面的类似</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>正则的实用与强大勿用多说，不仅平时找文本，替换文本有实用的效果，写代码的格式校验，文本<br>匹配爬虫的文本匹配，重复匹配，都是相当的好用。  </p>\n<blockquote>\n<p>正则前前后后看的遍数有个3,4遍了，这次做一个总结，因为这次基本将所有的东西都纳入进来了。</p>\n</blockquote>\n<h3 id=\"普通字符与元字符\"><a href=\"#普通字符与元字符\" class=\"headerlink\" title=\"普通字符与元字符\"></a>普通字符与元字符</h3><blockquote>\n<p>正则表达式其实就是有两部分组成，普通字符就是我们的字面文字，<br>元字符是用来实现正则功能的文字，就像一个工具字符。如果要匹配元字符这样的字面文本，加个转义就可以了。</p>\n</blockquote>\n<h4 id=\"普通字符\"><a href=\"#普通字符\" class=\"headerlink\" title=\"普通字符\"></a>普通字符</h4><pre><code class=\"regexp\">  String regexp = &quot;123&quot;;\n  String text = &quot;123456&quot;\n  不加其他元字符，这个就只是匹配 &quot;123&quot;，甚至我都不会以为这个一个正则，只是一个普通的查找。\n</code></pre>\n<p>普通字符匹配，就是直观的匹配,一般我们需要将某些文本内的独有的，有特征的文本找出来，来供我们进行匹配。普字符是什么就匹配什么。</p>\n<h4 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h4><blockquote>\n<p>元字符基本就是正则的核心，学习正则就是了解所有的这些元字符，他用所有他定义的元字符来实现它指定的功能。元字符有大致分为6种，用来实现不同的功能。</p>\n</blockquote>\n<h5 id=\"非打印字符\"><a href=\"#非打印字符\" class=\"headerlink\" title=\"非打印字符\"></a>非打印字符</h5><blockquote>\n<p>打印出来不是我们所写的那样的字符,而是定义好了的一些效果的字符。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">符号</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">\\n</td>\n<td style=\"text-align:left\">换行符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\r</td>\n<td style=\"text-align:left\">回车符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\s</td>\n<td style=\"text-align:left\">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\S</td>\n<td style=\"text-align:left\">匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。</td>\n</tr>\n</tbody>\n</table>\n<p>等等。</p>\n<h5 id=\"特殊字符\"><a href=\"#特殊字符\" class=\"headerlink\" title=\"特殊字符\"></a>特殊字符</h5><blockquote>\n<p>有特殊含义的功能字符</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">特殊字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$</td>\n<td style=\"text-align:left\">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配字面 $ 字符本身，使用 \\$。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">( )</td>\n<td style=\"text-align:left\">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，使用 \\( 和 \\)。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">*</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或多次。要匹配字面 <em> 字符，使用 \\\\</em>。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">+</td>\n<td style=\"text-align:left\">匹配前面的子表达式一次或多次。要匹配字面 + 字符，使用 \\+。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">.</td>\n<td style=\"text-align:left\">匹配除换行符 \\n 之外的任何单字符。要匹配 . ，使用 \\. 。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[</td>\n<td style=\"text-align:left\">标记一个中括号表达式的开始。要匹配 [，使用 \\[。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配字面 ? 字符，使用 \\?。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\</td>\n<td style=\"text-align:left\">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。如，’n’ 匹配’n’。’\\n’ 换行符。序列 ‘\\‘ 匹配 “\\”，而 ‘(‘ 则匹配 “(“。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">^</td>\n<td style=\"text-align:left\">匹配输入字符串的开始位置，不过在方括号表达式中使用，此时它表示非。要匹配字面 ^ 字符本身，使用 \\^。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{</td>\n<td style=\"text-align:left\">标记限定符表达式的开始。要匹配 {，使用 \\{。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">&#124;</td>\n<td style=\"text-align:left\">指明两项之间的一个选择。要匹配 &#124; ，使用 \\&#124;。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"限定符\"><a href=\"#限定符\" class=\"headerlink\" title=\"限定符\"></a>限定符</h5><blockquote>\n<p>用来表示个数的</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">*</td>\n<td style=\"text-align:left\">匹配紧贴前面的单个字母或者表达式0次或多次。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">+</td>\n<td style=\"text-align:left\">匹配紧贴前面的单个字母或者表达式1次或多次。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?</td>\n<td style=\"text-align:left\">匹配紧贴前面的单个字母或者表达式0次或1次。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n}</td>\n<td style=\"text-align:left\">n 是一个非负整数。匹配确定的 n 次。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n,}</td>\n<td style=\"text-align:left\">n 是一个非负整数。至少匹配n次。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{n,m}</td>\n<td style=\"text-align:left\">m 和 n 均为非负整数，匹配前面字符或者表达式连续出现n到m次</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"定位符\"><a href=\"#定位符\" class=\"headerlink\" title=\"定位符\"></a>定位符</h5><blockquote>\n<p>表示匹配项和空格，或者换行符的关系</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">^</td>\n<td style=\"text-align:left\">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$</td>\n<td style=\"text-align:left\">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\b</td>\n<td style=\"text-align:left\">匹配一个单词边界，即字与空格间的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\B</td>\n<td style=\"text-align:left\">非单词边界匹配。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h5><blockquote>\n<p>表示匹配项和旁边字符的关系,分 <strong>分获取匹配和</strong>和<strong>非获取匹配</strong> 配合括号使用</p>\n</blockquote>\n<p>用圆括号将所有选择项括起来的时候，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。<br>其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，<br>后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p>\n<h5 id=\"反向引用\"><a href=\"#反向引用\" class=\"headerlink\" title=\"反向引用\"></a>反向引用</h5><blockquote>\n<p>对已经获取到缓冲区的匹配项的引用，最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。<br>和替换功能里面的$1 符号类似。</p>\n</blockquote>\n<p>所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。<br>每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。</p>\n<h3 id=\"贪心与非贪心\"><a href=\"#贪心与非贪心\" class=\"headerlink\" title=\"贪心与非贪心\"></a>贪心与非贪心</h3><blockquote>\n<p>当匹配两个字符中间夹着的匹配项的时候如果有多个匹配项，正则模式使用的是贪心模式，也就是内容匹配最多的那种<br>通过在 *,+ 或 ? 限定符之后放置 ?，该表达式从”贪心”表达式转换为”非贪心”表达式或者最小匹配。</p>\n</blockquote>\n<h3 id=\"获取与非获取匹配\"><a href=\"#获取与非获取匹配\" class=\"headerlink\" title=\"获取与非获取匹配\"></a>获取与非获取匹配</h3><blockquote>\n<p>使用括号的时候会将括号里面的匹配项放入正则的缓冲区域里面(最多99项),这是获取匹配。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">符号</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">(pattern)</td>\n<td style=\"text-align:left\">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(?:pattern)</td>\n<td style=\"text-align:left\">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (\\&#124;) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y\\&#124;ies) 就是一个比 ‘industry\\&#124;industries’ 更简略的表达式。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"正反向肯定否定预查找\"><a href=\"#正反向肯定否定预查找\" class=\"headerlink\" title=\"正反向肯定否定预查找\"></a>正反向肯定否定预查找</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">表达式模板</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">(?=pattern)</td>\n<td style=\"text-align:left\">匹配给定字符后面的字符是括号里面期望项目，如1(?=2),表示匹配1后面是2的1而不是别的，12匹配成功，13匹配失败</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(?!pattern)</td>\n<td style=\"text-align:left\">匹配给定字符后面的字符不是是括号里面期望项目,如1(?!=2),表示匹配1后面不是2的1，12匹配失败，13匹配成功</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(?&lt;=pattern)</td>\n<td style=\"text-align:left\">匹配给定字符前面的字符是括号里面期望项目，与上面的类似</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(?&lt;!pattern)</td>\n<td style=\"text-align:left\">匹配给定字符前面的字符不是是括号里面期望项目，与上面的类似</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"分布式锁究竟应该怎么实现？","date":"2019-01-22T13:54:06.000Z","_content":"![](http://ww1.sinaimg.cn/large/006Cwrd9gy1fzfs9sj3xkj31hc0u07de.jpg)\n## 背景\n前几天突然接到任务说要实现一个分布式锁，由于之前有自己实现过一些demo，对各种分布式锁也都有一定的了解，\n实现的时候会数量一些，但是毕竟是公司直接要拿来用的东西，反复斟酌后才把初期的方案定了下来。\n\n### 常用的分布式锁简介\n基于redis的分布式锁\n- 使用setNX的方式\n- 直接使用redis官方的redission已经实现好的redLock(有一些人说这才是分布式锁的正确方式，我这里不做评价，详见)\n\n基于zookeeper的分布式锁\n- 利用zookeeper的顺序临时节点，自旋比较自己的节点是否是节点里的最小值，来获得锁。\n\n基于etcd的分布式锁\n- 原理与zookeeper类似\n\n### 基于redis分布式锁的具体方案及细节\n\n\n","source":"_posts/究竟应该怎么实现分布式锁 ？.md","raw":"---\ntitle: 分布式锁究竟应该怎么实现？\ndate: 2019-01-22 21:54:06\ntags: 分布式\ncategories: [分布式]\n---\n![](http://ww1.sinaimg.cn/large/006Cwrd9gy1fzfs9sj3xkj31hc0u07de.jpg)\n## 背景\n前几天突然接到任务说要实现一个分布式锁，由于之前有自己实现过一些demo，对各种分布式锁也都有一定的了解，\n实现的时候会数量一些，但是毕竟是公司直接要拿来用的东西，反复斟酌后才把初期的方案定了下来。\n\n### 常用的分布式锁简介\n基于redis的分布式锁\n- 使用setNX的方式\n- 直接使用redis官方的redission已经实现好的redLock(有一些人说这才是分布式锁的正确方式，我这里不做评价，详见)\n\n基于zookeeper的分布式锁\n- 利用zookeeper的顺序临时节点，自旋比较自己的节点是否是节点里的最小值，来获得锁。\n\n基于etcd的分布式锁\n- 原理与zookeeper类似\n\n### 基于redis分布式锁的具体方案及细节\n\n\n","slug":"究竟应该怎么实现分布式锁 ？","published":1,"updated":"2019-04-21T14:29:13.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0hkxqhn000kektve6mjwiqr","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><img src=\"http://ww1.sinaimg.cn/large/006Cwrd9gy1fzfs9sj3xkj31hc0u07de.jpg\" alt=\"\"></p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>前几天突然接到任务说要实现一个分布式锁，由于之前有自己实现过一些demo，对各种分布式锁也都有一定的了解，<br>实现的时候会数量一些，但是毕竟是公司直接要拿来用的东西，反复斟酌后才把初期的方案定了下来。</p>\n<h3 id=\"常用的分布式锁简介\"><a href=\"#常用的分布式锁简介\" class=\"headerlink\" title=\"常用的分布式锁简介\"></a>常用的分布式锁简介</h3><p>基于redis的分布式锁</p>\n<ul>\n<li>使用setNX的方式</li>\n<li>直接使用redis官方的redission已经实现好的redLock(有一些人说这才是分布式锁的正确方式，我这里不做评价，详见)</li>\n</ul>\n<p>基于zookeeper的分布式锁</p>\n<ul>\n<li>利用zookeeper的顺序临时节点，自旋比较自己的节点是否是节点里的最小值，来获得锁。</li>\n</ul>\n<p>基于etcd的分布式锁</p>\n<ul>\n<li>原理与zookeeper类似</li>\n</ul>\n<h3 id=\"基于redis分布式锁的具体方案及细节\"><a href=\"#基于redis分布式锁的具体方案及细节\" class=\"headerlink\" title=\"基于redis分布式锁的具体方案及细节\"></a>基于redis分布式锁的具体方案及细节</h3>","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<p><img src=\"http://ww1.sinaimg.cn/large/006Cwrd9gy1fzfs9sj3xkj31hc0u07de.jpg\" alt=\"\"></p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>前几天突然接到任务说要实现一个分布式锁，由于之前有自己实现过一些demo，对各种分布式锁也都有一定的了解，<br>实现的时候会数量一些，但是毕竟是公司直接要拿来用的东西，反复斟酌后才把初期的方案定了下来。</p>\n<h3 id=\"常用的分布式锁简介\"><a href=\"#常用的分布式锁简介\" class=\"headerlink\" title=\"常用的分布式锁简介\"></a>常用的分布式锁简介</h3><p>基于redis的分布式锁</p>\n<ul>\n<li>使用setNX的方式</li>\n<li>直接使用redis官方的redission已经实现好的redLock(有一些人说这才是分布式锁的正确方式，我这里不做评价，详见)</li>\n</ul>\n<p>基于zookeeper的分布式锁</p>\n<ul>\n<li>利用zookeeper的顺序临时节点，自旋比较自己的节点是否是节点里的最小值，来获得锁。</li>\n</ul>\n<p>基于etcd的分布式锁</p>\n<ul>\n<li>原理与zookeeper类似</li>\n</ul>\n<h3 id=\"基于redis分布式锁的具体方案及细节\"><a href=\"#基于redis分布式锁的具体方案及细节\" class=\"headerlink\" title=\"基于redis分布式锁的具体方案及细节\"></a>基于redis分布式锁的具体方案及细节</h3>"},{"title":"红黑树在jdk中的实现","date":"2019-01-26T02:51:33.000Z","_content":"### 前言\njdk里主要有TreeMap和HashMap里有用到红黑树的数据结构，我觉得TreeMap的实现看起来友好一点，但是长时间不看也容易忘记，在这一并整理一下。本次源码是基于jdk1.8的TreeMap的插入和删除的方法。\n\n### 基本概念\n红黑树的**基本概念**还是贴上来好点，该数据结构必须**同时**满足下面5点条件,[参见wiki](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)：\n>1. 节点是红色或黑色。\n>2. 根是黑色。\n>3. 所有叶子都是黑色（叶子是NIL节点）。\n>4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）\n>5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点    \n\n>其实如果你能细心看完wiki的介绍并理解这里就不用看了，由于情况较多我这里是跟着源码做的总结，个人觉得删除相对难理解一点。\n\n### 插入\n插入相对简单点，主要的工作是修复插入带来的影响，梳理下**核心逻辑**：\n>父节点是红色的时候才会需要调整\n1. 获取到叔节点的颜色  \n    1. 为红色：将父节点和叔节点染黑，爷节点染红，问题推向爷节点(**回到开始**)\n    2. 为黑色：\n        1. 先将当前节点方向变为和父节点同向(即当前节点，父节点，爷节点摆成一条直线)\n        2. 换色(交换父，爷节点颜色) + 旋转(爷节点为中心) **调整结束**\n\n```` java\n    /** From CLR */\n    private void fixAfterInsertion(Entry<K,V> x) {\n        x.color = RED;\n        // 父节点是红色的时候才会需要调整\n        while (x != null && x != root && x.parent.color == RED) {\n            //  父节点是左节点的情况\n            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n                // 1. 获取到叔节点U(uncle)\n                Entry<K,V> y = rightOf(parentOf(parentOf(x)));\n                if (colorOf(y) == RED) {\n                // 如果U为红色:将父节点和叔节点染黑，爷节点染红，问题向爷节点递推(进入下一个循环)\n                    setColor(parentOf(x), BLACK);\n                    setColor(y, BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    x = parentOf(parentOf(x));\n                } else {\n                    // U 为黑色 不用递推可以直接解决\n                    // 如果当前节点是父节点的右节点，左旋，将自己变成父节点的左节(变得和父节点同向)\n                    if (x == rightOf(parentOf(x))) {// 等价转换\n                        x = parentOf(x);\n                        rotateLeft(x);\n                    }\n                    // 换色(交换父，爷节点颜色) + 旋转(爷节点为中心)\n                    setColor(parentOf(x), BLACK); // 父节点已经为黑\n                    setColor(parentOf(parentOf(x)), RED);\n                    rotateRight(parentOf(parentOf(x)));\n                    // 此时父节点为黑色，调整结束\n                }\n            } else { // 对称的，和上面思路一样\n                ......\n            }\n        }\n        root.color = BLACK;\n    }\n````\n\n### 删除\n删除相对复杂，主要的工作是修复删除带来的影响，梳理下**核心逻辑**：\n>当前节点是黑色的时候才需要修复，前面先使用后继节点删除，所以需要向当前节点这里**补一个黑色节点**\n1. 得到兄弟节点\n    1. 将兄弟节点变为黑色(如果兄弟节点为红的话)\n    2. **兄弟节点**是否有**红色子节点**\n      1. 没有: 问题移向父节点(**回到开始1**)\n      2. 有: 先将和当前节点反方向上的**兄弟节点的子节点N**变为红色，将N染黑，交换兄弟和父节点颜色，以父节点为中心，向当前节点方向旋转(**结束**)\n        \n```` java\n    /** From CLR */\n    private void fixAfterDeletion(Entry<K,V> x) {\n        while (x != root && colorOf(x) == BLACK) {\n            // 当前为左节点\n            if (x == leftOf(parentOf(x))) {\n                // 得到兄弟节点 \n                Entry<K,V> sib = rightOf(parentOf(x));\n                // 如果兄弟节点为红色， 交换兄弟节点和父节点颜色并左旋(目的是将兄弟节点变为黑色) \n                if (colorOf(sib) == RED) {\n                    setColor(sib, BLACK);\n                    setColor(parentOf(x), RED);\n                    rotateLeft(parentOf(x));\n                    sib = rightOf(parentOf(x));\n                }\n                // 兄弟节点是否有红色子节点\n                if (colorOf(leftOf(sib))  == BLACK &&\n                    colorOf(rightOf(sib)) == BLACK) {\n                    setColor(sib, RED);\n                    x = parentOf(x);\n                } else {\n                    // 将兄弟节点的右子节点变为红色\n                    if (colorOf(rightOf(sib)) == BLACK) {\n                        setColor(leftOf(sib), BLACK);\n                        setColor(sib, RED);\n                        rotateRight(sib);\n                        sib = rightOf(parentOf(x));\n                    }\n                    // 将兄弟节点右子节点染黑，交换兄弟和父节点的颜色\n                    setColor(sib, colorOf(parentOf(x)));\n                    setColor(parentOf(x), BLACK);\n                    setColor(rightOf(sib), BLACK);\n                    // 以父节点为中心左旋，这样自己这边就多了一个黑色节点，补偿结束！\n                    rotateLeft(parentOf(x));\n                    x = root;\n                }\n            } else { // 对称,逻辑一模一样\n                ......\n            }\n        }\n        setColor(x, BLACK);\n    }\n````\n## 总结  \n>wiki里的c实现使用的是**尾递归**,但是java使用的是**非递归的while**实现的，好像目前java没有对尾递归做优化。\n### 插入的修复\n![](/images/红黑树插入调整.png)\n> 图片点击放大\n--- \n### 删除的修复\n![](/images/红黑树删除修复.png)","source":"_posts/红黑树RBTree在jdk中的实现.md","raw":"---\ntitle: 红黑树在jdk中的实现\ndate: 2019-01-26 10:51:33\ntags: [数据结构]\ncategories: [数据结构]\n---\n### 前言\njdk里主要有TreeMap和HashMap里有用到红黑树的数据结构，我觉得TreeMap的实现看起来友好一点，但是长时间不看也容易忘记，在这一并整理一下。本次源码是基于jdk1.8的TreeMap的插入和删除的方法。\n\n### 基本概念\n红黑树的**基本概念**还是贴上来好点，该数据结构必须**同时**满足下面5点条件,[参见wiki](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)：\n>1. 节点是红色或黑色。\n>2. 根是黑色。\n>3. 所有叶子都是黑色（叶子是NIL节点）。\n>4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）\n>5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点    \n\n>其实如果你能细心看完wiki的介绍并理解这里就不用看了，由于情况较多我这里是跟着源码做的总结，个人觉得删除相对难理解一点。\n\n### 插入\n插入相对简单点，主要的工作是修复插入带来的影响，梳理下**核心逻辑**：\n>父节点是红色的时候才会需要调整\n1. 获取到叔节点的颜色  \n    1. 为红色：将父节点和叔节点染黑，爷节点染红，问题推向爷节点(**回到开始**)\n    2. 为黑色：\n        1. 先将当前节点方向变为和父节点同向(即当前节点，父节点，爷节点摆成一条直线)\n        2. 换色(交换父，爷节点颜色) + 旋转(爷节点为中心) **调整结束**\n\n```` java\n    /** From CLR */\n    private void fixAfterInsertion(Entry<K,V> x) {\n        x.color = RED;\n        // 父节点是红色的时候才会需要调整\n        while (x != null && x != root && x.parent.color == RED) {\n            //  父节点是左节点的情况\n            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n                // 1. 获取到叔节点U(uncle)\n                Entry<K,V> y = rightOf(parentOf(parentOf(x)));\n                if (colorOf(y) == RED) {\n                // 如果U为红色:将父节点和叔节点染黑，爷节点染红，问题向爷节点递推(进入下一个循环)\n                    setColor(parentOf(x), BLACK);\n                    setColor(y, BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    x = parentOf(parentOf(x));\n                } else {\n                    // U 为黑色 不用递推可以直接解决\n                    // 如果当前节点是父节点的右节点，左旋，将自己变成父节点的左节(变得和父节点同向)\n                    if (x == rightOf(parentOf(x))) {// 等价转换\n                        x = parentOf(x);\n                        rotateLeft(x);\n                    }\n                    // 换色(交换父，爷节点颜色) + 旋转(爷节点为中心)\n                    setColor(parentOf(x), BLACK); // 父节点已经为黑\n                    setColor(parentOf(parentOf(x)), RED);\n                    rotateRight(parentOf(parentOf(x)));\n                    // 此时父节点为黑色，调整结束\n                }\n            } else { // 对称的，和上面思路一样\n                ......\n            }\n        }\n        root.color = BLACK;\n    }\n````\n\n### 删除\n删除相对复杂，主要的工作是修复删除带来的影响，梳理下**核心逻辑**：\n>当前节点是黑色的时候才需要修复，前面先使用后继节点删除，所以需要向当前节点这里**补一个黑色节点**\n1. 得到兄弟节点\n    1. 将兄弟节点变为黑色(如果兄弟节点为红的话)\n    2. **兄弟节点**是否有**红色子节点**\n      1. 没有: 问题移向父节点(**回到开始1**)\n      2. 有: 先将和当前节点反方向上的**兄弟节点的子节点N**变为红色，将N染黑，交换兄弟和父节点颜色，以父节点为中心，向当前节点方向旋转(**结束**)\n        \n```` java\n    /** From CLR */\n    private void fixAfterDeletion(Entry<K,V> x) {\n        while (x != root && colorOf(x) == BLACK) {\n            // 当前为左节点\n            if (x == leftOf(parentOf(x))) {\n                // 得到兄弟节点 \n                Entry<K,V> sib = rightOf(parentOf(x));\n                // 如果兄弟节点为红色， 交换兄弟节点和父节点颜色并左旋(目的是将兄弟节点变为黑色) \n                if (colorOf(sib) == RED) {\n                    setColor(sib, BLACK);\n                    setColor(parentOf(x), RED);\n                    rotateLeft(parentOf(x));\n                    sib = rightOf(parentOf(x));\n                }\n                // 兄弟节点是否有红色子节点\n                if (colorOf(leftOf(sib))  == BLACK &&\n                    colorOf(rightOf(sib)) == BLACK) {\n                    setColor(sib, RED);\n                    x = parentOf(x);\n                } else {\n                    // 将兄弟节点的右子节点变为红色\n                    if (colorOf(rightOf(sib)) == BLACK) {\n                        setColor(leftOf(sib), BLACK);\n                        setColor(sib, RED);\n                        rotateRight(sib);\n                        sib = rightOf(parentOf(x));\n                    }\n                    // 将兄弟节点右子节点染黑，交换兄弟和父节点的颜色\n                    setColor(sib, colorOf(parentOf(x)));\n                    setColor(parentOf(x), BLACK);\n                    setColor(rightOf(sib), BLACK);\n                    // 以父节点为中心左旋，这样自己这边就多了一个黑色节点，补偿结束！\n                    rotateLeft(parentOf(x));\n                    x = root;\n                }\n            } else { // 对称,逻辑一模一样\n                ......\n            }\n        }\n        setColor(x, BLACK);\n    }\n````\n## 总结  \n>wiki里的c实现使用的是**尾递归**,但是java使用的是**非递归的while**实现的，好像目前java没有对尾递归做优化。\n### 插入的修复\n![](/images/红黑树插入调整.png)\n> 图片点击放大\n--- \n### 删除的修复\n![](/images/红黑树删除修复.png)","slug":"红黑树RBTree在jdk中的实现","published":1,"updated":"2019-02-20T15:39:24.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0hkxqho000nektvzjd7alhy","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>jdk里主要有TreeMap和HashMap里有用到红黑树的数据结构，我觉得TreeMap的实现看起来友好一点，但是长时间不看也容易忘记，在这一并整理一下。本次源码是基于jdk1.8的TreeMap的插入和删除的方法。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>红黑树的<strong>基本概念</strong>还是贴上来好点，该数据结构必须<strong>同时</strong>满足下面5点条件,<a href=\"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91\" target=\"_blank\" rel=\"noopener\">参见wiki</a>：</p>\n<blockquote>\n<ol>\n<li>节点是红色或黑色。</li>\n<li>根是黑色。</li>\n<li>所有叶子都是黑色（叶子是NIL节点）。</li>\n<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>\n<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点    </li>\n</ol>\n</blockquote>\n<blockquote>\n<p>其实如果你能细心看完wiki的介绍并理解这里就不用看了，由于情况较多我这里是跟着源码做的总结，个人觉得删除相对难理解一点。</p>\n</blockquote>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><p>插入相对简单点，主要的工作是修复插入带来的影响，梳理下<strong>核心逻辑</strong>：</p>\n<blockquote>\n<p>父节点是红色的时候才会需要调整</p>\n<ol>\n<li>获取到叔节点的颜色  <ol>\n<li>为红色：将父节点和叔节点染黑，爷节点染红，问题推向爷节点(<strong>回到开始</strong>)</li>\n<li>为黑色：<ol>\n<li>先将当前节点方向变为和父节点同向(即当前节点，父节点，爷节点摆成一条直线)</li>\n<li>换色(交换父，爷节点颜色) + 旋转(爷节点为中心) <strong>调整结束</strong></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token comment\" spellcheck=\"true\">/** From CLR */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fixAfterInsertion</span><span class=\"token punctuation\">(</span>Entry<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        x<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> RED<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 父节点是红色的时候才会需要调整</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> x <span class=\"token operator\">!=</span> root <span class=\"token operator\">&amp;&amp;</span> x<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">.</span>color <span class=\"token operator\">==</span> RED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//  父节点是左节点的情况</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token function\">leftOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 1. 获取到叔节点U(uncle)</span>\n                Entry<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> y <span class=\"token operator\">=</span> <span class=\"token function\">rightOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">colorOf</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> RED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 如果U为红色:将父节点和叔节点染黑，爷节点染红，问题向爷节点递推(进入下一个循环)</span>\n                    <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> BLACK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span> BLACK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> RED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    x <span class=\"token operator\">=</span> <span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// U 为黑色 不用递推可以直接解决</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 如果当前节点是父节点的右节点，左旋，将自己变成父节点的左节(变得和父节点同向)</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">==</span> <span class=\"token function\">rightOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">// 等价转换</span>\n                        x <span class=\"token operator\">=</span> <span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token function\">rotateLeft</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 换色(交换父，爷节点颜色) + 旋转(爷节点为中心)</span>\n                    <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> BLACK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 父节点已经为黑</span>\n                    <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> RED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">rotateRight</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 此时父节点为黑色，调整结束</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 对称的，和上面思路一样</span>\n                <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        root<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> BLACK<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p>删除相对复杂，主要的工作是修复删除带来的影响，梳理下<strong>核心逻辑</strong>：</p>\n<blockquote>\n<p>当前节点是黑色的时候才需要修复，前面先使用后继节点删除，所以需要向当前节点这里<strong>补一个黑色节点</strong></p>\n<ol>\n<li>得到兄弟节点<ol>\n<li>将兄弟节点变为黑色(如果兄弟节点为红的话)</li>\n<li><strong>兄弟节点</strong>是否有<strong>红色子节点</strong><ol>\n<li>没有: 问题移向父节点(<strong>回到开始1</strong>)</li>\n<li>有: 先将和当前节点反方向上的<strong>兄弟节点的子节点N</strong>变为红色，将N染黑，交换兄弟和父节点颜色，以父节点为中心，向当前节点方向旋转(<strong>结束</strong>)</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token comment\" spellcheck=\"true\">/** From CLR */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">fixAfterDeletion</span><span class=\"token punctuation\">(</span>Entry<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">!=</span> root <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">colorOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> BLACK<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 当前为左节点</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">==</span> <span class=\"token function\">leftOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 得到兄弟节点 </span>\n                Entry<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> sib <span class=\"token operator\">=</span> <span class=\"token function\">rightOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 如果兄弟节点为红色， 交换兄弟节点和父节点颜色并左旋(目的是将兄弟节点变为黑色) </span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">colorOf</span><span class=\"token punctuation\">(</span>sib<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> RED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span>sib<span class=\"token punctuation\">,</span> BLACK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> RED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">rotateLeft</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    sib <span class=\"token operator\">=</span> <span class=\"token function\">rightOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 兄弟节点是否有红色子节点</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">colorOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">leftOf</span><span class=\"token punctuation\">(</span>sib<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token operator\">==</span> BLACK <span class=\"token operator\">&amp;&amp;</span>\n                    <span class=\"token function\">colorOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">rightOf</span><span class=\"token punctuation\">(</span>sib<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> BLACK<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span>sib<span class=\"token punctuation\">,</span> RED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    x <span class=\"token operator\">=</span> <span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 将兄弟节点的右子节点变为红色</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">colorOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">rightOf</span><span class=\"token punctuation\">(</span>sib<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> BLACK<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span><span class=\"token function\">leftOf</span><span class=\"token punctuation\">(</span>sib<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> BLACK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span>sib<span class=\"token punctuation\">,</span> RED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token function\">rotateRight</span><span class=\"token punctuation\">(</span>sib<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        sib <span class=\"token operator\">=</span> <span class=\"token function\">rightOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 将兄弟节点右子节点染黑，交换兄弟和父节点的颜色</span>\n                    <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span>sib<span class=\"token punctuation\">,</span> <span class=\"token function\">colorOf</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> BLACK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span><span class=\"token function\">rightOf</span><span class=\"token punctuation\">(</span>sib<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> BLACK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 以父节点为中心左旋，这样自己这边就多了一个黑色节点，补偿结束！</span>\n                    <span class=\"token function\">rotateLeft</span><span class=\"token punctuation\">(</span><span class=\"token function\">parentOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    x <span class=\"token operator\">=</span> root<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 对称,逻辑一模一样</span>\n                <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> BLACK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote>\n<p>wiki里的c实现使用的是<strong>尾递归</strong>,但是java使用的是<strong>非递归的while</strong>实现的，好像目前java没有对尾递归做优化。</p>\n</blockquote>\n<h3 id=\"插入的修复\"><a href=\"#插入的修复\" class=\"headerlink\" title=\"插入的修复\"></a>插入的修复</h3><p><img src=\"/images/红黑树插入调整.png\" alt=\"\"></p>\n<blockquote>\n<p>图片点击放大</p>\n</blockquote>\n<hr>\n<h3 id=\"删除的修复\"><a href=\"#删除的修复\" class=\"headerlink\" title=\"删除的修复\"></a>删除的修复</h3><p><img src=\"/images/红黑树删除修复.png\" alt=\"\"></p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>jdk里主要有TreeMap和HashMap里有用到红黑树的数据结构，我觉得TreeMap的实现看起来友好一点，但是长时间不看也容易忘记，在这一并整理一下。本次源码是基于jdk1.8的TreeMap的插入和删除的方法。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>红黑树的<strong>基本概念</strong>还是贴上来好点，该数据结构必须<strong>同时</strong>满足下面5点条件,<a href=\"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91\" target=\"_blank\" rel=\"noopener\">参见wiki</a>：</p>\n<blockquote>\n<ol>\n<li>节点是红色或黑色。</li>\n<li>根是黑色。</li>\n<li>所有叶子都是黑色（叶子是NIL节点）。</li>\n<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>\n<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点    </li>\n</ol>\n</blockquote>\n<blockquote>\n<p>其实如果你能细心看完wiki的介绍并理解这里就不用看了，由于情况较多我这里是跟着源码做的总结，个人觉得删除相对难理解一点。</p>\n</blockquote>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><p>插入相对简单点，主要的工作是修复插入带来的影响，梳理下<strong>核心逻辑</strong>：</p>\n<blockquote>\n<p>父节点是红色的时候才会需要调整</p>\n<ol>\n<li>获取到叔节点的颜色  <ol>\n<li>为红色：将父节点和叔节点染黑，爷节点染红，问题推向爷节点(<strong>回到开始</strong>)</li>\n<li>为黑色：<ol>\n<li>先将当前节点方向变为和父节点同向(即当前节点，父节点，爷节点摆成一条直线)</li>\n<li>换色(交换父，爷节点颜色) + 旋转(爷节点为中心) <strong>调整结束</strong></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<pre><code class=\"java\">    /** From CLR */\n    private void fixAfterInsertion(Entry&lt;K,V&gt; x) {\n        x.color = RED;\n        // 父节点是红色的时候才会需要调整\n        while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) {\n            //  父节点是左节点的情况\n            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n                // 1. 获取到叔节点U(uncle)\n                Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));\n                if (colorOf(y) == RED) {\n                // 如果U为红色:将父节点和叔节点染黑，爷节点染红，问题向爷节点递推(进入下一个循环)\n                    setColor(parentOf(x), BLACK);\n                    setColor(y, BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    x = parentOf(parentOf(x));\n                } else {\n                    // U 为黑色 不用递推可以直接解决\n                    // 如果当前节点是父节点的右节点，左旋，将自己变成父节点的左节(变得和父节点同向)\n                    if (x == rightOf(parentOf(x))) {// 等价转换\n                        x = parentOf(x);\n                        rotateLeft(x);\n                    }\n                    // 换色(交换父，爷节点颜色) + 旋转(爷节点为中心)\n                    setColor(parentOf(x), BLACK); // 父节点已经为黑\n                    setColor(parentOf(parentOf(x)), RED);\n                    rotateRight(parentOf(parentOf(x)));\n                    // 此时父节点为黑色，调整结束\n                }\n            } else { // 对称的，和上面思路一样\n                ......\n            }\n        }\n        root.color = BLACK;\n    }\n</code></pre>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p>删除相对复杂，主要的工作是修复删除带来的影响，梳理下<strong>核心逻辑</strong>：</p>\n<blockquote>\n<p>当前节点是黑色的时候才需要修复，前面先使用后继节点删除，所以需要向当前节点这里<strong>补一个黑色节点</strong></p>\n<ol>\n<li>得到兄弟节点<ol>\n<li>将兄弟节点变为黑色(如果兄弟节点为红的话)</li>\n<li><strong>兄弟节点</strong>是否有<strong>红色子节点</strong><ol>\n<li>没有: 问题移向父节点(<strong>回到开始1</strong>)</li>\n<li>有: 先将和当前节点反方向上的<strong>兄弟节点的子节点N</strong>变为红色，将N染黑，交换兄弟和父节点颜色，以父节点为中心，向当前节点方向旋转(<strong>结束</strong>)</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<pre><code class=\"java\">    /** From CLR */\n    private void fixAfterDeletion(Entry&lt;K,V&gt; x) {\n        while (x != root &amp;&amp; colorOf(x) == BLACK) {\n            // 当前为左节点\n            if (x == leftOf(parentOf(x))) {\n                // 得到兄弟节点 \n                Entry&lt;K,V&gt; sib = rightOf(parentOf(x));\n                // 如果兄弟节点为红色， 交换兄弟节点和父节点颜色并左旋(目的是将兄弟节点变为黑色) \n                if (colorOf(sib) == RED) {\n                    setColor(sib, BLACK);\n                    setColor(parentOf(x), RED);\n                    rotateLeft(parentOf(x));\n                    sib = rightOf(parentOf(x));\n                }\n                // 兄弟节点是否有红色子节点\n                if (colorOf(leftOf(sib))  == BLACK &amp;&amp;\n                    colorOf(rightOf(sib)) == BLACK) {\n                    setColor(sib, RED);\n                    x = parentOf(x);\n                } else {\n                    // 将兄弟节点的右子节点变为红色\n                    if (colorOf(rightOf(sib)) == BLACK) {\n                        setColor(leftOf(sib), BLACK);\n                        setColor(sib, RED);\n                        rotateRight(sib);\n                        sib = rightOf(parentOf(x));\n                    }\n                    // 将兄弟节点右子节点染黑，交换兄弟和父节点的颜色\n                    setColor(sib, colorOf(parentOf(x)));\n                    setColor(parentOf(x), BLACK);\n                    setColor(rightOf(sib), BLACK);\n                    // 以父节点为中心左旋，这样自己这边就多了一个黑色节点，补偿结束！\n                    rotateLeft(parentOf(x));\n                    x = root;\n                }\n            } else { // 对称,逻辑一模一样\n                ......\n            }\n        }\n        setColor(x, BLACK);\n    }\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote>\n<p>wiki里的c实现使用的是<strong>尾递归</strong>,但是java使用的是<strong>非递归的while</strong>实现的，好像目前java没有对尾递归做优化。</p>\n</blockquote>\n<h3 id=\"插入的修复\"><a href=\"#插入的修复\" class=\"headerlink\" title=\"插入的修复\"></a>插入的修复</h3><p><img src=\"/images/红黑树插入调整.png\" alt=\"\"></p>\n<blockquote>\n<p>图片点击放大</p>\n</blockquote>\n<hr>\n<h3 id=\"删除的修复\"><a href=\"#删除的修复\" class=\"headerlink\" title=\"删除的修复\"></a>删除的修复</h3><p><img src=\"/images/红黑树删除修复.png\" alt=\"\"></p>\n"},{"title":"聊聊paxos","date":"2019-06-01T15:27:51.000Z","_content":"### 前言\n分布式，里面不得不提的一个分布式算法就paxos了。分布式一致性算法(Consensus Algorithm)是一个分布式计算领域的基础性问题，\n其最基本的功能是为了在多个进程之间对某个(某些)值达成一致(强一致);进而解决分布式系统的可用性问题(高可用).\n\n### 前言\n","source":"_posts/聊聊paxos.md","raw":"---\ntitle: 聊聊paxos\ndate: 2019-06-01 23:27:51\ntags: [paxos, 分布式]\n---\n### 前言\n分布式，里面不得不提的一个分布式算法就paxos了。分布式一致性算法(Consensus Algorithm)是一个分布式计算领域的基础性问题，\n其最基本的功能是为了在多个进程之间对某个(某些)值达成一致(强一致);进而解决分布式系统的可用性问题(高可用).\n\n### 前言\n","slug":"聊聊paxos","published":1,"updated":"2019-08-26T12:40:25.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0hkxqhq000pektva04us2wi","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>分布式，里面不得不提的一个分布式算法就paxos了。分布式一致性算法(Consensus Algorithm)是一个分布式计算领域的基础性问题，<br>其最基本的功能是为了在多个进程之间对某个(某些)值达成一致(强一致);进而解决分布式系统的可用性问题(高可用).</p>\n<h3 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h3>","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>分布式，里面不得不提的一个分布式算法就paxos了。分布式一致性算法(Consensus Algorithm)是一个分布式计算领域的基础性问题，<br>其最基本的功能是为了在多个进程之间对某个(某些)值达成一致(强一致);进而解决分布式系统的可用性问题(高可用).</p>\n<h3 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h3>"},{"title":"记一次生产多线程数据导出bug排查","date":"2019-07-20T07:24:42.000Z","top":true,"_content":"### 事情由来:\n同事在写一个数据导出的需求的时候遇到个问题，调用dubbo后没响应，排查后是dubbo数据量多无法传输，\n于是我用idea的evaluation动态调整了数据量的大小去运行，发现大概要到500条数据左右的时候consumer才能\n得到响应，后来同事便调整了一下数据量，使用了线程池和callable,future来导出。于是bug开始产生了.  \n\n### 发展：\n同事代码写完后，数据接口调用的时间很长，得有二十来秒吧。由于需求来的**又快又急**，便匆忙上线了，结果第二\n天使用的时候发现有的时候数据导出不完全正确，bug时有时无的。我开始还没有在意，直到他们一直在那里讨\n论，而且这个需求已经耽误比较久了，于是想着反正我事情也做完了，我便看一下是什么鬼东西在作怪。\n\n### 入手：\n刚开始看代码的时候是这样的：各种奇怪的逻辑，就不贴上来的，贴上一段主要问题所在的那一段：\n主要的逻辑是这样的：\n先用查询参数查出数据量,\n然后给每个线程指定一定的分页页数,\n查询后,通过future的get方法拿出来放入到结果中......\n\n~~~ java\npublic class controller{\n    \n    @RequestMapping(value = \"/exportExcel\")\n\t@ResponseBody\n\tpublic synchronized String  exportExcel(QueryParam queryParam, HttpServletResponse response) {\n\t\tqueryParam.setIsExport(\"export\");\n\t\tPageBo<Map<String,Object>> pageBoPage;\n\t\tList<Map<String,Object>> resultList = new ArrayList<>();\n\t\t// 根据数据量控制导出情况\n\t\tint totalData = excelService.countOfficialMicroBlogPutList(queryParam).getCount();\n\t\tint rows = 100;\n\t\t// 线程的个数\n\t\tint nThread = 5;\n\t\t//每个线程需要处理的页数\n\t\tint pageEachThread = pageTotal/nThread + 1;\n\t\tlogger.info(\"每条线程需要查询的页数：[{}]\",pageEachThread);\n\t\tif( pageEachThread < 1 ){\n\t\t\tfor(int i = 0 ; i < pageTotal ; i++){\n\t\t\t\tparam.setPage(i+1);\n\t\t\t\tparam.setRows(rows);\n\t\t\t\tpageBoPage = excelService.getOfficialMicroBlogPutList(param);\n\t\t\t\tresultList.addAll(pageBoPage.getDataList());\n\t\t\t}\n\t\t} else {\n\t\t\tList<Future<List<Map<String, Object>>>> futures = new ArrayList<>();\n\t\t\ttry{\n\t\t\t\tfor(int j = 1; j <= nThread; j ++){\n\t\t\t\t\tint start = (1 + (j - 1) * pageEachThread);\n\t\t\t\t\tThreadExcel worker = new ThreadExcel(start, rows, pageEachThread, param, excelService);\n\t\t\t\t\tFuture<List<Map<String, Object>>> future = executorService.submit();\n\t\t\t\t\tfutures.add(future);\n\t\t\t\t}\n\t\t\t\tfor(Future<List<Map<String, Object>>> f : futures){\n\t\t\t\t\tresultList.addAll(f.get());\n\t\t\t\t}\n\t\t\t} catch (Exception e){\n\t\t\t\tlogger.error(\"投放查询导出失败\", e);\n\t\t\t}finally {\n\t\t\t\texecutorService.shutdown();\n\t\t\t}\n\t\t}\n\t\t// ......其他代码\n    }\n\n    private class ThreadExcel implements Callable {\n    \n        private Integer start;\n        private Integer rows;\n        private Integer pageEachThread;\n        private QueryParam queryParam;\n        private ExcelService excelService;\n    \n        private ThreadExcel(Integer start,Integer rows,Integer pageEachThread,QueryParam queryParam, ExcelService excelService){\n            this.start = start;\n            this.rows = rows;\n            this.pageEachThread = pageEachThread;\n            this.queryParam = queryParam;\n            this.excelService = excelService;\n        }\n    \n        @Override\n        public List<Map<String, Object>> call() {\n            List<Map<String, Object>> list = new ArrayList<>();\n            for (int k = start; k < start + pageEachThread; k++) {\n                param.setPage(k);// --------- 这里注意一下\n                param.setRows(rows);\n                try{\n                    PageBo<Map<String, Object>> pageList = excelService.getOfficialMicroBlogPutList(param);\n                    list.addAll(pageList.getDataList());\n                }catch (Exception e){\n                    logger.error(e);\n                }\n            }\n            return list;\n        }\n    }\n}\n\n~~~\n\n额，应该是写多线程写的确实比较少吧，一拿到这块代码感觉改的地方至少有三点了，\n1. 主要是线程池的使用是一方面，\n2. 还有就是**线程安全**的一些问题。\n3. 线程的创建记得只写核心参数不要无用参数。\n好了，最重要的东西来了，为什么接口有时候正确有时候又不正确呢？\n\n#### 思路：\n前后代码看了看，只可能是多线程这里的使用出了问题：仔细看一下线程的代码有将queryParam这个\n参数传入线程里重新set页然后数去查询。但是这里可是只有一个queryParam对象啊，那么多线程去setPage() 然后交给线程池，\n你能线程保证自己去拿的时候是自己set的那个分页参数么？显然是有线程安全问题的。线程执行的时候不一定拿到的是自己set的分页参数！\n\n初步定位到了问题我改善了下这小部分代码\n验证的代码：\n~~~java\npublic class Controller{\n\t\n\t@RequestMapping(value = \"/exportExcel\")\n\t@ResponseBody\n\tpublic String exportExcel(QueryParam queryParam, HttpServletResponse response) {\n\t\tparam.setIsExport(\"export\");\n\t    synchronized (this.exportLock){\n            List<Map<String,Object>> resultList = new ArrayList<>();\n            Long total = excelService.countOfficialMicroBlogPutList(queryParam);\n            // 虽然500条能拉回来但是有的数据比较大，所以就取了100--------------------------------------\n            params.setRows(100);\n            int totalPage =  (int)(total/100) + 1;\n            List<Future<List<Map<String, Object>>>> futures = new ArrayList<>();\n            for (int i = 1; i <= totalPage; i++) {\n                Future<List<Map<String, Object>>> submit = taskExecutor.submit(new ExcelWorker(i, queryParam));\n                futures.add(submit);\n            }\n            for(Future<List<Map<String, Object>>> f : futures){\n                try {\n                    resultList.addAll(f.get());\n                } catch (InterruptedException | ExecutionException e) {\n                    logger.error(\"获取数据异常\", e);\n                }\n            }\n            //-----------------------------------简洁快速的代码-----------------------------------\n\t    }\n\t\t//........\n\t}\n\t\n    private class ExcelWorker implements Callable{\n\t\t\n\t\tprivate int page;\n        private QueryParam queryParam;\n\t\t\n\t\tExcelWorker(int page, QueryParam queryParam) {\n\t\t\tthis.page = page;\n\t\t\tthis.queryParam = queryParam;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic List<Map<String, Object>> call() {\n\t\t\tQueryParam params = new QueryParam();\n\t\t\tBeanUtils.copyProperties(pageParam, params);\n\t\t\tparams.setPage(page);\n\t\t\t// 只取不变的部分\n\t\t\ttry {\n\t\t\t\tPageBo<Map<String, Object>> threadPage = excelService.getOfficialMicroBlogPutList(params);\n\t\t\t\treturn threadPage.getDataList();\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.error(\"分页查询异常\", e);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n}\n\n~~~\n\n先说结果：优化后的代码没有出现数据问题，响应也比较快,2s左右就可以看到表格导出了。完全符合要求了。\n主要是以下几点改进：\n1. 线程问题，安全这些线程都应该用自己的分页参数去请求，接口所以必须得clone(深度)或者copy一个新的对象才可以。\n2. worker的优化：只要两个不可缺的关键参数(还有就是copy的任务交给线程，不要让主线程做这么无聊的事情)\n3. 直接交个线程池处理后再去使用Future去取得结果。\n4. 不用去shutdown线程池，如果你是自己创建的线程池，他自己会管理自己。\n\n这篇文章对那些大佬是没什么提升的，对于没有接触过多线程，Callable,Future等等的人来说这些东西确实是比较棘手的,\n但是只要认真分析出问题的代码行附近，认真分析对比还是比较快速就能得到答案的。\n\n\n\n\n\n\n\n\n\n","source":"_posts/记一次生产多线程数据导出bug排查.md","raw":"---\ntitle: 记一次生产多线程数据导出bug排查\ndate: 2019-07-20 15:24:42\ntags: [多线程, 并发, dubbo, callable, future]\ntop: true\n---\n### 事情由来:\n同事在写一个数据导出的需求的时候遇到个问题，调用dubbo后没响应，排查后是dubbo数据量多无法传输，\n于是我用idea的evaluation动态调整了数据量的大小去运行，发现大概要到500条数据左右的时候consumer才能\n得到响应，后来同事便调整了一下数据量，使用了线程池和callable,future来导出。于是bug开始产生了.  \n\n### 发展：\n同事代码写完后，数据接口调用的时间很长，得有二十来秒吧。由于需求来的**又快又急**，便匆忙上线了，结果第二\n天使用的时候发现有的时候数据导出不完全正确，bug时有时无的。我开始还没有在意，直到他们一直在那里讨\n论，而且这个需求已经耽误比较久了，于是想着反正我事情也做完了，我便看一下是什么鬼东西在作怪。\n\n### 入手：\n刚开始看代码的时候是这样的：各种奇怪的逻辑，就不贴上来的，贴上一段主要问题所在的那一段：\n主要的逻辑是这样的：\n先用查询参数查出数据量,\n然后给每个线程指定一定的分页页数,\n查询后,通过future的get方法拿出来放入到结果中......\n\n~~~ java\npublic class controller{\n    \n    @RequestMapping(value = \"/exportExcel\")\n\t@ResponseBody\n\tpublic synchronized String  exportExcel(QueryParam queryParam, HttpServletResponse response) {\n\t\tqueryParam.setIsExport(\"export\");\n\t\tPageBo<Map<String,Object>> pageBoPage;\n\t\tList<Map<String,Object>> resultList = new ArrayList<>();\n\t\t// 根据数据量控制导出情况\n\t\tint totalData = excelService.countOfficialMicroBlogPutList(queryParam).getCount();\n\t\tint rows = 100;\n\t\t// 线程的个数\n\t\tint nThread = 5;\n\t\t//每个线程需要处理的页数\n\t\tint pageEachThread = pageTotal/nThread + 1;\n\t\tlogger.info(\"每条线程需要查询的页数：[{}]\",pageEachThread);\n\t\tif( pageEachThread < 1 ){\n\t\t\tfor(int i = 0 ; i < pageTotal ; i++){\n\t\t\t\tparam.setPage(i+1);\n\t\t\t\tparam.setRows(rows);\n\t\t\t\tpageBoPage = excelService.getOfficialMicroBlogPutList(param);\n\t\t\t\tresultList.addAll(pageBoPage.getDataList());\n\t\t\t}\n\t\t} else {\n\t\t\tList<Future<List<Map<String, Object>>>> futures = new ArrayList<>();\n\t\t\ttry{\n\t\t\t\tfor(int j = 1; j <= nThread; j ++){\n\t\t\t\t\tint start = (1 + (j - 1) * pageEachThread);\n\t\t\t\t\tThreadExcel worker = new ThreadExcel(start, rows, pageEachThread, param, excelService);\n\t\t\t\t\tFuture<List<Map<String, Object>>> future = executorService.submit();\n\t\t\t\t\tfutures.add(future);\n\t\t\t\t}\n\t\t\t\tfor(Future<List<Map<String, Object>>> f : futures){\n\t\t\t\t\tresultList.addAll(f.get());\n\t\t\t\t}\n\t\t\t} catch (Exception e){\n\t\t\t\tlogger.error(\"投放查询导出失败\", e);\n\t\t\t}finally {\n\t\t\t\texecutorService.shutdown();\n\t\t\t}\n\t\t}\n\t\t// ......其他代码\n    }\n\n    private class ThreadExcel implements Callable {\n    \n        private Integer start;\n        private Integer rows;\n        private Integer pageEachThread;\n        private QueryParam queryParam;\n        private ExcelService excelService;\n    \n        private ThreadExcel(Integer start,Integer rows,Integer pageEachThread,QueryParam queryParam, ExcelService excelService){\n            this.start = start;\n            this.rows = rows;\n            this.pageEachThread = pageEachThread;\n            this.queryParam = queryParam;\n            this.excelService = excelService;\n        }\n    \n        @Override\n        public List<Map<String, Object>> call() {\n            List<Map<String, Object>> list = new ArrayList<>();\n            for (int k = start; k < start + pageEachThread; k++) {\n                param.setPage(k);// --------- 这里注意一下\n                param.setRows(rows);\n                try{\n                    PageBo<Map<String, Object>> pageList = excelService.getOfficialMicroBlogPutList(param);\n                    list.addAll(pageList.getDataList());\n                }catch (Exception e){\n                    logger.error(e);\n                }\n            }\n            return list;\n        }\n    }\n}\n\n~~~\n\n额，应该是写多线程写的确实比较少吧，一拿到这块代码感觉改的地方至少有三点了，\n1. 主要是线程池的使用是一方面，\n2. 还有就是**线程安全**的一些问题。\n3. 线程的创建记得只写核心参数不要无用参数。\n好了，最重要的东西来了，为什么接口有时候正确有时候又不正确呢？\n\n#### 思路：\n前后代码看了看，只可能是多线程这里的使用出了问题：仔细看一下线程的代码有将queryParam这个\n参数传入线程里重新set页然后数去查询。但是这里可是只有一个queryParam对象啊，那么多线程去setPage() 然后交给线程池，\n你能线程保证自己去拿的时候是自己set的那个分页参数么？显然是有线程安全问题的。线程执行的时候不一定拿到的是自己set的分页参数！\n\n初步定位到了问题我改善了下这小部分代码\n验证的代码：\n~~~java\npublic class Controller{\n\t\n\t@RequestMapping(value = \"/exportExcel\")\n\t@ResponseBody\n\tpublic String exportExcel(QueryParam queryParam, HttpServletResponse response) {\n\t\tparam.setIsExport(\"export\");\n\t    synchronized (this.exportLock){\n            List<Map<String,Object>> resultList = new ArrayList<>();\n            Long total = excelService.countOfficialMicroBlogPutList(queryParam);\n            // 虽然500条能拉回来但是有的数据比较大，所以就取了100--------------------------------------\n            params.setRows(100);\n            int totalPage =  (int)(total/100) + 1;\n            List<Future<List<Map<String, Object>>>> futures = new ArrayList<>();\n            for (int i = 1; i <= totalPage; i++) {\n                Future<List<Map<String, Object>>> submit = taskExecutor.submit(new ExcelWorker(i, queryParam));\n                futures.add(submit);\n            }\n            for(Future<List<Map<String, Object>>> f : futures){\n                try {\n                    resultList.addAll(f.get());\n                } catch (InterruptedException | ExecutionException e) {\n                    logger.error(\"获取数据异常\", e);\n                }\n            }\n            //-----------------------------------简洁快速的代码-----------------------------------\n\t    }\n\t\t//........\n\t}\n\t\n    private class ExcelWorker implements Callable{\n\t\t\n\t\tprivate int page;\n        private QueryParam queryParam;\n\t\t\n\t\tExcelWorker(int page, QueryParam queryParam) {\n\t\t\tthis.page = page;\n\t\t\tthis.queryParam = queryParam;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic List<Map<String, Object>> call() {\n\t\t\tQueryParam params = new QueryParam();\n\t\t\tBeanUtils.copyProperties(pageParam, params);\n\t\t\tparams.setPage(page);\n\t\t\t// 只取不变的部分\n\t\t\ttry {\n\t\t\t\tPageBo<Map<String, Object>> threadPage = excelService.getOfficialMicroBlogPutList(params);\n\t\t\t\treturn threadPage.getDataList();\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.error(\"分页查询异常\", e);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n}\n\n~~~\n\n先说结果：优化后的代码没有出现数据问题，响应也比较快,2s左右就可以看到表格导出了。完全符合要求了。\n主要是以下几点改进：\n1. 线程问题，安全这些线程都应该用自己的分页参数去请求，接口所以必须得clone(深度)或者copy一个新的对象才可以。\n2. worker的优化：只要两个不可缺的关键参数(还有就是copy的任务交给线程，不要让主线程做这么无聊的事情)\n3. 直接交个线程池处理后再去使用Future去取得结果。\n4. 不用去shutdown线程池，如果你是自己创建的线程池，他自己会管理自己。\n\n这篇文章对那些大佬是没什么提升的，对于没有接触过多线程，Callable,Future等等的人来说这些东西确实是比较棘手的,\n但是只要认真分析出问题的代码行附近，认真分析对比还是比较快速就能得到答案的。\n\n\n\n\n\n\n\n\n\n","slug":"记一次生产多线程数据导出bug排查","published":1,"updated":"2019-08-20T14:16:35.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0hkxqht000sektvlkvkkeww","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"事情由来\"><a href=\"#事情由来\" class=\"headerlink\" title=\"事情由来:\"></a>事情由来:</h3><p>同事在写一个数据导出的需求的时候遇到个问题，调用dubbo后没响应，排查后是dubbo数据量多无法传输，<br>于是我用idea的evaluation动态调整了数据量的大小去运行，发现大概要到500条数据左右的时候consumer才能<br>得到响应，后来同事便调整了一下数据量，使用了线程池和callable,future来导出。于是bug开始产生了.  </p>\n<h3 id=\"发展：\"><a href=\"#发展：\" class=\"headerlink\" title=\"发展：\"></a>发展：</h3><p>同事代码写完后，数据接口调用的时间很长，得有二十来秒吧。由于需求来的<strong>又快又急</strong>，便匆忙上线了，结果第二<br>天使用的时候发现有的时候数据导出不完全正确，bug时有时无的。我开始还没有在意，直到他们一直在那里讨<br>论，而且这个需求已经耽误比较久了，于是想着反正我事情也做完了，我便看一下是什么鬼东西在作怪。</p>\n<h3 id=\"入手：\"><a href=\"#入手：\" class=\"headerlink\" title=\"入手：\"></a>入手：</h3><p>刚开始看代码的时候是这样的：各种奇怪的逻辑，就不贴上来的，贴上一段主要问题所在的那一段：<br>主要的逻辑是这样的：<br>先用查询参数查出数据量,<br>然后给每个线程指定一定的分页页数,<br>查询后,通过future的get方法拿出来放入到结果中……</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">controller</span><span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"/exportExcel\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@ResponseBody</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> String  <span class=\"token function\">exportExcel</span><span class=\"token punctuation\">(</span>QueryParam queryParam<span class=\"token punctuation\">,</span> HttpServletResponse response<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        queryParam<span class=\"token punctuation\">.</span><span class=\"token function\">setIsExport</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"export\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        PageBo<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span>Object<span class=\"token operator\">>></span> pageBoPage<span class=\"token punctuation\">;</span>\n        List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span>Object<span class=\"token operator\">>></span> resultList <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 根据数据量控制导出情况</span>\n        <span class=\"token keyword\">int</span> totalData <span class=\"token operator\">=</span> excelService<span class=\"token punctuation\">.</span><span class=\"token function\">countOfficialMicroBlogPutList</span><span class=\"token punctuation\">(</span>queryParam<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> rows <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 线程的个数</span>\n        <span class=\"token keyword\">int</span> nThread <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//每个线程需要处理的页数</span>\n        <span class=\"token keyword\">int</span> pageEachThread <span class=\"token operator\">=</span> pageTotal<span class=\"token operator\">/</span>nThread <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        logger<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"每条线程需要查询的页数：[{}]\"</span><span class=\"token punctuation\">,</span>pageEachThread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> pageEachThread <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> pageTotal <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                param<span class=\"token punctuation\">.</span><span class=\"token function\">setPage</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                param<span class=\"token punctuation\">.</span><span class=\"token function\">setRows</span><span class=\"token punctuation\">(</span>rows<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                pageBoPage <span class=\"token operator\">=</span> excelService<span class=\"token punctuation\">.</span><span class=\"token function\">getOfficialMicroBlogPutList</span><span class=\"token punctuation\">(</span>param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                resultList<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>pageBoPage<span class=\"token punctuation\">.</span><span class=\"token function\">getDataList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            List<span class=\"token operator\">&lt;</span>Future<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">>>></span><span class=\"token operator\">></span> futures <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> nThread<span class=\"token punctuation\">;</span> j <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">int</span> start <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> pageEachThread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    ThreadExcel worker <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadExcel</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> rows<span class=\"token punctuation\">,</span> pageEachThread<span class=\"token punctuation\">,</span> param<span class=\"token punctuation\">,</span> excelService<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    Future<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">>>></span> future <span class=\"token operator\">=</span> executorService<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    futures<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>future<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>Future<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">>>></span> f <span class=\"token operator\">:</span> futures<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    resultList<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                logger<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"投放查询导出失败\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n                executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// ......其他代码</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadExcel</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Callable</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">private</span> Integer start<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">private</span> Integer rows<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">private</span> Integer pageEachThread<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">private</span> QueryParam queryParam<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">private</span> ExcelService excelService<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">private</span> <span class=\"token function\">ThreadExcel</span><span class=\"token punctuation\">(</span>Integer start<span class=\"token punctuation\">,</span>Integer rows<span class=\"token punctuation\">,</span>Integer pageEachThread<span class=\"token punctuation\">,</span>QueryParam queryParam<span class=\"token punctuation\">,</span> ExcelService excelService<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>start <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>rows <span class=\"token operator\">=</span> rows<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>pageEachThread <span class=\"token operator\">=</span> pageEachThread<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>queryParam <span class=\"token operator\">=</span> queryParam<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>excelService <span class=\"token operator\">=</span> excelService<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">>></span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">>></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> start <span class=\"token operator\">+</span> pageEachThread<span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                param<span class=\"token punctuation\">.</span><span class=\"token function\">setPage</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// --------- 这里注意一下</span>\n                param<span class=\"token punctuation\">.</span><span class=\"token function\">setRows</span><span class=\"token punctuation\">(</span>rows<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n                    PageBo<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">>></span> pageList <span class=\"token operator\">=</span> excelService<span class=\"token punctuation\">.</span><span class=\"token function\">getOfficialMicroBlogPutList</span><span class=\"token punctuation\">(</span>param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    list<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>pageList<span class=\"token punctuation\">.</span><span class=\"token function\">getDataList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    logger<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> list<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>额，应该是写多线程写的确实比较少吧，一拿到这块代码感觉改的地方至少有三点了，</p>\n<ol>\n<li>主要是线程池的使用是一方面，</li>\n<li>还有就是<strong>线程安全</strong>的一些问题。</li>\n<li>线程的创建记得只写核心参数不要无用参数。<br>好了，最重要的东西来了，为什么接口有时候正确有时候又不正确呢？</li>\n</ol>\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>前后代码看了看，只可能是多线程这里的使用出了问题：仔细看一下线程的代码有将queryParam这个<br>参数传入线程里重新set页然后数去查询。但是这里可是只有一个queryParam对象啊，那么多线程去setPage() 然后交给线程池，<br>你能线程保证自己去拿的时候是自己set的那个分页参数么？显然是有线程安全问题的。线程执行的时候不一定拿到的是自己set的分页参数！</p>\n<p>初步定位到了问题我改善了下这小部分代码<br>验证的代码：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Controller</span><span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"/exportExcel\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@ResponseBody</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">exportExcel</span><span class=\"token punctuation\">(</span>QueryParam queryParam<span class=\"token punctuation\">,</span> HttpServletResponse response<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        param<span class=\"token punctuation\">.</span><span class=\"token function\">setIsExport</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"export\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>exportLock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span>Object<span class=\"token operator\">>></span> resultList <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Long total <span class=\"token operator\">=</span> excelService<span class=\"token punctuation\">.</span><span class=\"token function\">countOfficialMicroBlogPutList</span><span class=\"token punctuation\">(</span>queryParam<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 虽然500条能拉回来但是有的数据比较大，所以就取了100--------------------------------------</span>\n            params<span class=\"token punctuation\">.</span><span class=\"token function\">setRows</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> totalPage <span class=\"token operator\">=</span>  <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>total<span class=\"token operator\">/</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            List<span class=\"token operator\">&lt;</span>Future<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">>>></span><span class=\"token operator\">></span> futures <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> totalPage<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                Future<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">>>></span> submit <span class=\"token operator\">=</span> taskExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ExcelWorker</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> queryParam<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                futures<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>submit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>Future<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">>>></span> f <span class=\"token operator\">:</span> futures<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    resultList<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> <span class=\"token operator\">|</span> ExecutionException e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    logger<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"获取数据异常\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//-----------------------------------简洁快速的代码-----------------------------------</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//........</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ExcelWorker</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Callable</span><span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> page<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">private</span> QueryParam queryParam<span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">ExcelWorker</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> page<span class=\"token punctuation\">,</span> QueryParam queryParam<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>page <span class=\"token operator\">=</span> page<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>queryParam <span class=\"token operator\">=</span> queryParam<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">>></span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            QueryParam params <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">QueryParam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            BeanUtils<span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>pageParam<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            params<span class=\"token punctuation\">.</span><span class=\"token function\">setPage</span><span class=\"token punctuation\">(</span>page<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 只取不变的部分</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                PageBo<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">>></span> threadPage <span class=\"token operator\">=</span> excelService<span class=\"token punctuation\">.</span><span class=\"token function\">getOfficialMicroBlogPutList</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> threadPage<span class=\"token punctuation\">.</span><span class=\"token function\">getDataList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                logger<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"分页查询异常\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>先说结果：优化后的代码没有出现数据问题，响应也比较快,2s左右就可以看到表格导出了。完全符合要求了。<br>主要是以下几点改进：</p>\n<ol>\n<li>线程问题，安全这些线程都应该用自己的分页参数去请求，接口所以必须得clone(深度)或者copy一个新的对象才可以。</li>\n<li>worker的优化：只要两个不可缺的关键参数(还有就是copy的任务交给线程，不要让主线程做这么无聊的事情)</li>\n<li>直接交个线程池处理后再去使用Future去取得结果。</li>\n<li>不用去shutdown线程池，如果你是自己创建的线程池，他自己会管理自己。</li>\n</ol>\n<p>这篇文章对那些大佬是没什么提升的，对于没有接触过多线程，Callable,Future等等的人来说这些东西确实是比较棘手的,<br>但是只要认真分析出问题的代码行附近，认真分析对比还是比较快速就能得到答案的。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h3 id=\"事情由来\"><a href=\"#事情由来\" class=\"headerlink\" title=\"事情由来:\"></a>事情由来:</h3><p>同事在写一个数据导出的需求的时候遇到个问题，调用dubbo后没响应，排查后是dubbo数据量多无法传输，<br>于是我用idea的evaluation动态调整了数据量的大小去运行，发现大概要到500条数据左右的时候consumer才能<br>得到响应，后来同事便调整了一下数据量，使用了线程池和callable,future来导出。于是bug开始产生了.  </p>\n<h3 id=\"发展：\"><a href=\"#发展：\" class=\"headerlink\" title=\"发展：\"></a>发展：</h3><p>同事代码写完后，数据接口调用的时间很长，得有二十来秒吧。由于需求来的<strong>又快又急</strong>，便匆忙上线了，结果第二<br>天使用的时候发现有的时候数据导出不完全正确，bug时有时无的。我开始还没有在意，直到他们一直在那里讨<br>论，而且这个需求已经耽误比较久了，于是想着反正我事情也做完了，我便看一下是什么鬼东西在作怪。</p>\n<h3 id=\"入手：\"><a href=\"#入手：\" class=\"headerlink\" title=\"入手：\"></a>入手：</h3><p>刚开始看代码的时候是这样的：各种奇怪的逻辑，就不贴上来的，贴上一段主要问题所在的那一段：<br>主要的逻辑是这样的：<br>先用查询参数查出数据量,<br>然后给每个线程指定一定的分页页数,<br>查询后,通过future的get方法拿出来放入到结果中……</p>\n<pre><code class=\"java\">public class controller{\n\n    @RequestMapping(value = &quot;/exportExcel&quot;)\n    @ResponseBody\n    public synchronized String  exportExcel(QueryParam queryParam, HttpServletResponse response) {\n        queryParam.setIsExport(&quot;export&quot;);\n        PageBo&lt;Map&lt;String,Object&gt;&gt; pageBoPage;\n        List&lt;Map&lt;String,Object&gt;&gt; resultList = new ArrayList&lt;&gt;();\n        // 根据数据量控制导出情况\n        int totalData = excelService.countOfficialMicroBlogPutList(queryParam).getCount();\n        int rows = 100;\n        // 线程的个数\n        int nThread = 5;\n        //每个线程需要处理的页数\n        int pageEachThread = pageTotal/nThread + 1;\n        logger.info(&quot;每条线程需要查询的页数：[{}]&quot;,pageEachThread);\n        if( pageEachThread &lt; 1 ){\n            for(int i = 0 ; i &lt; pageTotal ; i++){\n                param.setPage(i+1);\n                param.setRows(rows);\n                pageBoPage = excelService.getOfficialMicroBlogPutList(param);\n                resultList.addAll(pageBoPage.getDataList());\n            }\n        } else {\n            List&lt;Future&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; futures = new ArrayList&lt;&gt;();\n            try{\n                for(int j = 1; j &lt;= nThread; j ++){\n                    int start = (1 + (j - 1) * pageEachThread);\n                    ThreadExcel worker = new ThreadExcel(start, rows, pageEachThread, param, excelService);\n                    Future&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; future = executorService.submit();\n                    futures.add(future);\n                }\n                for(Future&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; f : futures){\n                    resultList.addAll(f.get());\n                }\n            } catch (Exception e){\n                logger.error(&quot;投放查询导出失败&quot;, e);\n            }finally {\n                executorService.shutdown();\n            }\n        }\n        // ......其他代码\n    }\n\n    private class ThreadExcel implements Callable {\n\n        private Integer start;\n        private Integer rows;\n        private Integer pageEachThread;\n        private QueryParam queryParam;\n        private ExcelService excelService;\n\n        private ThreadExcel(Integer start,Integer rows,Integer pageEachThread,QueryParam queryParam, ExcelService excelService){\n            this.start = start;\n            this.rows = rows;\n            this.pageEachThread = pageEachThread;\n            this.queryParam = queryParam;\n            this.excelService = excelService;\n        }\n\n        @Override\n        public List&lt;Map&lt;String, Object&gt;&gt; call() {\n            List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();\n            for (int k = start; k &lt; start + pageEachThread; k++) {\n                param.setPage(k);// --------- 这里注意一下\n                param.setRows(rows);\n                try{\n                    PageBo&lt;Map&lt;String, Object&gt;&gt; pageList = excelService.getOfficialMicroBlogPutList(param);\n                    list.addAll(pageList.getDataList());\n                }catch (Exception e){\n                    logger.error(e);\n                }\n            }\n            return list;\n        }\n    }\n}\n\n</code></pre>\n<p>额，应该是写多线程写的确实比较少吧，一拿到这块代码感觉改的地方至少有三点了，</p>\n<ol>\n<li>主要是线程池的使用是一方面，</li>\n<li>还有就是<strong>线程安全</strong>的一些问题。</li>\n<li>线程的创建记得只写核心参数不要无用参数。<br>好了，最重要的东西来了，为什么接口有时候正确有时候又不正确呢？</li>\n</ol>\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>前后代码看了看，只可能是多线程这里的使用出了问题：仔细看一下线程的代码有将queryParam这个<br>参数传入线程里重新set页然后数去查询。但是这里可是只有一个queryParam对象啊，那么多线程去setPage() 然后交给线程池，<br>你能线程保证自己去拿的时候是自己set的那个分页参数么？显然是有线程安全问题的。线程执行的时候不一定拿到的是自己set的分页参数！</p>\n<p>初步定位到了问题我改善了下这小部分代码<br>验证的代码：</p>\n<pre><code class=\"java\">public class Controller{\n\n    @RequestMapping(value = &quot;/exportExcel&quot;)\n    @ResponseBody\n    public String exportExcel(QueryParam queryParam, HttpServletResponse response) {\n        param.setIsExport(&quot;export&quot;);\n        synchronized (this.exportLock){\n            List&lt;Map&lt;String,Object&gt;&gt; resultList = new ArrayList&lt;&gt;();\n            Long total = excelService.countOfficialMicroBlogPutList(queryParam);\n            // 虽然500条能拉回来但是有的数据比较大，所以就取了100--------------------------------------\n            params.setRows(100);\n            int totalPage =  (int)(total/100) + 1;\n            List&lt;Future&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; futures = new ArrayList&lt;&gt;();\n            for (int i = 1; i &lt;= totalPage; i++) {\n                Future&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; submit = taskExecutor.submit(new ExcelWorker(i, queryParam));\n                futures.add(submit);\n            }\n            for(Future&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; f : futures){\n                try {\n                    resultList.addAll(f.get());\n                } catch (InterruptedException | ExecutionException e) {\n                    logger.error(&quot;获取数据异常&quot;, e);\n                }\n            }\n            //-----------------------------------简洁快速的代码-----------------------------------\n        }\n        //........\n    }\n\n    private class ExcelWorker implements Callable{\n\n        private int page;\n        private QueryParam queryParam;\n\n        ExcelWorker(int page, QueryParam queryParam) {\n            this.page = page;\n            this.queryParam = queryParam;\n        }\n\n        @Override\n        public List&lt;Map&lt;String, Object&gt;&gt; call() {\n            QueryParam params = new QueryParam();\n            BeanUtils.copyProperties(pageParam, params);\n            params.setPage(page);\n            // 只取不变的部分\n            try {\n                PageBo&lt;Map&lt;String, Object&gt;&gt; threadPage = excelService.getOfficialMicroBlogPutList(params);\n                return threadPage.getDataList();\n            } catch (Exception e) {\n                logger.error(&quot;分页查询异常&quot;, e);\n            }\n            return null;\n        }\n    }\n}\n\n</code></pre>\n<p>先说结果：优化后的代码没有出现数据问题，响应也比较快,2s左右就可以看到表格导出了。完全符合要求了。<br>主要是以下几点改进：</p>\n<ol>\n<li>线程问题，安全这些线程都应该用自己的分页参数去请求，接口所以必须得clone(深度)或者copy一个新的对象才可以。</li>\n<li>worker的优化：只要两个不可缺的关键参数(还有就是copy的任务交给线程，不要让主线程做这么无聊的事情)</li>\n<li>直接交个线程池处理后再去使用Future去取得结果。</li>\n<li>不用去shutdown线程池，如果你是自己创建的线程池，他自己会管理自己。</li>\n</ol>\n<p>这篇文章对那些大佬是没什么提升的，对于没有接触过多线程，Callable,Future等等的人来说这些东西确实是比较棘手的,<br>但是只要认真分析出问题的代码行附近，认真分析对比还是比较快速就能得到答案的。</p>\n"},{"title":"限流方案对比","date":"2019-01-21T10:57:53.000Z","_content":"\n## 广为流传的接口限流方案\n### 漏斗桶\n如果将请求比作是水，水来了都先放进桶里，并以限定的速度出水，桶满会溢出，体现为拒绝服务。\n漏斗有一个进水口和一个出水口，出水口以一定速率出水，并且有一个最大出水速率。\n在漏斗中没有水的时候，\n- 如果进水速率小于等于最大出水速率，那么，出水速率等于进水速率，不会积水\n- 如果进水速率大于最大出水速率，漏斗会以最大速率出水，此时，多余的水会积在漏斗中\n在漏斗中有水的时候\n- 出水口以最大速率出水\n- 如果漏斗未满，且有进水的话，那么这些水会积在漏斗中\n- 如果漏斗已满，且有进水的话，那么这些水会溢出到漏斗之外\n![](http://ww1.sinaimg.cn/large/006Cwrd9ly1fy4wszq4y5j31hc0u0thv.jpg)\n### 桶令牌\n对于很多应用场景来说，其实除了要求能够限制数据的平均传输速率外，还要应该求允许某种程度的突发传输。那么漏桶算法就无法满足，令牌桶算法更为适合。\n令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；\n当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。\n#### RateLimiter 用法\n#### [google的guava包](https://github.com/google/guava)\n```` java\n    // 测试一下\n    public class Test {\n    \n        public static void main(String[] args) {\n            ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(100));\n            // 指定每秒放1个令牌\n            RateLimiter limiter = RateLimiter.create(1);\n            for (int i = 1; i < 50; i++) {\n                // 请求RateLimiter, 超过permits会被阻塞\n                //acquire(int permits)函数主要用于获取permits个令牌，并计算需要等待多长时间，进而挂起等待，并将该值返回\n                  Double acquire = null;\n                if (i == 1) {\n                    acquire = limiter.acquire(1);\n                } else if (i == 2) {\n                    acquire = limiter.acquire(10);\n                } else if (i == 3) {\n                    acquire = limiter.acquire(2);\n                } else if (i == 4) {\n                    acquire = limiter.acquire(20);\n                } else {\n                    acquire = limiter.acquire(2);\n                }\n                executorService.submit(new Task(\"获取令牌成功，获取耗：\" + acquire + \" 第 \" + i + \" 个任务执行\"));\n            }\n        }\n    }\n    class Task implements Runnable {\n        String str;\n        public Task(String str) {\n            this.str = str;\n        }\n        @Override\n      public void run() {\n            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n            System.out.println(sdf.format(new Date()) + \" | \" + Thread.currentThread().getName() + str);\n        }\n    }\n````\nacquire函数主要用于获取permits个令牌，并计算需要等待多长时间，进而挂起等待，并将该值返回\n一个RateLimiter主要定义了发放permits的速率。如果没有额外的配置，permits将以固定的速度分配，单位是每秒多少permits。默认情况下，Permits将会被稳定的平缓的发放。\n### 令牌桶算法VS漏桶算法\n漏桶\n- 漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。\n令牌桶\n- 生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。\n\n## 还有那些简单易懂的?\n限流方案有很多他们有各自的使用场景，下面看两个有关key的限流\n### 环形窗口\n#### 实现\n- 用定时任务维护一个环，头结点走完一周的时间是指定的窗口时间\n- 每次访问key或者接口的时候见时间戳放入环内，头结点碰到的节点都会充值\n####\n- 优势可以异步维护各自的key的访问量，而不用主线程每次去判断\n- \n### 定制窗口\n- 每次请求记录时间戳，查看当前窗口内的节点数目，并将窗口外的节点删除\n- 每次请求先该key对应的节点数量少于指定的可以直接进入请求\n- 代码简单逻辑清晰容易实现","source":"_posts/限流方案对比.md","raw":"---\ntitle: 限流方案对比\ndate: 2019-01-21 18:57:53\ntags: 分布式\ncategories: [分布式]\n---\n\n## 广为流传的接口限流方案\n### 漏斗桶\n如果将请求比作是水，水来了都先放进桶里，并以限定的速度出水，桶满会溢出，体现为拒绝服务。\n漏斗有一个进水口和一个出水口，出水口以一定速率出水，并且有一个最大出水速率。\n在漏斗中没有水的时候，\n- 如果进水速率小于等于最大出水速率，那么，出水速率等于进水速率，不会积水\n- 如果进水速率大于最大出水速率，漏斗会以最大速率出水，此时，多余的水会积在漏斗中\n在漏斗中有水的时候\n- 出水口以最大速率出水\n- 如果漏斗未满，且有进水的话，那么这些水会积在漏斗中\n- 如果漏斗已满，且有进水的话，那么这些水会溢出到漏斗之外\n![](http://ww1.sinaimg.cn/large/006Cwrd9ly1fy4wszq4y5j31hc0u0thv.jpg)\n### 桶令牌\n对于很多应用场景来说，其实除了要求能够限制数据的平均传输速率外，还要应该求允许某种程度的突发传输。那么漏桶算法就无法满足，令牌桶算法更为适合。\n令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；\n当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。\n#### RateLimiter 用法\n#### [google的guava包](https://github.com/google/guava)\n```` java\n    // 测试一下\n    public class Test {\n    \n        public static void main(String[] args) {\n            ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(100));\n            // 指定每秒放1个令牌\n            RateLimiter limiter = RateLimiter.create(1);\n            for (int i = 1; i < 50; i++) {\n                // 请求RateLimiter, 超过permits会被阻塞\n                //acquire(int permits)函数主要用于获取permits个令牌，并计算需要等待多长时间，进而挂起等待，并将该值返回\n                  Double acquire = null;\n                if (i == 1) {\n                    acquire = limiter.acquire(1);\n                } else if (i == 2) {\n                    acquire = limiter.acquire(10);\n                } else if (i == 3) {\n                    acquire = limiter.acquire(2);\n                } else if (i == 4) {\n                    acquire = limiter.acquire(20);\n                } else {\n                    acquire = limiter.acquire(2);\n                }\n                executorService.submit(new Task(\"获取令牌成功，获取耗：\" + acquire + \" 第 \" + i + \" 个任务执行\"));\n            }\n        }\n    }\n    class Task implements Runnable {\n        String str;\n        public Task(String str) {\n            this.str = str;\n        }\n        @Override\n      public void run() {\n            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n            System.out.println(sdf.format(new Date()) + \" | \" + Thread.currentThread().getName() + str);\n        }\n    }\n````\nacquire函数主要用于获取permits个令牌，并计算需要等待多长时间，进而挂起等待，并将该值返回\n一个RateLimiter主要定义了发放permits的速率。如果没有额外的配置，permits将以固定的速度分配，单位是每秒多少permits。默认情况下，Permits将会被稳定的平缓的发放。\n### 令牌桶算法VS漏桶算法\n漏桶\n- 漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。\n令牌桶\n- 生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。\n\n## 还有那些简单易懂的?\n限流方案有很多他们有各自的使用场景，下面看两个有关key的限流\n### 环形窗口\n#### 实现\n- 用定时任务维护一个环，头结点走完一周的时间是指定的窗口时间\n- 每次访问key或者接口的时候见时间戳放入环内，头结点碰到的节点都会充值\n####\n- 优势可以异步维护各自的key的访问量，而不用主线程每次去判断\n- \n### 定制窗口\n- 每次请求记录时间戳，查看当前窗口内的节点数目，并将窗口外的节点删除\n- 每次请求先该key对应的节点数量少于指定的可以直接进入请求\n- 代码简单逻辑清晰容易实现","slug":"限流方案对比","published":1,"updated":"2019-08-18T07:37:55.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0hkxqhv000uektvlsn0x6tl","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"广为流传的接口限流方案\"><a href=\"#广为流传的接口限流方案\" class=\"headerlink\" title=\"广为流传的接口限流方案\"></a>广为流传的接口限流方案</h2><h3 id=\"漏斗桶\"><a href=\"#漏斗桶\" class=\"headerlink\" title=\"漏斗桶\"></a>漏斗桶</h3><p>如果将请求比作是水，水来了都先放进桶里，并以限定的速度出水，桶满会溢出，体现为拒绝服务。<br>漏斗有一个进水口和一个出水口，出水口以一定速率出水，并且有一个最大出水速率。<br>在漏斗中没有水的时候，</p>\n<ul>\n<li>如果进水速率小于等于最大出水速率，那么，出水速率等于进水速率，不会积水</li>\n<li>如果进水速率大于最大出水速率，漏斗会以最大速率出水，此时，多余的水会积在漏斗中<br>在漏斗中有水的时候</li>\n<li>出水口以最大速率出水</li>\n<li>如果漏斗未满，且有进水的话，那么这些水会积在漏斗中</li>\n<li><p>如果漏斗已满，且有进水的话，那么这些水会溢出到漏斗之外<br><img src=\"http://ww1.sinaimg.cn/large/006Cwrd9ly1fy4wszq4y5j31hc0u0thv.jpg\" alt=\"\"></p>\n<h3 id=\"桶令牌\"><a href=\"#桶令牌\" class=\"headerlink\" title=\"桶令牌\"></a>桶令牌</h3><p>对于很多应用场景来说，其实除了要求能够限制数据的平均传输速率外，还要应该求允许某种程度的突发传输。那么漏桶算法就无法满足，令牌桶算法更为适合。<br>令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；<br>当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。</p>\n<h4 id=\"RateLimiter-用法\"><a href=\"#RateLimiter-用法\" class=\"headerlink\" title=\"RateLimiter 用法\"></a>RateLimiter 用法</h4><h4 id=\"google的guava包\"><a href=\"#google的guava包\" class=\"headerlink\" title=\"google的guava包\"></a><a href=\"https://github.com/google/guava\">google的guava包</a></h4><pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token comment\" spellcheck=\"true\">// 测试一下</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          ListeningExecutorService executorService <span class=\"token operator\">=</span> MoreExecutors<span class=\"token punctuation\">.</span><span class=\"token function\">listeningDecorator</span><span class=\"token punctuation\">(</span>Executors<span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 指定每秒放1个令牌</span>\n          RateLimiter limiter <span class=\"token operator\">=</span> RateLimiter<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">50</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token comment\" spellcheck=\"true\">// 请求RateLimiter, 超过permits会被阻塞</span>\n              <span class=\"token comment\" spellcheck=\"true\">//acquire(int permits)函数主要用于获取permits个令牌，并计算需要等待多长时间，进而挂起等待，并将该值返回</span>\n                Double acquire <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n              <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                  acquire <span class=\"token operator\">=</span> limiter<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                  acquire <span class=\"token operator\">=</span> limiter<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                  acquire <span class=\"token operator\">=</span> limiter<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                  acquire <span class=\"token operator\">=</span> limiter<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                  acquire <span class=\"token operator\">=</span> limiter<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span>\n              executorService<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Task</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"获取令牌成功，获取耗：\"</span> <span class=\"token operator\">+</span> acquire <span class=\"token operator\">+</span> <span class=\"token string\">\" 第 \"</span> <span class=\"token operator\">+</span> i <span class=\"token operator\">+</span> <span class=\"token string\">\" 个任务执行\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">Task</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n      String str<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">public</span> <span class=\"token function\">Task</span><span class=\"token punctuation\">(</span>String str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>str <span class=\"token operator\">=</span> str<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          SimpleDateFormat sdf <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleDateFormat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"yyyy-MM-dd HH:mm:ss.SSS\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>sdf<span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" | \"</span> <span class=\"token operator\">+</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>acquire函数主要用于获取permits个令牌，并计算需要等待多长时间，进而挂起等待，并将该值返回<br>一个RateLimiter主要定义了发放permits的速率。如果没有额外的配置，permits将以固定的速度分配，单位是每秒多少permits。默认情况下，Permits将会被稳定的平缓的发放。</p>\n<h3 id=\"令牌桶算法VS漏桶算法\"><a href=\"#令牌桶算法VS漏桶算法\" class=\"headerlink\" title=\"令牌桶算法VS漏桶算法\"></a>令牌桶算法VS漏桶算法</h3><p>漏桶</p>\n</li>\n<li>漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。<br>令牌桶</li>\n<li>生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。</li>\n</ul>\n<h2 id=\"还有那些简单易懂的\"><a href=\"#还有那些简单易懂的\" class=\"headerlink\" title=\"还有那些简单易懂的?\"></a>还有那些简单易懂的?</h2><p>限流方案有很多他们有各自的使用场景，下面看两个有关key的限流</p>\n<h3 id=\"环形窗口\"><a href=\"#环形窗口\" class=\"headerlink\" title=\"环形窗口\"></a>环形窗口</h3><h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><ul>\n<li>用定时任务维护一个环，头结点走完一周的时间是指定的窗口时间</li>\n<li>每次访问key或者接口的时候见时间戳放入环内，头结点碰到的节点都会充值<br>####</li>\n<li>优势可以异步维护各自的key的访问量，而不用主线程每次去判断</li>\n<li><h3 id=\"定制窗口\"><a href=\"#定制窗口\" class=\"headerlink\" title=\"定制窗口\"></a>定制窗口</h3></li>\n<li>每次请求记录时间戳，查看当前窗口内的节点数目，并将窗口外的节点删除</li>\n<li>每次请求先该key对应的节点数量少于指定的可以直接进入请求</li>\n<li>代码简单逻辑清晰容易实现</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"广为流传的接口限流方案\"><a href=\"#广为流传的接口限流方案\" class=\"headerlink\" title=\"广为流传的接口限流方案\"></a>广为流传的接口限流方案</h2><h3 id=\"漏斗桶\"><a href=\"#漏斗桶\" class=\"headerlink\" title=\"漏斗桶\"></a>漏斗桶</h3><p>如果将请求比作是水，水来了都先放进桶里，并以限定的速度出水，桶满会溢出，体现为拒绝服务。<br>漏斗有一个进水口和一个出水口，出水口以一定速率出水，并且有一个最大出水速率。<br>在漏斗中没有水的时候，</p>\n<ul>\n<li>如果进水速率小于等于最大出水速率，那么，出水速率等于进水速率，不会积水</li>\n<li>如果进水速率大于最大出水速率，漏斗会以最大速率出水，此时，多余的水会积在漏斗中<br>在漏斗中有水的时候</li>\n<li>出水口以最大速率出水</li>\n<li>如果漏斗未满，且有进水的话，那么这些水会积在漏斗中</li>\n<li><p>如果漏斗已满，且有进水的话，那么这些水会溢出到漏斗之外<br><img src=\"http://ww1.sinaimg.cn/large/006Cwrd9ly1fy4wszq4y5j31hc0u0thv.jpg\" alt=\"\"></p>\n<h3 id=\"桶令牌\"><a href=\"#桶令牌\" class=\"headerlink\" title=\"桶令牌\"></a>桶令牌</h3><p>对于很多应用场景来说，其实除了要求能够限制数据的平均传输速率外，还要应该求允许某种程度的突发传输。那么漏桶算法就无法满足，令牌桶算法更为适合。<br>令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；<br>当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。</p>\n<h4 id=\"RateLimiter-用法\"><a href=\"#RateLimiter-用法\" class=\"headerlink\" title=\"RateLimiter 用法\"></a>RateLimiter 用法</h4><h4 id=\"google的guava包\"><a href=\"#google的guava包\" class=\"headerlink\" title=\"google的guava包\"></a><a href=\"https://github.com/google/guava\">google的guava包</a></h4><pre><code class=\"java\">  // 测试一下\n  public class Test {\n\n      public static void main(String[] args) {\n          ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(100));\n          // 指定每秒放1个令牌\n          RateLimiter limiter = RateLimiter.create(1);\n          for (int i = 1; i &lt; 50; i++) {\n              // 请求RateLimiter, 超过permits会被阻塞\n              //acquire(int permits)函数主要用于获取permits个令牌，并计算需要等待多长时间，进而挂起等待，并将该值返回\n                Double acquire = null;\n              if (i == 1) {\n                  acquire = limiter.acquire(1);\n              } else if (i == 2) {\n                  acquire = limiter.acquire(10);\n              } else if (i == 3) {\n                  acquire = limiter.acquire(2);\n              } else if (i == 4) {\n                  acquire = limiter.acquire(20);\n              } else {\n                  acquire = limiter.acquire(2);\n              }\n              executorService.submit(new Task(&quot;获取令牌成功，获取耗：&quot; + acquire + &quot; 第 &quot; + i + &quot; 个任务执行&quot;));\n          }\n      }\n  }\n  class Task implements Runnable {\n      String str;\n      public Task(String str) {\n          this.str = str;\n      }\n      @Override\n    public void run() {\n          SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);\n          System.out.println(sdf.format(new Date()) + &quot; | &quot; + Thread.currentThread().getName() + str);\n      }\n  }\n</code></pre>\n<p>acquire函数主要用于获取permits个令牌，并计算需要等待多长时间，进而挂起等待，并将该值返回<br>一个RateLimiter主要定义了发放permits的速率。如果没有额外的配置，permits将以固定的速度分配，单位是每秒多少permits。默认情况下，Permits将会被稳定的平缓的发放。</p>\n<h3 id=\"令牌桶算法VS漏桶算法\"><a href=\"#令牌桶算法VS漏桶算法\" class=\"headerlink\" title=\"令牌桶算法VS漏桶算法\"></a>令牌桶算法VS漏桶算法</h3><p>漏桶</p>\n</li>\n<li>漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。<br>令牌桶</li>\n<li>生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。</li>\n</ul>\n<h2 id=\"还有那些简单易懂的\"><a href=\"#还有那些简单易懂的\" class=\"headerlink\" title=\"还有那些简单易懂的?\"></a>还有那些简单易懂的?</h2><p>限流方案有很多他们有各自的使用场景，下面看两个有关key的限流</p>\n<h3 id=\"环形窗口\"><a href=\"#环形窗口\" class=\"headerlink\" title=\"环形窗口\"></a>环形窗口</h3><h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><ul>\n<li>用定时任务维护一个环，头结点走完一周的时间是指定的窗口时间</li>\n<li>每次访问key或者接口的时候见时间戳放入环内，头结点碰到的节点都会充值<br>####</li>\n<li>优势可以异步维护各自的key的访问量，而不用主线程每次去判断</li>\n<li><h3 id=\"定制窗口\"><a href=\"#定制窗口\" class=\"headerlink\" title=\"定制窗口\"></a>定制窗口</h3></li>\n<li>每次请求记录时间戳，查看当前窗口内的节点数目，并将窗口外的节点删除</li>\n<li>每次请求先该key对应的节点数量少于指定的可以直接进入请求</li>\n<li>代码简单逻辑清晰容易实现</li>\n</ul>\n"},{"title":"QuickSort Application in java","date":"2018-11-25T15:07:22.000Z","top":true,"_content":"![I love it when a plan comes together.](http://ww1.sinaimg.cn/large/006Cwrd9gy1fxskn2tpksj31hc0u0guq.jpg)\n### 前言：\n**对各种基本排序有了解的人都会知道，各种单一的排序都有他自己合适的使用场景，而快速排序是这种单一排序里面综合表现最好的。\n而实际应用中的排序可要考虑的情况实在是太多了，兴趣使然，我看了下jdk的快排，过程不多说看大佬究竟是怎么写的吧**\n\n>java中的Arrays.Sort()方法是我们常用的排序方法，有心的人肯定点进去源码里面看过的，随着jdk的变化这个排序也有持续的变动，\n说明维护的人还是很愿意花精力在这个方法上的，排序的算法代码对基本算法没有足够了解的人来说看起来还是很吃力的(我说的是以前的我)，\n花了点时间整理下这个算法。在看这个之前最好是对各种基本的排序有一定的了解，这样才不至于一脸懵。\n### 涉及的算法\n1. 插入排序(之前1.7有用binary insertion,既二分法找到插入点后copy)\n2. 归并排序\n3. 快速排序\n    - 单轴(one pivot)双切分快排序(带等号),也就是荷兰国旗问题优化.\n    - 双轴三切分快排\n4. 计数排序(用于数值范围小的情况，byte，short，char类型的时候)\n5. timSort(用于分析本身排序情况)\n\n### 核心思路\n尽量发掘各自单一排序算法自己优势，当有合适条件的时候就使用对应的基本排序，并穿插一些实用的优化：\n1. 小数据量：插入排序\n2. 适中：快速排序\n    - 结合插入排序\n    - 划分区间的时候，带等号使用单轴快排，否则双轴快排\n    - 递归调用自己 \n3. 大量：先分用timSort分析数据本身排序状况，\n    - 衡量指标：run(单调区间的长度)和runs(单调区间的数目)\n    - 满足对应的常量要求就用归并，否则就用快排(归并的次数太多就用快排，否则采用归并)\n    \n### 具体代码:(jdk1.8对int[]的排序)\n``` java\nclass Sort {\n    /**\n     * 将给定区间数组排序，如果可以的话使用归并排序\n     */\n    static void sort(int[] a, int left, int right,\n                         int[] work, int workBase, int workLen) {\n            // 对于数据量少的直接使用快排\n            if (right - left < QUICKSORT_THRESHOLD) {// 286\n                sort(a, left, right, true); // 基于插入，单双轴的快排见下面\n                return;\n            }\n    \n            /*  timSort分析数据排序情况， run[i]是第i个run的开始\n             *  一个run是一节单调区间(升序或者降序)\n             */\n            int[] run = new int[MAX_RUN_COUNT + 1];\n            int count = 0; run[0] = left;\n    \n            for (int k = left; k < right; run[count] = k) {\n                if (a[k] < a[k + 1]) { // \n                    while (++k <= right && a[k - 1] <= a[k]);\n                } else if (a[k] > a[k + 1]) { // 降序\n                    while (++k <= right && a[k - 1] >= a[k]);\n                    for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {\n                        int t = a[lo]; a[lo] = a[hi]; a[hi] = t;\n                    }\n                } else { // 相等\n                    for (int m = MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {\n                        if (--m == 0) { // 等号多了直接将这里短丢到快排里面\n                            sort(a, left, right, true);\n                            return;\n                        }\n                    }\n                }\n    \n                /* 如果数组不是高度结构化用快排代替归并(要合并的次数count太多了)\n                 */\n                if (++count == MAX_RUN_COUNT) {// 目前MAX_RUN_COUNT = 67\n                    sort(a, left, right, true); // 基于插入，单双轴的快排见下面\n                    return;\n                }\n            }\n            \n            // 下面是基于O(n)辅助空间的非递归归并，贴进来总体太长\n            // ...... 归并\n            // 结束\n        }\n}\n```  \n下面是**核心快排**(有点长)我梳理下：\n1. 小范围的用插入排序结束对应区间的排序，跳过\n2. 切分数组成6个区间（不是等分），中间有五个点，把这五个点排好序\n3. 判断这五个点有没有相等的\n    - 有：双轴三切分\n      - 前后部分直接递归（转到第一步）\n      - 如果中间的切分比较大的话，对他进行瘦身(把那些等于头尾的去掉后)再递归（转到第一步）\n    - 没有：单轴双切分，排除中间相等的点切分，后从方法开头递归（转到第一步）\n      \n```` java\nclass Sort{\n    /**\n     * Sorts the specified range of the array by Dual-Pivot Quicksort.\n     */\n    private static void sort(int[] a, int left, int right, boolean leftmost) {\n        int length = right - left + 1;\n\n        // 使用插入排序\n        if (length < INSERTION_SORT_THRESHOLD) { // INSERTION_SORT_THRESHOLD = 47\n            // 左边是否是最大\n            if (leftmost) {\n                // 普通的插入排序\n                for (int i = left, j = i; i < right; j = ++i) {\n                    int ai = a[i + 1];\n                    while (ai < a[j]) {\n                        a[j + 1] = a[j];\n                        if (j-- == left) {\n                            break;\n                        }\n                    }\n                    a[j + 1] = ai;\n                }\n            } else {\n                /*\n                 * 跳过最长升序\n                 */\n                do {\n                    if (left >= right) {\n                        return;\n                    }\n                } while (a[++left] >= a[left - 1]);\n\n                /*\n                 * 这里也不是普通的的插入排序，\n                 * 使用的是双元素插入法更优。\n                 */\n                for (int k = left; ++left <= right; k = ++left) {\n                    int a1 = a[k], a2 = a[left];\n\n                    if (a1 < a2) {\n                        a2 = a1; a1 = a[left];\n                    }\n                    while (a1 < a[--k]) {\n                        a[k + 2] = a[k];\n                    }\n                    a[++k + 1] = a1;\n\n                    while (a2 < a[--k]) {\n                        a[k + 1] = a[k];\n                    }\n                    a[k + 1] = a2;\n                }\n                int last = a[right];\n\n                while (last < a[--right]) {\n                    a[right + 1] = a[right];\n                }\n                a[right + 1] = last;\n            }\n            return;\n        }\n\n        // 快速得到接近七等分的长度(1/8 + 1/64 = 9/64)的长度 + 1\n        int seventh = (length >> 3) + (length >> 6) + 1;\n        // 各个等分点\n        int e3 = (left + right) >>> 1; // The midpoint\n        int e2 = e3 - seventh;\n        int e1 = e2 - seventh;\n        int e4 = e3 + seventh;\n        int e5 = e4 + seventh;\n\n        // 用插入排序将这些点快速排好序\n        if (a[e2] < a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n\n        if (a[e3] < a[e2]) { int t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n            if (t < a[e1]) { a[e2] = a[e1]; a[e1] = t; }\n        }\n        if (a[e4] < a[e3]) { int t = a[e4]; a[e4] = a[e3]; a[e3] = t;\n            if (t < a[e2]) { a[e3] = a[e2]; a[e2] = t;\n                if (t < a[e1]) { a[e2] = a[e1]; a[e1] = t; }\n            }\n        }\n        if (a[e5] < a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t;\n            if (t < a[e3]) { a[e4] = a[e3]; a[e3] = t;\n                if (t < a[e2]) { a[e3] = a[e2]; a[e2] = t;\n                    if (t < a[e1]) { a[e2] = a[e1]; a[e1] = t; }\n                }\n            }\n        }\n\n        // Pointers\n        int less  = left;  // The index of the first element of center part\n        int great = right; // The index before the first element of right part\n\n        if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {\n            // 取第二和第四点为轴\n            int pivot1 = a[e2];\n            int pivot2 = a[e4];\n\n            a[e2] = a[left];\n            a[e4] = a[right];\n            \n            // 找到开始和结束向中间靠拢的合适下标\n            while (a[++less] < pivot1);\n            while (a[--great] > pivot2);\n            \n            // 双轴三切分排序\n            /*\n             *   left part           center part                   right part\n             * +--------------------------------------------------------------+\n             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |\n             * +--------------------------------------------------------------+\n             *               ^                          ^       ^\n             *               |                          |       |\n             *              less                        k     great\n             */\n            outer:\n            for (int k = less - 1; ++k <= great; ) {\n                int ak = a[k];\n                if (ak < pivot1) { // Move a[k] to left part\n                    a[k] = a[less];\n                    a[less] = ak;\n                    ++less;\n                } else if (ak > pivot2) { // Move a[k] to right part\n                    while (a[great] > pivot2) {\n                        if (great-- == k) {\n                            break outer;\n                        }\n                    }\n                    if (a[great] < pivot1) { // a[great] <= pivot2\n                        a[k] = a[less];\n                        a[less] = a[great];\n                        ++less;\n                    } else { // pivot1 <= a[great] <= pivot2\n                        a[k] = a[great];\n                    }\n                    a[great] = ak;\n                    --great;\n                }\n            }\n\n            // Swap pivots into their final positions\n            a[left]  = a[less  - 1]; a[less  - 1] = pivot1;\n            a[right] = a[great + 1]; a[great + 1] = pivot2;\n\n            // 前后切分，递归\n            sort(a, left, less - 2, leftmost);\n            sort(a, great + 2, right, false);\n\n            /* \n             * 如果中间长度大于 length 4/7 的长度\n             */\n            if (less < e1 && e5 < great) {\n                while (a[less] == pivot1) {\n                    ++less;\n                }\n\n                while (a[great] == pivot2) {\n                    --great;\n                }\n\n                /*\n                 *   left part         center part                  right part\n                 * +----------------------------------------------------------+\n                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |\n                 * +----------------------------------------------------------+\n                 *              ^                        ^       ^\n                 *             less                      k     great\n                 */\n                outer:\n                for (int k = less - 1; ++k <= great; ) {\n                    int ak = a[k];\n                    if (ak == pivot1) { // Move a[k] to left part\n                        a[k] = a[less];\n                        a[less] = ak;\n                        ++less;\n                    } else if (ak == pivot2) { // Move a[k] to right part\n                        while (a[great] == pivot2) {\n                            if (great-- == k) {\n                                break outer;\n                            }\n                        }\n                        if (a[great] == pivot1) { // a[great] < pivot2\n                            a[k] = a[less];\n                            a[less] = pivot1;\n                            ++less;\n                        } else { // pivot1 < a[great] < pivot2\n                            a[k] = a[great];\n                        }\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n            }\n\n            // 中间递归\n            sort(a, less, great, false);\n\n        } else { // 单轴快排\n            int pivot = a[e3];\n\n            /*\n             *   left part    center part              right part\n             * +-------------------------------------------------+\n             * |  < pivot  |   == pivot   |     ?    |  > pivot  |\n             * +-------------------------------------------------+\n             *              ^              ^        ^\n             *             less            k      great\n             */\n            for (int k = less; k <= great; ++k) {\n                if (a[k] == pivot) {\n                    continue;\n                }\n                int ak = a[k];\n                if (ak < pivot) { // Move a[k] to left part\n                    a[k] = a[less];\n                    a[less] = ak;\n                    ++less;\n                } else { // a[k] > pivot - Move a[k] to right part\n                    while (a[great] > pivot) {\n                        --great;\n                    }\n                    if (a[great] < pivot) { // a[great] <= pivot\n                        a[k] = a[less];\n                        a[less] = a[great];\n                        ++less;\n                    } else { // a[great] == pivot\n                        a[k] = pivot;\n                    }\n                    a[great] = ak;\n                    --great;\n                }\n            }\n\n            /*\n             * 双切分，递归\n             */\n            sort(a, left, less - 1, leftmost);\n            sort(a, great + 1, right, false);\n        }\n    }\n}\n````\n我承认需要要有点耐心才能看完，如果你认真看完并理解了，看别的代码那就是小菜一碟了 - -。\n### 总结一下\n1. 数据量小(n<47)：使用插入排序\n2. 数据量大(n>286)：且符合归并排序的指标(run<33,runs<67)就用归并\n3. 别的时候都是使用快排递归解决\n\n   \n    ","source":"_posts/jdk的快速排序.md","raw":"title: 'QuickSort Application in java'\ndate: 2018-11-25 23:07:22\ntags: Algorithm\ncategories: [算法]\ntop: true\n---\n![I love it when a plan comes together.](http://ww1.sinaimg.cn/large/006Cwrd9gy1fxskn2tpksj31hc0u0guq.jpg)\n### 前言：\n**对各种基本排序有了解的人都会知道，各种单一的排序都有他自己合适的使用场景，而快速排序是这种单一排序里面综合表现最好的。\n而实际应用中的排序可要考虑的情况实在是太多了，兴趣使然，我看了下jdk的快排，过程不多说看大佬究竟是怎么写的吧**\n\n>java中的Arrays.Sort()方法是我们常用的排序方法，有心的人肯定点进去源码里面看过的，随着jdk的变化这个排序也有持续的变动，\n说明维护的人还是很愿意花精力在这个方法上的，排序的算法代码对基本算法没有足够了解的人来说看起来还是很吃力的(我说的是以前的我)，\n花了点时间整理下这个算法。在看这个之前最好是对各种基本的排序有一定的了解，这样才不至于一脸懵。\n### 涉及的算法\n1. 插入排序(之前1.7有用binary insertion,既二分法找到插入点后copy)\n2. 归并排序\n3. 快速排序\n    - 单轴(one pivot)双切分快排序(带等号),也就是荷兰国旗问题优化.\n    - 双轴三切分快排\n4. 计数排序(用于数值范围小的情况，byte，short，char类型的时候)\n5. timSort(用于分析本身排序情况)\n\n### 核心思路\n尽量发掘各自单一排序算法自己优势，当有合适条件的时候就使用对应的基本排序，并穿插一些实用的优化：\n1. 小数据量：插入排序\n2. 适中：快速排序\n    - 结合插入排序\n    - 划分区间的时候，带等号使用单轴快排，否则双轴快排\n    - 递归调用自己 \n3. 大量：先分用timSort分析数据本身排序状况，\n    - 衡量指标：run(单调区间的长度)和runs(单调区间的数目)\n    - 满足对应的常量要求就用归并，否则就用快排(归并的次数太多就用快排，否则采用归并)\n    \n### 具体代码:(jdk1.8对int[]的排序)\n``` java\nclass Sort {\n    /**\n     * 将给定区间数组排序，如果可以的话使用归并排序\n     */\n    static void sort(int[] a, int left, int right,\n                         int[] work, int workBase, int workLen) {\n            // 对于数据量少的直接使用快排\n            if (right - left < QUICKSORT_THRESHOLD) {// 286\n                sort(a, left, right, true); // 基于插入，单双轴的快排见下面\n                return;\n            }\n    \n            /*  timSort分析数据排序情况， run[i]是第i个run的开始\n             *  一个run是一节单调区间(升序或者降序)\n             */\n            int[] run = new int[MAX_RUN_COUNT + 1];\n            int count = 0; run[0] = left;\n    \n            for (int k = left; k < right; run[count] = k) {\n                if (a[k] < a[k + 1]) { // \n                    while (++k <= right && a[k - 1] <= a[k]);\n                } else if (a[k] > a[k + 1]) { // 降序\n                    while (++k <= right && a[k - 1] >= a[k]);\n                    for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {\n                        int t = a[lo]; a[lo] = a[hi]; a[hi] = t;\n                    }\n                } else { // 相等\n                    for (int m = MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {\n                        if (--m == 0) { // 等号多了直接将这里短丢到快排里面\n                            sort(a, left, right, true);\n                            return;\n                        }\n                    }\n                }\n    \n                /* 如果数组不是高度结构化用快排代替归并(要合并的次数count太多了)\n                 */\n                if (++count == MAX_RUN_COUNT) {// 目前MAX_RUN_COUNT = 67\n                    sort(a, left, right, true); // 基于插入，单双轴的快排见下面\n                    return;\n                }\n            }\n            \n            // 下面是基于O(n)辅助空间的非递归归并，贴进来总体太长\n            // ...... 归并\n            // 结束\n        }\n}\n```  \n下面是**核心快排**(有点长)我梳理下：\n1. 小范围的用插入排序结束对应区间的排序，跳过\n2. 切分数组成6个区间（不是等分），中间有五个点，把这五个点排好序\n3. 判断这五个点有没有相等的\n    - 有：双轴三切分\n      - 前后部分直接递归（转到第一步）\n      - 如果中间的切分比较大的话，对他进行瘦身(把那些等于头尾的去掉后)再递归（转到第一步）\n    - 没有：单轴双切分，排除中间相等的点切分，后从方法开头递归（转到第一步）\n      \n```` java\nclass Sort{\n    /**\n     * Sorts the specified range of the array by Dual-Pivot Quicksort.\n     */\n    private static void sort(int[] a, int left, int right, boolean leftmost) {\n        int length = right - left + 1;\n\n        // 使用插入排序\n        if (length < INSERTION_SORT_THRESHOLD) { // INSERTION_SORT_THRESHOLD = 47\n            // 左边是否是最大\n            if (leftmost) {\n                // 普通的插入排序\n                for (int i = left, j = i; i < right; j = ++i) {\n                    int ai = a[i + 1];\n                    while (ai < a[j]) {\n                        a[j + 1] = a[j];\n                        if (j-- == left) {\n                            break;\n                        }\n                    }\n                    a[j + 1] = ai;\n                }\n            } else {\n                /*\n                 * 跳过最长升序\n                 */\n                do {\n                    if (left >= right) {\n                        return;\n                    }\n                } while (a[++left] >= a[left - 1]);\n\n                /*\n                 * 这里也不是普通的的插入排序，\n                 * 使用的是双元素插入法更优。\n                 */\n                for (int k = left; ++left <= right; k = ++left) {\n                    int a1 = a[k], a2 = a[left];\n\n                    if (a1 < a2) {\n                        a2 = a1; a1 = a[left];\n                    }\n                    while (a1 < a[--k]) {\n                        a[k + 2] = a[k];\n                    }\n                    a[++k + 1] = a1;\n\n                    while (a2 < a[--k]) {\n                        a[k + 1] = a[k];\n                    }\n                    a[k + 1] = a2;\n                }\n                int last = a[right];\n\n                while (last < a[--right]) {\n                    a[right + 1] = a[right];\n                }\n                a[right + 1] = last;\n            }\n            return;\n        }\n\n        // 快速得到接近七等分的长度(1/8 + 1/64 = 9/64)的长度 + 1\n        int seventh = (length >> 3) + (length >> 6) + 1;\n        // 各个等分点\n        int e3 = (left + right) >>> 1; // The midpoint\n        int e2 = e3 - seventh;\n        int e1 = e2 - seventh;\n        int e4 = e3 + seventh;\n        int e5 = e4 + seventh;\n\n        // 用插入排序将这些点快速排好序\n        if (a[e2] < a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n\n        if (a[e3] < a[e2]) { int t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n            if (t < a[e1]) { a[e2] = a[e1]; a[e1] = t; }\n        }\n        if (a[e4] < a[e3]) { int t = a[e4]; a[e4] = a[e3]; a[e3] = t;\n            if (t < a[e2]) { a[e3] = a[e2]; a[e2] = t;\n                if (t < a[e1]) { a[e2] = a[e1]; a[e1] = t; }\n            }\n        }\n        if (a[e5] < a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t;\n            if (t < a[e3]) { a[e4] = a[e3]; a[e3] = t;\n                if (t < a[e2]) { a[e3] = a[e2]; a[e2] = t;\n                    if (t < a[e1]) { a[e2] = a[e1]; a[e1] = t; }\n                }\n            }\n        }\n\n        // Pointers\n        int less  = left;  // The index of the first element of center part\n        int great = right; // The index before the first element of right part\n\n        if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {\n            // 取第二和第四点为轴\n            int pivot1 = a[e2];\n            int pivot2 = a[e4];\n\n            a[e2] = a[left];\n            a[e4] = a[right];\n            \n            // 找到开始和结束向中间靠拢的合适下标\n            while (a[++less] < pivot1);\n            while (a[--great] > pivot2);\n            \n            // 双轴三切分排序\n            /*\n             *   left part           center part                   right part\n             * +--------------------------------------------------------------+\n             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |\n             * +--------------------------------------------------------------+\n             *               ^                          ^       ^\n             *               |                          |       |\n             *              less                        k     great\n             */\n            outer:\n            for (int k = less - 1; ++k <= great; ) {\n                int ak = a[k];\n                if (ak < pivot1) { // Move a[k] to left part\n                    a[k] = a[less];\n                    a[less] = ak;\n                    ++less;\n                } else if (ak > pivot2) { // Move a[k] to right part\n                    while (a[great] > pivot2) {\n                        if (great-- == k) {\n                            break outer;\n                        }\n                    }\n                    if (a[great] < pivot1) { // a[great] <= pivot2\n                        a[k] = a[less];\n                        a[less] = a[great];\n                        ++less;\n                    } else { // pivot1 <= a[great] <= pivot2\n                        a[k] = a[great];\n                    }\n                    a[great] = ak;\n                    --great;\n                }\n            }\n\n            // Swap pivots into their final positions\n            a[left]  = a[less  - 1]; a[less  - 1] = pivot1;\n            a[right] = a[great + 1]; a[great + 1] = pivot2;\n\n            // 前后切分，递归\n            sort(a, left, less - 2, leftmost);\n            sort(a, great + 2, right, false);\n\n            /* \n             * 如果中间长度大于 length 4/7 的长度\n             */\n            if (less < e1 && e5 < great) {\n                while (a[less] == pivot1) {\n                    ++less;\n                }\n\n                while (a[great] == pivot2) {\n                    --great;\n                }\n\n                /*\n                 *   left part         center part                  right part\n                 * +----------------------------------------------------------+\n                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |\n                 * +----------------------------------------------------------+\n                 *              ^                        ^       ^\n                 *             less                      k     great\n                 */\n                outer:\n                for (int k = less - 1; ++k <= great; ) {\n                    int ak = a[k];\n                    if (ak == pivot1) { // Move a[k] to left part\n                        a[k] = a[less];\n                        a[less] = ak;\n                        ++less;\n                    } else if (ak == pivot2) { // Move a[k] to right part\n                        while (a[great] == pivot2) {\n                            if (great-- == k) {\n                                break outer;\n                            }\n                        }\n                        if (a[great] == pivot1) { // a[great] < pivot2\n                            a[k] = a[less];\n                            a[less] = pivot1;\n                            ++less;\n                        } else { // pivot1 < a[great] < pivot2\n                            a[k] = a[great];\n                        }\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n            }\n\n            // 中间递归\n            sort(a, less, great, false);\n\n        } else { // 单轴快排\n            int pivot = a[e3];\n\n            /*\n             *   left part    center part              right part\n             * +-------------------------------------------------+\n             * |  < pivot  |   == pivot   |     ?    |  > pivot  |\n             * +-------------------------------------------------+\n             *              ^              ^        ^\n             *             less            k      great\n             */\n            for (int k = less; k <= great; ++k) {\n                if (a[k] == pivot) {\n                    continue;\n                }\n                int ak = a[k];\n                if (ak < pivot) { // Move a[k] to left part\n                    a[k] = a[less];\n                    a[less] = ak;\n                    ++less;\n                } else { // a[k] > pivot - Move a[k] to right part\n                    while (a[great] > pivot) {\n                        --great;\n                    }\n                    if (a[great] < pivot) { // a[great] <= pivot\n                        a[k] = a[less];\n                        a[less] = a[great];\n                        ++less;\n                    } else { // a[great] == pivot\n                        a[k] = pivot;\n                    }\n                    a[great] = ak;\n                    --great;\n                }\n            }\n\n            /*\n             * 双切分，递归\n             */\n            sort(a, left, less - 1, leftmost);\n            sort(a, great + 1, right, false);\n        }\n    }\n}\n````\n我承认需要要有点耐心才能看完，如果你认真看完并理解了，看别的代码那就是小菜一碟了 - -。\n### 总结一下\n1. 数据量小(n<47)：使用插入排序\n2. 数据量大(n>286)：且符合归并排序的指标(run<33,runs<67)就用归并\n3. 别的时候都是使用快排递归解决\n\n   \n    ","slug":"jdk的快速排序","published":1,"updated":"2019-08-18T07:36:49.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0hkxqiy0024ektvdrkcfdoq","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><img src=\"http://ww1.sinaimg.cn/large/006Cwrd9gy1fxskn2tpksj31hc0u0guq.jpg\" alt=\"I love it when a plan comes together.\"></p>\n<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p><strong>对各种基本排序有了解的人都会知道，各种单一的排序都有他自己合适的使用场景，而快速排序是这种单一排序里面综合表现最好的。<br>而实际应用中的排序可要考虑的情况实在是太多了，兴趣使然，我看了下jdk的快排，过程不多说看大佬究竟是怎么写的吧</strong></p>\n<blockquote>\n<p>java中的Arrays.Sort()方法是我们常用的排序方法，有心的人肯定点进去源码里面看过的，随着jdk的变化这个排序也有持续的变动，<br>说明维护的人还是很愿意花精力在这个方法上的，排序的算法代码对基本算法没有足够了解的人来说看起来还是很吃力的(我说的是以前的我)，<br>花了点时间整理下这个算法。在看这个之前最好是对各种基本的排序有一定的了解，这样才不至于一脸懵。</p>\n</blockquote>\n<h3 id=\"涉及的算法\"><a href=\"#涉及的算法\" class=\"headerlink\" title=\"涉及的算法\"></a>涉及的算法</h3><ol>\n<li>插入排序(之前1.7有用binary insertion,既二分法找到插入点后copy)</li>\n<li>归并排序</li>\n<li>快速排序<ul>\n<li>单轴(one pivot)双切分快排序(带等号),也就是荷兰国旗问题优化.</li>\n<li>双轴三切分快排</li>\n</ul>\n</li>\n<li>计数排序(用于数值范围小的情况，byte，short，char类型的时候)</li>\n<li>timSort(用于分析本身排序情况)</li>\n</ol>\n<h3 id=\"核心思路\"><a href=\"#核心思路\" class=\"headerlink\" title=\"核心思路\"></a>核心思路</h3><p>尽量发掘各自单一排序算法自己优势，当有合适条件的时候就使用对应的基本排序，并穿插一些实用的优化：</p>\n<ol>\n<li>小数据量：插入排序</li>\n<li>适中：快速排序<ul>\n<li>结合插入排序</li>\n<li>划分区间的时候，带等号使用单轴快排，否则双轴快排</li>\n<li>递归调用自己 </li>\n</ul>\n</li>\n<li>大量：先分用timSort分析数据本身排序状况，<ul>\n<li>衡量指标：run(单调区间的长度)和runs(单调区间的数目)</li>\n<li>满足对应的常量要求就用归并，否则就用快排(归并的次数太多就用快排，否则采用归并)</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"具体代码-jdk1-8对int-的排序\"><a href=\"#具体代码-jdk1-8对int-的排序\" class=\"headerlink\" title=\"具体代码:(jdk1.8对int[]的排序)\"></a>具体代码:(jdk1.8对int[]的排序)</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Sort</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 将给定区间数组排序，如果可以的话使用归并排序\n     */</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> right<span class=\"token punctuation\">,</span>\n                         <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> work<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> workBase<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> workLen<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 对于数据量少的直接使用快排</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>right <span class=\"token operator\">-</span> left <span class=\"token operator\">&lt;</span> QUICKSORT_THRESHOLD<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">// 286</span>\n                <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 基于插入，单双轴的快排见下面</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">/*  timSort分析数据排序情况， run[i]是第i个run的开始\n             *  一个run是一节单调区间(升序或者降序)\n             */</span>\n            <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> run <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>MAX_RUN_COUNT <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> run<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">;</span> run<span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// </span>\n                    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>k <span class=\"token operator\">&lt;=</span> right <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>k <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> a<span class=\"token punctuation\">[</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 降序</span>\n                    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>k <span class=\"token operator\">&lt;=</span> right <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>k <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> lo <span class=\"token operator\">=</span> run<span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> hi <span class=\"token operator\">=</span> k<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>lo <span class=\"token operator\">&lt;</span> <span class=\"token operator\">--</span>hi<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">int</span> t <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>lo<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>hi<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 相等</span>\n                    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> MAX_RUN_LENGTH<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>k <span class=\"token operator\">&lt;=</span> right <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>k <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">--</span>m <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 等号多了直接将这里短丢到快排里面</span>\n                            <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n\n                <span class=\"token comment\" spellcheck=\"true\">/* 如果数组不是高度结构化用快排代替归并(要合并的次数count太多了)\n                 */</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>count <span class=\"token operator\">==</span> MAX_RUN_COUNT<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">// 目前MAX_RUN_COUNT = 67</span>\n                    <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 基于插入，单双轴的快排见下面</span>\n                    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 下面是基于O(n)辅助空间的非递归归并，贴进来总体太长</span>\n            <span class=\"token comment\" spellcheck=\"true\">// ...... 归并</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 结束</span>\n        <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>下面是<strong>核心快排</strong>(有点长)我梳理下：</p>\n<ol>\n<li>小范围的用插入排序结束对应区间的排序，跳过</li>\n<li>切分数组成6个区间（不是等分），中间有五个点，把这五个点排好序</li>\n<li>判断这五个点有没有相等的<ul>\n<li>有：双轴三切分<ul>\n<li>前后部分直接递归（转到第一步）</li>\n<li>如果中间的切分比较大的话，对他进行瘦身(把那些等于头尾的去掉后)再递归（转到第一步）</li>\n</ul>\n</li>\n<li>没有：单轴双切分，排除中间相等的点切分，后从方法开头递归（转到第一步）</li>\n</ul>\n</li>\n</ol>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Sort</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * Sorts the specified range of the array by Dual-Pivot Quicksort.\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> right<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> leftmost<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> length <span class=\"token operator\">=</span> right <span class=\"token operator\">-</span> left <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 使用插入排序</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>length <span class=\"token operator\">&lt;</span> INSERTION_SORT_THRESHOLD<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// INSERTION_SORT_THRESHOLD = 47</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 左边是否是最大</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>leftmost<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 普通的插入排序</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> left<span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">;</span> j <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">int</span> ai <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>ai <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        a<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>j<span class=\"token operator\">--</span> <span class=\"token operator\">==</span> left<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span>\n                    a<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> ai<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">/*\n                 * 跳过最长升序\n                 */</span>\n                <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">>=</span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> a<span class=\"token punctuation\">[</span>left <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token comment\" spellcheck=\"true\">/*\n                 * 这里也不是普通的的插入排序，\n                 * 使用的是双元素插入法更优。\n                 */</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>left <span class=\"token operator\">&lt;=</span> right<span class=\"token punctuation\">;</span> k <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>left<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">int</span> a1 <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> a2 <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a1 <span class=\"token operator\">&lt;</span> a2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        a2 <span class=\"token operator\">=</span> a1<span class=\"token punctuation\">;</span> a1 <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>a1 <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        a<span class=\"token punctuation\">[</span>k <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    a<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a1<span class=\"token punctuation\">;</span>\n\n                    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>a2 <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        a<span class=\"token punctuation\">[</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    a<span class=\"token punctuation\">[</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a2<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">int</span> last <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>last <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    a<span class=\"token punctuation\">[</span>right <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                a<span class=\"token punctuation\">[</span>right <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> last<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 快速得到接近七等分的长度(1/8 + 1/64 = 9/64)的长度 + 1</span>\n        <span class=\"token keyword\">int</span> seventh <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>length <span class=\"token operator\">>></span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>length <span class=\"token operator\">>></span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 各个等分点</span>\n        <span class=\"token keyword\">int</span> e3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">+</span> right<span class=\"token punctuation\">)</span> <span class=\"token operator\">>>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// The midpoint</span>\n        <span class=\"token keyword\">int</span> e2 <span class=\"token operator\">=</span> e3 <span class=\"token operator\">-</span> seventh<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> e1 <span class=\"token operator\">=</span> e2 <span class=\"token operator\">-</span> seventh<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> e4 <span class=\"token operator\">=</span> e3 <span class=\"token operator\">+</span> seventh<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> e5 <span class=\"token operator\">=</span> e4 <span class=\"token operator\">+</span> seventh<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 用插入排序将这些点快速排好序</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>e1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">int</span> t <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>e1<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>e3<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">int</span> t <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e3<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>e3<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>e1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>e1<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>e4<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>e3<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">int</span> t <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e4<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>e4<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e3<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>e3<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">[</span>e3<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>e1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>e1<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>e5<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>e4<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">int</span> t <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e5<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>e5<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e4<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>e4<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>e3<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">[</span>e4<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e3<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>e3<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">[</span>e3<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>e1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>e1<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// Pointers</span>\n        <span class=\"token keyword\">int</span> less  <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// The index of the first element of center part</span>\n        <span class=\"token keyword\">int</span> great <span class=\"token operator\">=</span> right<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// The index before the first element of right part</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>e1<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> a<span class=\"token punctuation\">[</span>e3<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>e3<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> a<span class=\"token punctuation\">[</span>e4<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>e4<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> a<span class=\"token punctuation\">[</span>e5<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 取第二和第四点为轴</span>\n            <span class=\"token keyword\">int</span> pivot1 <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> pivot2 <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e4<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n            a<span class=\"token punctuation\">[</span>e2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            a<span class=\"token punctuation\">[</span>e4<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 找到开始和结束向中间靠拢的合适下标</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span><span class=\"token operator\">++</span>less<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> pivot1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>great<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> pivot2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 双轴三切分排序</span>\n            <span class=\"token comment\" spellcheck=\"true\">/*\n             *   left part           center part                   right part\n             * +--------------------------------------------------------------+\n             * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  > pivot2  |\n             * +--------------------------------------------------------------+\n             *               ^                          ^       ^\n             *               |                          |       |\n             *              less                        k     great\n             */</span>\n            outer<span class=\"token operator\">:</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> less <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>k <span class=\"token operator\">&lt;=</span> great<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> ak <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ak <span class=\"token operator\">&lt;</span> pivot1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// Move a[k] to left part</span>\n                    a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>less<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    a<span class=\"token punctuation\">[</span>less<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> ak<span class=\"token punctuation\">;</span>\n                    <span class=\"token operator\">++</span>less<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ak <span class=\"token operator\">></span> pivot2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// Move a[k] to right part</span>\n                    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>great<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> pivot2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>great<span class=\"token operator\">--</span> <span class=\"token operator\">==</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            <span class=\"token keyword\">break</span> outer<span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>great<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> pivot1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// a[great] &lt;= pivot2</span>\n                        a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>less<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                        a<span class=\"token punctuation\">[</span>less<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>great<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token operator\">++</span>less<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// pivot1 &lt;= a[great] &lt;= pivot2</span>\n                        a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>great<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    a<span class=\"token punctuation\">[</span>great<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> ak<span class=\"token punctuation\">;</span>\n                    <span class=\"token operator\">--</span>great<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// Swap pivots into their final positions</span>\n            a<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span>  <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>less  <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>less  <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> pivot1<span class=\"token punctuation\">;</span>\n            a<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>great <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> a<span class=\"token punctuation\">[</span>great <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> pivot2<span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 前后切分，递归</span>\n            <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> less <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> leftmost<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> great <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">/* \n             * 如果中间长度大于 length 4/7 的长度\n             */</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>less <span class=\"token operator\">&lt;</span> e1 <span class=\"token operator\">&amp;&amp;</span> e5 <span class=\"token operator\">&lt;</span> great<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>less<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> pivot1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token operator\">++</span>less<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n\n                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>great<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> pivot2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token operator\">--</span>great<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n\n                <span class=\"token comment\" spellcheck=\"true\">/*\n                 *   left part         center part                  right part\n                 * +----------------------------------------------------------+\n                 * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |\n                 * +----------------------------------------------------------+\n                 *              ^                        ^       ^\n                 *             less                      k     great\n                 */</span>\n                outer<span class=\"token operator\">:</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> less <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>k <span class=\"token operator\">&lt;=</span> great<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">int</span> ak <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ak <span class=\"token operator\">==</span> pivot1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// Move a[k] to left part</span>\n                        a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>less<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                        a<span class=\"token punctuation\">[</span>less<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> ak<span class=\"token punctuation\">;</span>\n                        <span class=\"token operator\">++</span>less<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ak <span class=\"token operator\">==</span> pivot2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// Move a[k] to right part</span>\n                        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>great<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> pivot2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>great<span class=\"token operator\">--</span> <span class=\"token operator\">==</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                <span class=\"token keyword\">break</span> outer<span class=\"token punctuation\">;</span>\n                            <span class=\"token punctuation\">}</span>\n                        <span class=\"token punctuation\">}</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>great<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> pivot1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// a[great] &lt; pivot2</span>\n                            a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>less<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                            a<span class=\"token punctuation\">[</span>less<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> pivot1<span class=\"token punctuation\">;</span>\n                            <span class=\"token operator\">++</span>less<span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// pivot1 &lt; a[great] &lt; pivot2</span>\n                            a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>great<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span>\n                        a<span class=\"token punctuation\">[</span>great<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> ak<span class=\"token punctuation\">;</span>\n                        <span class=\"token operator\">--</span>great<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 中间递归</span>\n            <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> less<span class=\"token punctuation\">,</span> great<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 单轴快排</span>\n            <span class=\"token keyword\">int</span> pivot <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>e3<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">/*\n             *   left part    center part              right part\n             * +-------------------------------------------------+\n             * |  &lt; pivot  |   == pivot   |     ?    |  > pivot  |\n             * +-------------------------------------------------+\n             *              ^              ^        ^\n             *             less            k      great\n             */</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> less<span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;=</span> great<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> pivot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">int</span> ak <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ak <span class=\"token operator\">&lt;</span> pivot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// Move a[k] to left part</span>\n                    a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>less<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    a<span class=\"token punctuation\">[</span>less<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> ak<span class=\"token punctuation\">;</span>\n                    <span class=\"token operator\">++</span>less<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// a[k] > pivot - Move a[k] to right part</span>\n                    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>great<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> pivot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token operator\">--</span>great<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>great<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> pivot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// a[great] &lt;= pivot</span>\n                        a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>less<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                        a<span class=\"token punctuation\">[</span>less<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>great<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token operator\">++</span>less<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// a[great] == pivot</span>\n                        a<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> pivot<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    a<span class=\"token punctuation\">[</span>great<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> ak<span class=\"token punctuation\">;</span>\n                    <span class=\"token operator\">--</span>great<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">/*\n             * 双切分，递归\n             */</span>\n            <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> less <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> leftmost<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> great <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>我承认需要要有点耐心才能看完，如果你认真看完并理解了，看别的代码那就是小菜一碟了 - -。</p>\n<h3 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h3><ol>\n<li>数据量小(n&lt;47)：使用插入排序</li>\n<li>数据量大(n&gt;286)：且符合归并排序的指标(run&lt;33,runs&lt;67)就用归并</li>\n<li>别的时候都是使用快排递归解决</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<p><img src=\"http://ww1.sinaimg.cn/large/006Cwrd9gy1fxskn2tpksj31hc0u0guq.jpg\" alt=\"I love it when a plan comes together.\"></p>\n<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p><strong>对各种基本排序有了解的人都会知道，各种单一的排序都有他自己合适的使用场景，而快速排序是这种单一排序里面综合表现最好的。<br>而实际应用中的排序可要考虑的情况实在是太多了，兴趣使然，我看了下jdk的快排，过程不多说看大佬究竟是怎么写的吧</strong></p>\n<blockquote>\n<p>java中的Arrays.Sort()方法是我们常用的排序方法，有心的人肯定点进去源码里面看过的，随着jdk的变化这个排序也有持续的变动，<br>说明维护的人还是很愿意花精力在这个方法上的，排序的算法代码对基本算法没有足够了解的人来说看起来还是很吃力的(我说的是以前的我)，<br>花了点时间整理下这个算法。在看这个之前最好是对各种基本的排序有一定的了解，这样才不至于一脸懵。</p>\n</blockquote>\n<h3 id=\"涉及的算法\"><a href=\"#涉及的算法\" class=\"headerlink\" title=\"涉及的算法\"></a>涉及的算法</h3><ol>\n<li>插入排序(之前1.7有用binary insertion,既二分法找到插入点后copy)</li>\n<li>归并排序</li>\n<li>快速排序<ul>\n<li>单轴(one pivot)双切分快排序(带等号),也就是荷兰国旗问题优化.</li>\n<li>双轴三切分快排</li>\n</ul>\n</li>\n<li>计数排序(用于数值范围小的情况，byte，short，char类型的时候)</li>\n<li>timSort(用于分析本身排序情况)</li>\n</ol>\n<h3 id=\"核心思路\"><a href=\"#核心思路\" class=\"headerlink\" title=\"核心思路\"></a>核心思路</h3><p>尽量发掘各自单一排序算法自己优势，当有合适条件的时候就使用对应的基本排序，并穿插一些实用的优化：</p>\n<ol>\n<li>小数据量：插入排序</li>\n<li>适中：快速排序<ul>\n<li>结合插入排序</li>\n<li>划分区间的时候，带等号使用单轴快排，否则双轴快排</li>\n<li>递归调用自己 </li>\n</ul>\n</li>\n<li>大量：先分用timSort分析数据本身排序状况，<ul>\n<li>衡量指标：run(单调区间的长度)和runs(单调区间的数目)</li>\n<li>满足对应的常量要求就用归并，否则就用快排(归并的次数太多就用快排，否则采用归并)</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"具体代码-jdk1-8对int-的排序\"><a href=\"#具体代码-jdk1-8对int-的排序\" class=\"headerlink\" title=\"具体代码:(jdk1.8对int[]的排序)\"></a>具体代码:(jdk1.8对int[]的排序)</h3><pre><code class=\"java\">class Sort {\n    /**\n     * 将给定区间数组排序，如果可以的话使用归并排序\n     */\n    static void sort(int[] a, int left, int right,\n                         int[] work, int workBase, int workLen) {\n            // 对于数据量少的直接使用快排\n            if (right - left &lt; QUICKSORT_THRESHOLD) {// 286\n                sort(a, left, right, true); // 基于插入，单双轴的快排见下面\n                return;\n            }\n\n            /*  timSort分析数据排序情况， run[i]是第i个run的开始\n             *  一个run是一节单调区间(升序或者降序)\n             */\n            int[] run = new int[MAX_RUN_COUNT + 1];\n            int count = 0; run[0] = left;\n\n            for (int k = left; k &lt; right; run[count] = k) {\n                if (a[k] &lt; a[k + 1]) { // \n                    while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);\n                } else if (a[k] &gt; a[k + 1]) { // 降序\n                    while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);\n                    for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {\n                        int t = a[lo]; a[lo] = a[hi]; a[hi] = t;\n                    }\n                } else { // 相等\n                    for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) {\n                        if (--m == 0) { // 等号多了直接将这里短丢到快排里面\n                            sort(a, left, right, true);\n                            return;\n                        }\n                    }\n                }\n\n                /* 如果数组不是高度结构化用快排代替归并(要合并的次数count太多了)\n                 */\n                if (++count == MAX_RUN_COUNT) {// 目前MAX_RUN_COUNT = 67\n                    sort(a, left, right, true); // 基于插入，单双轴的快排见下面\n                    return;\n                }\n            }\n\n            // 下面是基于O(n)辅助空间的非递归归并，贴进来总体太长\n            // ...... 归并\n            // 结束\n        }\n}\n</code></pre>\n<p>下面是<strong>核心快排</strong>(有点长)我梳理下：</p>\n<ol>\n<li>小范围的用插入排序结束对应区间的排序，跳过</li>\n<li>切分数组成6个区间（不是等分），中间有五个点，把这五个点排好序</li>\n<li>判断这五个点有没有相等的<ul>\n<li>有：双轴三切分<ul>\n<li>前后部分直接递归（转到第一步）</li>\n<li>如果中间的切分比较大的话，对他进行瘦身(把那些等于头尾的去掉后)再递归（转到第一步）</li>\n</ul>\n</li>\n<li>没有：单轴双切分，排除中间相等的点切分，后从方法开头递归（转到第一步）</li>\n</ul>\n</li>\n</ol>\n<pre><code class=\"java\">class Sort{\n    /**\n     * Sorts the specified range of the array by Dual-Pivot Quicksort.\n     */\n    private static void sort(int[] a, int left, int right, boolean leftmost) {\n        int length = right - left + 1;\n\n        // 使用插入排序\n        if (length &lt; INSERTION_SORT_THRESHOLD) { // INSERTION_SORT_THRESHOLD = 47\n            // 左边是否是最大\n            if (leftmost) {\n                // 普通的插入排序\n                for (int i = left, j = i; i &lt; right; j = ++i) {\n                    int ai = a[i + 1];\n                    while (ai &lt; a[j]) {\n                        a[j + 1] = a[j];\n                        if (j-- == left) {\n                            break;\n                        }\n                    }\n                    a[j + 1] = ai;\n                }\n            } else {\n                /*\n                 * 跳过最长升序\n                 */\n                do {\n                    if (left &gt;= right) {\n                        return;\n                    }\n                } while (a[++left] &gt;= a[left - 1]);\n\n                /*\n                 * 这里也不是普通的的插入排序，\n                 * 使用的是双元素插入法更优。\n                 */\n                for (int k = left; ++left &lt;= right; k = ++left) {\n                    int a1 = a[k], a2 = a[left];\n\n                    if (a1 &lt; a2) {\n                        a2 = a1; a1 = a[left];\n                    }\n                    while (a1 &lt; a[--k]) {\n                        a[k + 2] = a[k];\n                    }\n                    a[++k + 1] = a1;\n\n                    while (a2 &lt; a[--k]) {\n                        a[k + 1] = a[k];\n                    }\n                    a[k + 1] = a2;\n                }\n                int last = a[right];\n\n                while (last &lt; a[--right]) {\n                    a[right + 1] = a[right];\n                }\n                a[right + 1] = last;\n            }\n            return;\n        }\n\n        // 快速得到接近七等分的长度(1/8 + 1/64 = 9/64)的长度 + 1\n        int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;\n        // 各个等分点\n        int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint\n        int e2 = e3 - seventh;\n        int e1 = e2 - seventh;\n        int e4 = e3 + seventh;\n        int e5 = e4 + seventh;\n\n        // 用插入排序将这些点快速排好序\n        if (a[e2] &lt; a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n\n        if (a[e3] &lt; a[e2]) { int t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n            if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }\n        }\n        if (a[e4] &lt; a[e3]) { int t = a[e4]; a[e4] = a[e3]; a[e3] = t;\n            if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;\n                if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }\n            }\n        }\n        if (a[e5] &lt; a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t;\n            if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;\n                if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;\n                    if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }\n                }\n            }\n        }\n\n        // Pointers\n        int less  = left;  // The index of the first element of center part\n        int great = right; // The index before the first element of right part\n\n        if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {\n            // 取第二和第四点为轴\n            int pivot1 = a[e2];\n            int pivot2 = a[e4];\n\n            a[e2] = a[left];\n            a[e4] = a[right];\n\n            // 找到开始和结束向中间靠拢的合适下标\n            while (a[++less] &lt; pivot1);\n            while (a[--great] &gt; pivot2);\n\n            // 双轴三切分排序\n            /*\n             *   left part           center part                   right part\n             * +--------------------------------------------------------------+\n             * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |\n             * +--------------------------------------------------------------+\n             *               ^                          ^       ^\n             *               |                          |       |\n             *              less                        k     great\n             */\n            outer:\n            for (int k = less - 1; ++k &lt;= great; ) {\n                int ak = a[k];\n                if (ak &lt; pivot1) { // Move a[k] to left part\n                    a[k] = a[less];\n                    a[less] = ak;\n                    ++less;\n                } else if (ak &gt; pivot2) { // Move a[k] to right part\n                    while (a[great] &gt; pivot2) {\n                        if (great-- == k) {\n                            break outer;\n                        }\n                    }\n                    if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2\n                        a[k] = a[less];\n                        a[less] = a[great];\n                        ++less;\n                    } else { // pivot1 &lt;= a[great] &lt;= pivot2\n                        a[k] = a[great];\n                    }\n                    a[great] = ak;\n                    --great;\n                }\n            }\n\n            // Swap pivots into their final positions\n            a[left]  = a[less  - 1]; a[less  - 1] = pivot1;\n            a[right] = a[great + 1]; a[great + 1] = pivot2;\n\n            // 前后切分，递归\n            sort(a, left, less - 2, leftmost);\n            sort(a, great + 2, right, false);\n\n            /* \n             * 如果中间长度大于 length 4/7 的长度\n             */\n            if (less &lt; e1 &amp;&amp; e5 &lt; great) {\n                while (a[less] == pivot1) {\n                    ++less;\n                }\n\n                while (a[great] == pivot2) {\n                    --great;\n                }\n\n                /*\n                 *   left part         center part                  right part\n                 * +----------------------------------------------------------+\n                 * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |\n                 * +----------------------------------------------------------+\n                 *              ^                        ^       ^\n                 *             less                      k     great\n                 */\n                outer:\n                for (int k = less - 1; ++k &lt;= great; ) {\n                    int ak = a[k];\n                    if (ak == pivot1) { // Move a[k] to left part\n                        a[k] = a[less];\n                        a[less] = ak;\n                        ++less;\n                    } else if (ak == pivot2) { // Move a[k] to right part\n                        while (a[great] == pivot2) {\n                            if (great-- == k) {\n                                break outer;\n                            }\n                        }\n                        if (a[great] == pivot1) { // a[great] &lt; pivot2\n                            a[k] = a[less];\n                            a[less] = pivot1;\n                            ++less;\n                        } else { // pivot1 &lt; a[great] &lt; pivot2\n                            a[k] = a[great];\n                        }\n                        a[great] = ak;\n                        --great;\n                    }\n                }\n            }\n\n            // 中间递归\n            sort(a, less, great, false);\n\n        } else { // 单轴快排\n            int pivot = a[e3];\n\n            /*\n             *   left part    center part              right part\n             * +-------------------------------------------------+\n             * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |\n             * +-------------------------------------------------+\n             *              ^              ^        ^\n             *             less            k      great\n             */\n            for (int k = less; k &lt;= great; ++k) {\n                if (a[k] == pivot) {\n                    continue;\n                }\n                int ak = a[k];\n                if (ak &lt; pivot) { // Move a[k] to left part\n                    a[k] = a[less];\n                    a[less] = ak;\n                    ++less;\n                } else { // a[k] &gt; pivot - Move a[k] to right part\n                    while (a[great] &gt; pivot) {\n                        --great;\n                    }\n                    if (a[great] &lt; pivot) { // a[great] &lt;= pivot\n                        a[k] = a[less];\n                        a[less] = a[great];\n                        ++less;\n                    } else { // a[great] == pivot\n                        a[k] = pivot;\n                    }\n                    a[great] = ak;\n                    --great;\n                }\n            }\n\n            /*\n             * 双切分，递归\n             */\n            sort(a, left, less - 1, leftmost);\n            sort(a, great + 1, right, false);\n        }\n    }\n}\n</code></pre>\n<p>我承认需要要有点耐心才能看完，如果你认真看完并理解了，看别的代码那就是小菜一碟了 - -。</p>\n<h3 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h3><ol>\n<li>数据量小(n&lt;47)：使用插入排序</li>\n<li>数据量大(n&gt;286)：且符合归并排序的指标(run&lt;33,runs&lt;67)就用归并</li>\n<li>别的时候都是使用快排递归解决</li>\n</ol>\n"},{"title":"读 Designing Data-Intensive Application","date":"2019-02-13T08:57:48.000Z","_content":"\n## 前言\n> 拜读大佬的书籍，把重点的语句做个笔记。\n---\n书本内容：\n## 序言\n>1. 近些年的软件工程，特别是服务器端和后端系统开发，大量关于数据存储和处理的时髦词汇涌现出来： **NoSQL！大数据！Web-Scale！分片！最终一致性！\nACID！ CAP定理！云服务！MapReduce！实时！**\n2. 而**数据密集型应用**（data-intensive applications）正在通过使用这些技术进步来推动可能性的边界。当一个应用被称为**数据密集**型的引用，\n如果数据是其主要挑战（数据量，数据复杂度或数据变化速度）—— 与之相对的是**计算密集型**，即**处理器速度**是其瓶颈。\n3. 在技术迅速变化的背后总是存在一些持续成立的原则，无论我们使用了特定工具的哪个版本。如果理解了这些原则，就可以领会这些工具的适用场景，如何充分\n利用它们，以及如何避免其中的陷阱.\n## 第一部分：数据系统的基石\n1. 第一章将介绍本书使用的术语和方法。可靠性，可扩展性和可维护性 ，这些词汇到底意味着什么？如何实现这些目标？\n2. 第二章将对几种不同的数据模型和查询语言进行比较。从程序员的角度看，这是数据库之间最明显的区别。不同的数据模型适用于不同的应用场景。\n3. 第三章将深入存储引擎内部，研究数据库如何在磁盘上摆放数据。不同的存储引擎针对不同的负载进行优化，选择合适的存储引擎对系统性能有巨大影响。\n4. 第四章将对几种不同的 数据编码进行比较。特别研究了这些格式在应用需求经常变化、模式需要随时间演变的环境中表现如何。\n\n### 第一章：可靠性可，扩展性，可维护性\n- 现今很多应用程序都是 **数据密集型（data-intensive）** 的，而非 **计算密集型（compute-intensive）** 的。因此CPU很少成为这类应用的瓶颈，\n更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。一旦系统的负载被描述好，就可以研究当负载增加会发生什么。我们可以从两种角度来看：  \n    - 增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？\n    - 增加负载参数并希望保持性能不变时，需要增加多少系统资源？\n这两个问题都需要性能数据，所以让我们简单地看一下如何描述系统性能。\n​对于Hadoop这样的**批处理系统**，通常关心的是**吞吐量**（throughput），即每秒可以处理的记录数量，或者在特定规模数据集上运行作业的总时间。\n对于在线系统，通常更重要的是服务的**响应时间**（response time），即客户端发送请求到接收响应之间的时间。\n使不断重复发送同样的请求，每次得到的响应时间也都会略有不同。现实世界的系统会处理各式各样的请求，响应时间可能会有很大差异。因此我们需要将\n**响应时间**视为一个可以测量的**数值分布**（distribution），**而不是单个数值**\n\n### 第二章：数据模型与查询语言\n- 数据模型主要分为两种：**关系模型**(sql,典型的如mysql,oracle)与**文档模型**(noSql[Not Only SQL],典型的如mongo) \n- 采用NoSQL数据库的背后有几个驱动因素，其中包括：\n  - 需要比关系数据库更好的可扩展性，包括非常大的数据集或非常高的写入吞吐量\n  - 相比商业数据库产品，免费和开源软件更受偏爱。\n  - 关系模型不能很好地支持一些特殊的查询操作\n  - 受挫于关系模型的限制性，渴望一种更具多动态性与表现力的数据模型\n- 文档和关系数据库的融合:自2000年代中期以来，大多数关系数据库都已经开始支持文档结构：如json，xml格式的数据\n- 随着时间的推移，关系数据库和文档数据库似乎变得越来越相似，这是一件好事：数据模型相互补充 ，如果一个数据库能够处理类似文档的数据，\n并能够对其执行关系查询，那么应用程序就可以使用最符合其需求的功能组合。\n- 关系模型和文档模型的混合是未来数据库一条很好的路线。\n\n- 文档数据库有时称为无模式（schemaless），但这具有误导性，因为读取数据的代码通常假定某种结构——即存在隐式模式，但不由数据库强制执行。\n一个更精确的术语是读时模式（schema-on-read）（数据的结构是隐含的，只有在数据被读取时才被解释），相应的是写时模式（schema-on-write）\n（传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式）\n-  模式变更的速度很慢，而且要求停运。它的这种坏名誉并不是完全应得的：大多数关系数据库系统可在几毫秒内执行 ALTER TABLE  语句。\nMySQL是一个值得注意的例外，它执行 ALTER TABLE  时会复制整个表，这**可能意味着在更改一个大型表时会花费几分钟甚至几个小时的停机\n时间，尽管存在各种工具来解决这个限制**。\n- 大型表上运行 UPDATE 语句在任何数据库上都可能会很慢，因为每一行都需要重写。要是不可接受的话，应用程序可以将 first_name  设置为默认值 NULL\n  ，并在读取时再填充，就像使用文档数据库一样。\n> SQL是一种声明式查询语言，而IMS和CODASYL使用命令式代码来查询数据库。那是什么意思？许多常用的编程语言是命令式的。例如，给定一个动物物种的列表，\n返回列表中的鲨鱼可以这样写：\nfunction getSharks() {\nvar sharks = [];\nfor (var i = 0; i < animals.length; i++) {\nif (animals[i].family === \"Sharks\") {\nsharks.push(animals[i]);\n}\n}\nreturn sharks;\n}\n命令式语言告诉计算机以特定顺序执行某些操作。可以想象一下，逐行地遍历代码，评估条 件，更新变量，并决定是否再循环一遍。\n在声明式查询语言（如SQL或关系代数）中，你只需指定所需数据的模式 - 结果必须符合哪些 条件，以及如何将数据转换（例如，排序，分组和集合）\n但不是如何实现这一目标。数据库 系统的查询优化器决定使用哪些索引和哪些连接方法，以及以何种顺序执行查询的各个部分。\n\n- 声明式查询语言是迷人的，因为它通常比命令式API更加简洁和容易。但更重要的是，它还隐\n藏了数据库引擎的实现细节，这使得数据库系统可以在无需对查询做任何更改的情况下进行\n性能提升。  \n\n- 最后，声明式语言往往适合并行执行。现在，CPU的速度通过内核的增加变得更快，而不是\n以比以前更高的时钟速度运行【31】。命令代码很难在多个内核和多个机器之间并行化，因\n为它指定了指令必须以特定顺序执行。声明式语言更具有并行执行的潜力，因为它们仅指定\n结果的模式，而不指定用于确定结果的算法。在适当情况下，数据库可以自由使用查询语言\n的并行实现\n\n- 我们会研究两大类存储引擎：日志结构（log-structured）的存储引擎，以及面向页面（page-oriented）的存储引擎（例如B树）。\n- 冻结段的合并和压缩可以在后台线程中完成，在进行时，我们仍然可以继续使用旧的段文件来正常提供读写请求。合并过程完成后，我们将读取请求转换为\n使用新的合并段 而不是旧段然后可以简单地删除旧的段文件。\n- **简而言之，一些真正实施中重要的问题是:**\n  - **文件格式**:\n  - **删除记录**:\n  - **崩溃恢复**:\n  - **部分写入记录**:\n  - **并发控制**: 乍一看，只有追加日志看起来很浪费：为什么不更新文件，用新值覆盖旧值？但是只能追加设计的原因有几个:\n    - 追加和分段合并是顺序写入操作，通常比随机写入快得多，尤其是在磁盘旋转硬盘上。\n    - 在某种程度上，顺序写入在基于闪存的固态硬盘（SSD）上也是优选的【4】。我们将在\n    - 第83页的“比较B-树和LSM-树”中进一步讨论这个问题。\n    - 如果段文件是附加的或不可变的，并发和崩溃恢复就简单多了。例如，您不必担心在覆\n    - 盖值时发生崩溃的情况，而将包含旧值和新值的一部分的文件保留在一起。\n    - 合并旧段可以避免数据文件随着时间的推移而分散的问题。  \n- 与往常一样，大量的细节使得存储引擎在实践中表现良好。例如，当查找数据库中**不存在的键**时，LSM树算法可能会很慢：您必须检查内存表，然后将这些段一\n直回到最老的（这可能必须从磁盘读取每一个），然后才能确定键不存在。为了优化这种访问，存储引擎通常使用额外的Bloom过滤器\n- 布隆过滤器是用于近似集合内容的内存高效数据结构，它可以告诉您数据库中是否出现键，从而为不存在的键节省许多不必要的磁盘读取操作。\n  (布隆过滤有这样的特性：没有那就一定是没有，有，有百分之95%以上的几率是有的，用很小的错误率，和很小的空间获得特别大的效率)\n-  即使有许多微妙的东西，LSM树的基本思想 —— 保存一系列在后台合并的SSTables —— 简 单而有效。即使数据集比可用内存大得多，它仍能继续正常工作。\n由于数据按排序顺序存储， 因此可以高效地执行范围查询（扫描所有高于某些最小值和最高值的所有键），并且因 为磁盘写入是连续的，所以LSM树可以支持\n非常高的写入吞吐量。\n- 在B树的一个页面中对子页面的引用的数量称为分支因子。例如，在图3-6中，分支因子是 6 。在实践中，分支因子取决于存储页面参考和范围边界所需的空间量，\n但通常是几百个。\n- 日志结构化的方法在这方面更简单，因为它们在后台进行所有的合并，而不会干扰传入的查询，并且不时地将旧的分段原子交换为新的分段。\n- 这种差异在磁性硬盘驱动器上尤其重要，顺序写入比随机写入快得多。\n- 在许多关系数据库中，事务隔离是通过在键范围上使用锁来实现的，在B树索引中，这些锁可以直接连接到树\n- 在新的数据存储中，**日志结构化索引**变得越来越流行。没有快速和容易的规则来确定哪种类型的存储引擎对你的场景更好，所以值得进行一些经验上的测试.\n- 索引中的关键字是查询搜索的内容，但是该值可以是以下两种情况之一：它可以是所讨论的实际行（文档，顶点），也可以是对存储在别处的行的引用。在后一种\n情况下，行被存储的 地方被称为堆文件（heap file），并且存储的数据没有特定的顺序（它可以是仅附加的，或 者可以跟踪被删除的行以便用新数据覆盖它们后来）\n- 在聚集索引（在索引中存储所有行数据）和非聚集索引（仅在索引中存储对数据的引用）之间的折衷被称为包含列的索引或覆盖索引，其存储表的一部分在索引内。\n这允许通过单独使用索引来回答一些查询（这种情况叫做：索引覆盖（cover）了查询）\n- 某些内存中的键值存储（如Memcached）仅用于缓存，在重新启动计算机时丢失的数据是可 以接受的。但其他内存数据库的目标是持久性，可以通过特殊的硬件\n（例如电池供电的 RAM），将更改日志写入磁盘，将定时快照写入磁盘或通过复制内存来实现，记忆状态到其他机器。\n>诸如VoltDB，MemSQL和Oracle TimesTen等产品是具有关系模型的内存数据库，供应商声称，通过消除与管理磁盘上的数据结构相关的所有开销，\n他们可以提供巨大的性能改进【41,42】。 RAM Cloud是一个开源的内存键值存储器，具有持久性（对存储器中的数据以及磁盘上的数据使用日志结构化方法）\n【43】。 Redis和Couchbase通过异步写入磁盘提供了较弱的持久性。\n \n>磁盘的顺序读速度能打到在100MB/S上下使用列式存储，分析的时候，可以只扫描需要的那部分数据的时候，减少CPU和磁盘的访问量。同时面向列的存储通常\n很适合压缩，使用压缩，可以综合CPU和磁盘，发挥最大的效能。\n>面向行的存储将每一行保存在一个地方（在堆文件或聚簇索引中）\n> 在OLTP方面，我们看到了来自两大主流学派的存储引擎： 日志结构学派\n> 只允许附加到文件和删除过时的文件，但不会更新已经写入的文件。 Bitcask，SSTables，LSM树，LevelDB，Cassandra，HBase，Lucene等都属于这个组。 \n原地更新学派将磁盘视为一组可以覆盖的固定大小的页面。 B树是这种哲学的最大的例子，被用在所有主要的关系数据库中，还有许多非关系数据库。\n \n### 第三章：存储与检索\n> 日志结构的存储引擎是相对较新的发展。他们的主要想法是，他们系统地将随机访问写入顺\n> 序写入磁盘，由于硬盘驱动器和固态硬盘的性能特点，可以实现更高的写入吞吐量。在完成\n> OLTP方面，我们通过一些更复杂的索引结构和为保留所有数据而优化的数据库做了一个简短\n> 的介绍。 然后，我们从存储引擎的内部绕开，看看典型数据仓库的高级架构。这一背景说明了为什么\n> 分析工作负载与OLTP差别很大：当您的查询需要在大量行中顺序扫描时，索引的相关性就会\n> 降低很多。相反，非常紧凑地编码数据变得非常重要，以最大限度地减少查询需要从磁盘读\n> 取的数据量。我们讨论了列式存储如何帮助实现这一目标。\n> 作为一名应用程序开发人员，如果您掌握了有关存储引擎内部的知识，那么您就能更好地了\n> 解哪种工具最适合您的特定应用程序。 如果您需要调整数据库的调整参数，这种理解可以让\n> 您设想一个更高或更低的值可能会产生什么效果。\n> 尽管本章不能让你成为一个特定存储引擎的调参专家，但它至少有大概率使你有了足够的概\n> 念与词汇储备去读懂数据库的文档，从而选择合适的数据库。\n\n>\n- 作为程序员，为什么要关心数据库内部存储与检索的机理？你可能不会去从头开始实现自己的存储引擎，但是你确实需要从许多可用的存储引擎中选择一个合适的。\n而且为了协调存储引擎以适配应用工作负载，你也需要大致了解存储引擎在底层究竟做什么。\n- 特别需要注意，针对事务性负载和分析性负载优化的存储引擎之间存在巨大差异。稍后我们\n  将在 “事务处理还是分析？” 一节中探讨这一区别，并在 “列存储”中讨论一系列针对分析优化存储引擎。   \n>世界上最简单的数据库可以用两个Bash函数实现：\n> \\#!/bin/bash\n> db_set () {\n echo \"$1,$2\" >> database\n }\n db_get () {\n grep \"^$1,\" database | sed -e \"s/^$1,//\" | tail -n 1\n }\n 这两个函数实现了键值存储的功能。执行  db_set key value  ，会将 键（key）和值\n （value） 存储在数据库中。\n   \n- db_set\n  函数对于极其简单的场景其实有非常好的性能，因为在文件尾部追加写入通常是非常高效的。与\n  db_set 做的事情类似，许多数据库在内部使用了日志（log），也就是一个仅追\n  加（append-only）的数据文件。真正的数据库有更多的问题需要处理（如并发控制，回收\n  磁盘空间以避免日志无限增长，处理错误与部分写入的记录），但基本原理是一样的。日志\n  极其有用，我们还将在本书的其它部分重复见到它好几次。\n>日志（log）这个词通常指应用日志：即应用程序输出的描述发生事情的文本。本书在更\n 普遍的意义下使用日志这一词：一个仅追加的记录序列。它可能压根就不是给人类看\n 的，使用二进制格式，并仅能由其他程序读取。 \n \n- 索引背后的大致思想是，保存一些额外的元数据作为路\n  标，帮助你找到想要的数据。如果您想在同一份数据中以几种不同的方式进行搜索，那么你\n  也许需要不同的索引，建在数据的不同部分上。\n  \n- 索引是从主数据衍生的附加（additional）结构。许多数据库允许添加与删除索引，这不会影\n响数据的内容，它只影响查询的性能。维护额外的结构会产生开销，特别是在写入时。写入\n性能很难超过简单地追加写入文件，因为追加写入是最简单的写入操作。任何类型的索引通\n常都会减慢写入速度，因为每次写入数据时都需要更新索引。 \n> 这是存储系统中一个重要的权衡：精心选择的索引加快了读查询的速度，但是每个索引都会\n  拖慢写入速度。因为这个原因，数据库默认并不会索引所有的内容，而需要你（程序员或\n  DBA）通过对应用查询模式的了解来手动选择索引。你可以选择能为应用带来最大收益，同\n  时又不会引入超出必要开销的索引。\n\n- 哈希索引: 很常见与字典（dictionary）类型非常相似   \n- 所以如何避免最终用完磁盘空间？一种好的解决\n  方案是，将日志分为特定大小的段，当日志增长到特定尺寸时关闭当前段文件，并开始写入\n  一个新的段文件。然后，我们就可以对这些段进行压缩（compaction），如图3-2所示。压\n  缩意味着在日志中丢弃重复的键，只保留每个键的最近更新。\n  \n> 乍一看，只有追加日志看起来很浪费：为什么不更新文件，用新值覆盖旧值？但是只能追加设计的原因有几个：\n- 追加和分段合并是顺序写入操作，通常比随机写入快得多，尤其是在磁盘旋转硬盘上。\n- 在某种程度上，顺序写入在基于闪存的固态硬盘（SSD）上也是优选的【4】。我们将在\n- 第83页的“比较B-树和LSM-树”中进一步讨论这个问题。\n- 如果段文件是附加的或不可变的，并发和崩溃恢复就简单多了。例如，您不必担心在覆\n- 盖值时发生崩溃的情况，而将包含旧值和新值的一部分的文件保留在一起。\n- 合并旧段可以避免数据文件随着时间的推移而分散的问题。 \n\n>但是，哈希表索引也有局限性：\n **散列表必须能放进内存**如果你有非常多的键，那真是倒霉。原则上可以在磁盘上保留一个哈希映射，不幸的是 **磁盘哈希映射很难表现优秀**。它需要\n **大量的随机访问I/O**，当它变**满时增长是很昂贵的**， 并且解决散列冲突需要很多的逻辑 范围查询效率不高。例如，您无法轻松扫描kitty00000\n 和kitty99999 之间的所有键—您 必须在散列映射中单独查找每个键。 \n### 第四章：编码与演化\n> 本章中将介绍几种编码数据的格式，包括 JSON，XML，Protocol Buffers，Thrift和 Avro。\n\n- 需要在两种表示之间进行某种类型的翻译。 从内存中表示到字节序列的转换称为编码（Encoding）（也称为序列化（serialization）\n或编组（marshalling）），反过来称为解码\n  （Decoding） （解析（Parsing），反序列化（deserialization），反编组() unmarshalling）） 。\n- Java的内置序列化由于其糟糕的性能和臃肿的编码而臭名昭着【8】\n\n>程序通常（至少）使用两种形式的数据：\n> 1.在内存中，数据保存在对象，结构体，列表，数组，哈希表，树等中。 这些数据结构针\n>对CPU的高效访问和操作进行了优化（通常使用指针）。\n>2.如果要将数据写入文件，或通过网络发送，则必须将其编码（encode）为某种自包含的\n>字节序列（例如，JSON文档）。 由于每个进程都有自己独立的地址空间，一个进程中\n>的指针对任何其他进程都没有意义，所以这个字节序列表示会与通常在内存中使用的数\n>据结构完全不同 。\n\n>语言特定的格式\n许多编程语言都内建了将内存对象编码为字节序列的支持。例如，Java\n有 java.io.Serializable  【1】，Ruby有 Marshal  【2】，Python有 pickle【3】等等。许多\n第三方库也存在，例如 Kryo for Java  【4】。\n这些编码库非常方便，可以用很少的额外代码实现内存对象的保存与恢复。但是它们也有一些深层次的问题：这类编码通常与特定的编程语言深度绑定，其他语言\n很难读取这种数据。如果以这类编码存储或传输数据，那你就和这门语言绑死在一起了。并且很难将系统与其他组织的系统（可能用的是不同的语言）进行集成。\n为了恢复相同对象类型的数据，解码过程需要实例化任意类的能力，这通常是安全问题的一个来源【5】：如果攻击者可以让应用程序解码任意的字节序列，他们\n就能实例化任意的类，这会允许他们做可怕的事情，如远程执行任意代码【6,7】。在这些库中，数据版本控制通常是事后才考虑的。因为它们旨在快速简便地\n对数据进行编码，所以往往忽略了前向后向兼容性带来的麻烦问题。效率（编码或解码所花费的CPU时间，以及编码结构的大小）往往也是事后才考虑的。\n例如，Java的内置序列化由于其糟糕的性能和臃肿的编码而臭名昭着【8】。\n**因此，除非临时使用，采用语言内置编码通常是一个坏主意。**\n\n## 第二部分：分布式数据\n### 第五章：复制\n\n### 第六章：分区\n### 第七章：事务\n### 第八章：分布式系统的麻烦\n### 第九章：一致性与共识  \n\n---\n## 第三部分：派生数据\n### 第十章：批处理\n### 第十一章：流处理\n### 第十二章：数据系统的未来","source":"_posts/Designing Data-Intensive Application.md","raw":"---\ntitle: 读 Designing Data-Intensive Application\ndate: 2019-02-13 16:57:48\ntags: 阅读\ncategories: [设计思想]\n---\n\n## 前言\n> 拜读大佬的书籍，把重点的语句做个笔记。\n---\n书本内容：\n## 序言\n>1. 近些年的软件工程，特别是服务器端和后端系统开发，大量关于数据存储和处理的时髦词汇涌现出来： **NoSQL！大数据！Web-Scale！分片！最终一致性！\nACID！ CAP定理！云服务！MapReduce！实时！**\n2. 而**数据密集型应用**（data-intensive applications）正在通过使用这些技术进步来推动可能性的边界。当一个应用被称为**数据密集**型的引用，\n如果数据是其主要挑战（数据量，数据复杂度或数据变化速度）—— 与之相对的是**计算密集型**，即**处理器速度**是其瓶颈。\n3. 在技术迅速变化的背后总是存在一些持续成立的原则，无论我们使用了特定工具的哪个版本。如果理解了这些原则，就可以领会这些工具的适用场景，如何充分\n利用它们，以及如何避免其中的陷阱.\n## 第一部分：数据系统的基石\n1. 第一章将介绍本书使用的术语和方法。可靠性，可扩展性和可维护性 ，这些词汇到底意味着什么？如何实现这些目标？\n2. 第二章将对几种不同的数据模型和查询语言进行比较。从程序员的角度看，这是数据库之间最明显的区别。不同的数据模型适用于不同的应用场景。\n3. 第三章将深入存储引擎内部，研究数据库如何在磁盘上摆放数据。不同的存储引擎针对不同的负载进行优化，选择合适的存储引擎对系统性能有巨大影响。\n4. 第四章将对几种不同的 数据编码进行比较。特别研究了这些格式在应用需求经常变化、模式需要随时间演变的环境中表现如何。\n\n### 第一章：可靠性可，扩展性，可维护性\n- 现今很多应用程序都是 **数据密集型（data-intensive）** 的，而非 **计算密集型（compute-intensive）** 的。因此CPU很少成为这类应用的瓶颈，\n更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。一旦系统的负载被描述好，就可以研究当负载增加会发生什么。我们可以从两种角度来看：  \n    - 增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？\n    - 增加负载参数并希望保持性能不变时，需要增加多少系统资源？\n这两个问题都需要性能数据，所以让我们简单地看一下如何描述系统性能。\n​对于Hadoop这样的**批处理系统**，通常关心的是**吞吐量**（throughput），即每秒可以处理的记录数量，或者在特定规模数据集上运行作业的总时间。\n对于在线系统，通常更重要的是服务的**响应时间**（response time），即客户端发送请求到接收响应之间的时间。\n使不断重复发送同样的请求，每次得到的响应时间也都会略有不同。现实世界的系统会处理各式各样的请求，响应时间可能会有很大差异。因此我们需要将\n**响应时间**视为一个可以测量的**数值分布**（distribution），**而不是单个数值**\n\n### 第二章：数据模型与查询语言\n- 数据模型主要分为两种：**关系模型**(sql,典型的如mysql,oracle)与**文档模型**(noSql[Not Only SQL],典型的如mongo) \n- 采用NoSQL数据库的背后有几个驱动因素，其中包括：\n  - 需要比关系数据库更好的可扩展性，包括非常大的数据集或非常高的写入吞吐量\n  - 相比商业数据库产品，免费和开源软件更受偏爱。\n  - 关系模型不能很好地支持一些特殊的查询操作\n  - 受挫于关系模型的限制性，渴望一种更具多动态性与表现力的数据模型\n- 文档和关系数据库的融合:自2000年代中期以来，大多数关系数据库都已经开始支持文档结构：如json，xml格式的数据\n- 随着时间的推移，关系数据库和文档数据库似乎变得越来越相似，这是一件好事：数据模型相互补充 ，如果一个数据库能够处理类似文档的数据，\n并能够对其执行关系查询，那么应用程序就可以使用最符合其需求的功能组合。\n- 关系模型和文档模型的混合是未来数据库一条很好的路线。\n\n- 文档数据库有时称为无模式（schemaless），但这具有误导性，因为读取数据的代码通常假定某种结构——即存在隐式模式，但不由数据库强制执行。\n一个更精确的术语是读时模式（schema-on-read）（数据的结构是隐含的，只有在数据被读取时才被解释），相应的是写时模式（schema-on-write）\n（传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式）\n-  模式变更的速度很慢，而且要求停运。它的这种坏名誉并不是完全应得的：大多数关系数据库系统可在几毫秒内执行 ALTER TABLE  语句。\nMySQL是一个值得注意的例外，它执行 ALTER TABLE  时会复制整个表，这**可能意味着在更改一个大型表时会花费几分钟甚至几个小时的停机\n时间，尽管存在各种工具来解决这个限制**。\n- 大型表上运行 UPDATE 语句在任何数据库上都可能会很慢，因为每一行都需要重写。要是不可接受的话，应用程序可以将 first_name  设置为默认值 NULL\n  ，并在读取时再填充，就像使用文档数据库一样。\n> SQL是一种声明式查询语言，而IMS和CODASYL使用命令式代码来查询数据库。那是什么意思？许多常用的编程语言是命令式的。例如，给定一个动物物种的列表，\n返回列表中的鲨鱼可以这样写：\nfunction getSharks() {\nvar sharks = [];\nfor (var i = 0; i < animals.length; i++) {\nif (animals[i].family === \"Sharks\") {\nsharks.push(animals[i]);\n}\n}\nreturn sharks;\n}\n命令式语言告诉计算机以特定顺序执行某些操作。可以想象一下，逐行地遍历代码，评估条 件，更新变量，并决定是否再循环一遍。\n在声明式查询语言（如SQL或关系代数）中，你只需指定所需数据的模式 - 结果必须符合哪些 条件，以及如何将数据转换（例如，排序，分组和集合）\n但不是如何实现这一目标。数据库 系统的查询优化器决定使用哪些索引和哪些连接方法，以及以何种顺序执行查询的各个部分。\n\n- 声明式查询语言是迷人的，因为它通常比命令式API更加简洁和容易。但更重要的是，它还隐\n藏了数据库引擎的实现细节，这使得数据库系统可以在无需对查询做任何更改的情况下进行\n性能提升。  \n\n- 最后，声明式语言往往适合并行执行。现在，CPU的速度通过内核的增加变得更快，而不是\n以比以前更高的时钟速度运行【31】。命令代码很难在多个内核和多个机器之间并行化，因\n为它指定了指令必须以特定顺序执行。声明式语言更具有并行执行的潜力，因为它们仅指定\n结果的模式，而不指定用于确定结果的算法。在适当情况下，数据库可以自由使用查询语言\n的并行实现\n\n- 我们会研究两大类存储引擎：日志结构（log-structured）的存储引擎，以及面向页面（page-oriented）的存储引擎（例如B树）。\n- 冻结段的合并和压缩可以在后台线程中完成，在进行时，我们仍然可以继续使用旧的段文件来正常提供读写请求。合并过程完成后，我们将读取请求转换为\n使用新的合并段 而不是旧段然后可以简单地删除旧的段文件。\n- **简而言之，一些真正实施中重要的问题是:**\n  - **文件格式**:\n  - **删除记录**:\n  - **崩溃恢复**:\n  - **部分写入记录**:\n  - **并发控制**: 乍一看，只有追加日志看起来很浪费：为什么不更新文件，用新值覆盖旧值？但是只能追加设计的原因有几个:\n    - 追加和分段合并是顺序写入操作，通常比随机写入快得多，尤其是在磁盘旋转硬盘上。\n    - 在某种程度上，顺序写入在基于闪存的固态硬盘（SSD）上也是优选的【4】。我们将在\n    - 第83页的“比较B-树和LSM-树”中进一步讨论这个问题。\n    - 如果段文件是附加的或不可变的，并发和崩溃恢复就简单多了。例如，您不必担心在覆\n    - 盖值时发生崩溃的情况，而将包含旧值和新值的一部分的文件保留在一起。\n    - 合并旧段可以避免数据文件随着时间的推移而分散的问题。  \n- 与往常一样，大量的细节使得存储引擎在实践中表现良好。例如，当查找数据库中**不存在的键**时，LSM树算法可能会很慢：您必须检查内存表，然后将这些段一\n直回到最老的（这可能必须从磁盘读取每一个），然后才能确定键不存在。为了优化这种访问，存储引擎通常使用额外的Bloom过滤器\n- 布隆过滤器是用于近似集合内容的内存高效数据结构，它可以告诉您数据库中是否出现键，从而为不存在的键节省许多不必要的磁盘读取操作。\n  (布隆过滤有这样的特性：没有那就一定是没有，有，有百分之95%以上的几率是有的，用很小的错误率，和很小的空间获得特别大的效率)\n-  即使有许多微妙的东西，LSM树的基本思想 —— 保存一系列在后台合并的SSTables —— 简 单而有效。即使数据集比可用内存大得多，它仍能继续正常工作。\n由于数据按排序顺序存储， 因此可以高效地执行范围查询（扫描所有高于某些最小值和最高值的所有键），并且因 为磁盘写入是连续的，所以LSM树可以支持\n非常高的写入吞吐量。\n- 在B树的一个页面中对子页面的引用的数量称为分支因子。例如，在图3-6中，分支因子是 6 。在实践中，分支因子取决于存储页面参考和范围边界所需的空间量，\n但通常是几百个。\n- 日志结构化的方法在这方面更简单，因为它们在后台进行所有的合并，而不会干扰传入的查询，并且不时地将旧的分段原子交换为新的分段。\n- 这种差异在磁性硬盘驱动器上尤其重要，顺序写入比随机写入快得多。\n- 在许多关系数据库中，事务隔离是通过在键范围上使用锁来实现的，在B树索引中，这些锁可以直接连接到树\n- 在新的数据存储中，**日志结构化索引**变得越来越流行。没有快速和容易的规则来确定哪种类型的存储引擎对你的场景更好，所以值得进行一些经验上的测试.\n- 索引中的关键字是查询搜索的内容，但是该值可以是以下两种情况之一：它可以是所讨论的实际行（文档，顶点），也可以是对存储在别处的行的引用。在后一种\n情况下，行被存储的 地方被称为堆文件（heap file），并且存储的数据没有特定的顺序（它可以是仅附加的，或 者可以跟踪被删除的行以便用新数据覆盖它们后来）\n- 在聚集索引（在索引中存储所有行数据）和非聚集索引（仅在索引中存储对数据的引用）之间的折衷被称为包含列的索引或覆盖索引，其存储表的一部分在索引内。\n这允许通过单独使用索引来回答一些查询（这种情况叫做：索引覆盖（cover）了查询）\n- 某些内存中的键值存储（如Memcached）仅用于缓存，在重新启动计算机时丢失的数据是可 以接受的。但其他内存数据库的目标是持久性，可以通过特殊的硬件\n（例如电池供电的 RAM），将更改日志写入磁盘，将定时快照写入磁盘或通过复制内存来实现，记忆状态到其他机器。\n>诸如VoltDB，MemSQL和Oracle TimesTen等产品是具有关系模型的内存数据库，供应商声称，通过消除与管理磁盘上的数据结构相关的所有开销，\n他们可以提供巨大的性能改进【41,42】。 RAM Cloud是一个开源的内存键值存储器，具有持久性（对存储器中的数据以及磁盘上的数据使用日志结构化方法）\n【43】。 Redis和Couchbase通过异步写入磁盘提供了较弱的持久性。\n \n>磁盘的顺序读速度能打到在100MB/S上下使用列式存储，分析的时候，可以只扫描需要的那部分数据的时候，减少CPU和磁盘的访问量。同时面向列的存储通常\n很适合压缩，使用压缩，可以综合CPU和磁盘，发挥最大的效能。\n>面向行的存储将每一行保存在一个地方（在堆文件或聚簇索引中）\n> 在OLTP方面，我们看到了来自两大主流学派的存储引擎： 日志结构学派\n> 只允许附加到文件和删除过时的文件，但不会更新已经写入的文件。 Bitcask，SSTables，LSM树，LevelDB，Cassandra，HBase，Lucene等都属于这个组。 \n原地更新学派将磁盘视为一组可以覆盖的固定大小的页面。 B树是这种哲学的最大的例子，被用在所有主要的关系数据库中，还有许多非关系数据库。\n \n### 第三章：存储与检索\n> 日志结构的存储引擎是相对较新的发展。他们的主要想法是，他们系统地将随机访问写入顺\n> 序写入磁盘，由于硬盘驱动器和固态硬盘的性能特点，可以实现更高的写入吞吐量。在完成\n> OLTP方面，我们通过一些更复杂的索引结构和为保留所有数据而优化的数据库做了一个简短\n> 的介绍。 然后，我们从存储引擎的内部绕开，看看典型数据仓库的高级架构。这一背景说明了为什么\n> 分析工作负载与OLTP差别很大：当您的查询需要在大量行中顺序扫描时，索引的相关性就会\n> 降低很多。相反，非常紧凑地编码数据变得非常重要，以最大限度地减少查询需要从磁盘读\n> 取的数据量。我们讨论了列式存储如何帮助实现这一目标。\n> 作为一名应用程序开发人员，如果您掌握了有关存储引擎内部的知识，那么您就能更好地了\n> 解哪种工具最适合您的特定应用程序。 如果您需要调整数据库的调整参数，这种理解可以让\n> 您设想一个更高或更低的值可能会产生什么效果。\n> 尽管本章不能让你成为一个特定存储引擎的调参专家，但它至少有大概率使你有了足够的概\n> 念与词汇储备去读懂数据库的文档，从而选择合适的数据库。\n\n>\n- 作为程序员，为什么要关心数据库内部存储与检索的机理？你可能不会去从头开始实现自己的存储引擎，但是你确实需要从许多可用的存储引擎中选择一个合适的。\n而且为了协调存储引擎以适配应用工作负载，你也需要大致了解存储引擎在底层究竟做什么。\n- 特别需要注意，针对事务性负载和分析性负载优化的存储引擎之间存在巨大差异。稍后我们\n  将在 “事务处理还是分析？” 一节中探讨这一区别，并在 “列存储”中讨论一系列针对分析优化存储引擎。   \n>世界上最简单的数据库可以用两个Bash函数实现：\n> \\#!/bin/bash\n> db_set () {\n echo \"$1,$2\" >> database\n }\n db_get () {\n grep \"^$1,\" database | sed -e \"s/^$1,//\" | tail -n 1\n }\n 这两个函数实现了键值存储的功能。执行  db_set key value  ，会将 键（key）和值\n （value） 存储在数据库中。\n   \n- db_set\n  函数对于极其简单的场景其实有非常好的性能，因为在文件尾部追加写入通常是非常高效的。与\n  db_set 做的事情类似，许多数据库在内部使用了日志（log），也就是一个仅追\n  加（append-only）的数据文件。真正的数据库有更多的问题需要处理（如并发控制，回收\n  磁盘空间以避免日志无限增长，处理错误与部分写入的记录），但基本原理是一样的。日志\n  极其有用，我们还将在本书的其它部分重复见到它好几次。\n>日志（log）这个词通常指应用日志：即应用程序输出的描述发生事情的文本。本书在更\n 普遍的意义下使用日志这一词：一个仅追加的记录序列。它可能压根就不是给人类看\n 的，使用二进制格式，并仅能由其他程序读取。 \n \n- 索引背后的大致思想是，保存一些额外的元数据作为路\n  标，帮助你找到想要的数据。如果您想在同一份数据中以几种不同的方式进行搜索，那么你\n  也许需要不同的索引，建在数据的不同部分上。\n  \n- 索引是从主数据衍生的附加（additional）结构。许多数据库允许添加与删除索引，这不会影\n响数据的内容，它只影响查询的性能。维护额外的结构会产生开销，特别是在写入时。写入\n性能很难超过简单地追加写入文件，因为追加写入是最简单的写入操作。任何类型的索引通\n常都会减慢写入速度，因为每次写入数据时都需要更新索引。 \n> 这是存储系统中一个重要的权衡：精心选择的索引加快了读查询的速度，但是每个索引都会\n  拖慢写入速度。因为这个原因，数据库默认并不会索引所有的内容，而需要你（程序员或\n  DBA）通过对应用查询模式的了解来手动选择索引。你可以选择能为应用带来最大收益，同\n  时又不会引入超出必要开销的索引。\n\n- 哈希索引: 很常见与字典（dictionary）类型非常相似   \n- 所以如何避免最终用完磁盘空间？一种好的解决\n  方案是，将日志分为特定大小的段，当日志增长到特定尺寸时关闭当前段文件，并开始写入\n  一个新的段文件。然后，我们就可以对这些段进行压缩（compaction），如图3-2所示。压\n  缩意味着在日志中丢弃重复的键，只保留每个键的最近更新。\n  \n> 乍一看，只有追加日志看起来很浪费：为什么不更新文件，用新值覆盖旧值？但是只能追加设计的原因有几个：\n- 追加和分段合并是顺序写入操作，通常比随机写入快得多，尤其是在磁盘旋转硬盘上。\n- 在某种程度上，顺序写入在基于闪存的固态硬盘（SSD）上也是优选的【4】。我们将在\n- 第83页的“比较B-树和LSM-树”中进一步讨论这个问题。\n- 如果段文件是附加的或不可变的，并发和崩溃恢复就简单多了。例如，您不必担心在覆\n- 盖值时发生崩溃的情况，而将包含旧值和新值的一部分的文件保留在一起。\n- 合并旧段可以避免数据文件随着时间的推移而分散的问题。 \n\n>但是，哈希表索引也有局限性：\n **散列表必须能放进内存**如果你有非常多的键，那真是倒霉。原则上可以在磁盘上保留一个哈希映射，不幸的是 **磁盘哈希映射很难表现优秀**。它需要\n **大量的随机访问I/O**，当它变**满时增长是很昂贵的**， 并且解决散列冲突需要很多的逻辑 范围查询效率不高。例如，您无法轻松扫描kitty00000\n 和kitty99999 之间的所有键—您 必须在散列映射中单独查找每个键。 \n### 第四章：编码与演化\n> 本章中将介绍几种编码数据的格式，包括 JSON，XML，Protocol Buffers，Thrift和 Avro。\n\n- 需要在两种表示之间进行某种类型的翻译。 从内存中表示到字节序列的转换称为编码（Encoding）（也称为序列化（serialization）\n或编组（marshalling）），反过来称为解码\n  （Decoding） （解析（Parsing），反序列化（deserialization），反编组() unmarshalling）） 。\n- Java的内置序列化由于其糟糕的性能和臃肿的编码而臭名昭着【8】\n\n>程序通常（至少）使用两种形式的数据：\n> 1.在内存中，数据保存在对象，结构体，列表，数组，哈希表，树等中。 这些数据结构针\n>对CPU的高效访问和操作进行了优化（通常使用指针）。\n>2.如果要将数据写入文件，或通过网络发送，则必须将其编码（encode）为某种自包含的\n>字节序列（例如，JSON文档）。 由于每个进程都有自己独立的地址空间，一个进程中\n>的指针对任何其他进程都没有意义，所以这个字节序列表示会与通常在内存中使用的数\n>据结构完全不同 。\n\n>语言特定的格式\n许多编程语言都内建了将内存对象编码为字节序列的支持。例如，Java\n有 java.io.Serializable  【1】，Ruby有 Marshal  【2】，Python有 pickle【3】等等。许多\n第三方库也存在，例如 Kryo for Java  【4】。\n这些编码库非常方便，可以用很少的额外代码实现内存对象的保存与恢复。但是它们也有一些深层次的问题：这类编码通常与特定的编程语言深度绑定，其他语言\n很难读取这种数据。如果以这类编码存储或传输数据，那你就和这门语言绑死在一起了。并且很难将系统与其他组织的系统（可能用的是不同的语言）进行集成。\n为了恢复相同对象类型的数据，解码过程需要实例化任意类的能力，这通常是安全问题的一个来源【5】：如果攻击者可以让应用程序解码任意的字节序列，他们\n就能实例化任意的类，这会允许他们做可怕的事情，如远程执行任意代码【6,7】。在这些库中，数据版本控制通常是事后才考虑的。因为它们旨在快速简便地\n对数据进行编码，所以往往忽略了前向后向兼容性带来的麻烦问题。效率（编码或解码所花费的CPU时间，以及编码结构的大小）往往也是事后才考虑的。\n例如，Java的内置序列化由于其糟糕的性能和臃肿的编码而臭名昭着【8】。\n**因此，除非临时使用，采用语言内置编码通常是一个坏主意。**\n\n## 第二部分：分布式数据\n### 第五章：复制\n\n### 第六章：分区\n### 第七章：事务\n### 第八章：分布式系统的麻烦\n### 第九章：一致性与共识  \n\n---\n## 第三部分：派生数据\n### 第十章：批处理\n### 第十一章：流处理\n### 第十二章：数据系统的未来","slug":"Designing Data-Intensive Application","published":1,"updated":"2019-04-26T16:06:56.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0hkxqmj0028ektvimhyon4d","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>拜读大佬的书籍，把重点的语句做个笔记。</p>\n</blockquote>\n<hr>\n<p>书本内容：</p>\n<h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><blockquote>\n<ol>\n<li>近些年的软件工程，特别是服务器端和后端系统开发，大量关于数据存储和处理的时髦词汇涌现出来： <strong>NoSQL！大数据！Web-Scale！分片！最终一致性！<br>ACID！ CAP定理！云服务！MapReduce！实时！</strong></li>\n<li>而<strong>数据密集型应用</strong>（data-intensive applications）正在通过使用这些技术进步来推动可能性的边界。当一个应用被称为<strong>数据密集</strong>型的引用，<br>如果数据是其主要挑战（数据量，数据复杂度或数据变化速度）—— 与之相对的是<strong>计算密集型</strong>，即<strong>处理器速度</strong>是其瓶颈。</li>\n<li>在技术迅速变化的背后总是存在一些持续成立的原则，无论我们使用了特定工具的哪个版本。如果理解了这些原则，就可以领会这些工具的适用场景，如何充分<br>利用它们，以及如何避免其中的陷阱.</li>\n</ol>\n</blockquote>\n<h2 id=\"第一部分：数据系统的基石\"><a href=\"#第一部分：数据系统的基石\" class=\"headerlink\" title=\"第一部分：数据系统的基石\"></a>第一部分：数据系统的基石</h2><ol>\n<li>第一章将介绍本书使用的术语和方法。可靠性，可扩展性和可维护性 ，这些词汇到底意味着什么？如何实现这些目标？</li>\n<li>第二章将对几种不同的数据模型和查询语言进行比较。从程序员的角度看，这是数据库之间最明显的区别。不同的数据模型适用于不同的应用场景。</li>\n<li>第三章将深入存储引擎内部，研究数据库如何在磁盘上摆放数据。不同的存储引擎针对不同的负载进行优化，选择合适的存储引擎对系统性能有巨大影响。</li>\n<li>第四章将对几种不同的 数据编码进行比较。特别研究了这些格式在应用需求经常变化、模式需要随时间演变的环境中表现如何。</li>\n</ol>\n<h3 id=\"第一章：可靠性可，扩展性，可维护性\"><a href=\"#第一章：可靠性可，扩展性，可维护性\" class=\"headerlink\" title=\"第一章：可靠性可，扩展性，可维护性\"></a>第一章：可靠性可，扩展性，可维护性</h3><ul>\n<li>现今很多应用程序都是 <strong>数据密集型（data-intensive）</strong> 的，而非 <strong>计算密集型（compute-intensive）</strong> 的。因此CPU很少成为这类应用的瓶颈，<br>更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。一旦系统的负载被描述好，就可以研究当负载增加会发生什么。我们可以从两种角度来看：  <ul>\n<li>增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？</li>\n<li>增加负载参数并希望保持性能不变时，需要增加多少系统资源？<br>这两个问题都需要性能数据，所以让我们简单地看一下如何描述系统性能。<br>​对于Hadoop这样的<strong>批处理系统</strong>，通常关心的是<strong>吞吐量</strong>（throughput），即每秒可以处理的记录数量，或者在特定规模数据集上运行作业的总时间。<br>对于在线系统，通常更重要的是服务的<strong>响应时间</strong>（response time），即客户端发送请求到接收响应之间的时间。<br>使不断重复发送同样的请求，每次得到的响应时间也都会略有不同。现实世界的系统会处理各式各样的请求，响应时间可能会有很大差异。因此我们需要将<br><strong>响应时间</strong>视为一个可以测量的<strong>数值分布</strong>（distribution），<strong>而不是单个数值</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第二章：数据模型与查询语言\"><a href=\"#第二章：数据模型与查询语言\" class=\"headerlink\" title=\"第二章：数据模型与查询语言\"></a>第二章：数据模型与查询语言</h3><ul>\n<li>数据模型主要分为两种：<strong>关系模型</strong>(sql,典型的如mysql,oracle)与<strong>文档模型</strong>(noSql[Not Only SQL],典型的如mongo) </li>\n<li>采用NoSQL数据库的背后有几个驱动因素，其中包括：<ul>\n<li>需要比关系数据库更好的可扩展性，包括非常大的数据集或非常高的写入吞吐量</li>\n<li>相比商业数据库产品，免费和开源软件更受偏爱。</li>\n<li>关系模型不能很好地支持一些特殊的查询操作</li>\n<li>受挫于关系模型的限制性，渴望一种更具多动态性与表现力的数据模型</li>\n</ul>\n</li>\n<li>文档和关系数据库的融合:自2000年代中期以来，大多数关系数据库都已经开始支持文档结构：如json，xml格式的数据</li>\n<li>随着时间的推移，关系数据库和文档数据库似乎变得越来越相似，这是一件好事：数据模型相互补充 ，如果一个数据库能够处理类似文档的数据，<br>并能够对其执行关系查询，那么应用程序就可以使用最符合其需求的功能组合。</li>\n<li><p>关系模型和文档模型的混合是未来数据库一条很好的路线。</p>\n</li>\n<li><p>文档数据库有时称为无模式（schemaless），但这具有误导性，因为读取数据的代码通常假定某种结构——即存在隐式模式，但不由数据库强制执行。<br>一个更精确的术语是读时模式（schema-on-read）（数据的结构是隐含的，只有在数据被读取时才被解释），相应的是写时模式（schema-on-write）<br>（传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式）</p>\n</li>\n<li>模式变更的速度很慢，而且要求停运。它的这种坏名誉并不是完全应得的：大多数关系数据库系统可在几毫秒内执行 ALTER TABLE  语句。<br>MySQL是一个值得注意的例外，它执行 ALTER TABLE  时会复制整个表，这<strong>可能意味着在更改一个大型表时会花费几分钟甚至几个小时的停机<br>时间，尽管存在各种工具来解决这个限制</strong>。</li>\n<li><p>大型表上运行 UPDATE 语句在任何数据库上都可能会很慢，因为每一行都需要重写。要是不可接受的话，应用程序可以将 first_name  设置为默认值 NULL<br>，并在读取时再填充，就像使用文档数据库一样。</p>\n<blockquote>\n<p>SQL是一种声明式查询语言，而IMS和CODASYL使用命令式代码来查询数据库。那是什么意思？许多常用的编程语言是命令式的。例如，给定一个动物物种的列表，<br>返回列表中的鲨鱼可以这样写：<br>function getSharks() {<br>var sharks = [];<br>for (var i = 0; i &lt; animals.length; i++) {<br>if (animals[i].family === “Sharks”) {<br>sharks.push(animals[i]);<br>}<br>}<br>return sharks;<br>}<br>命令式语言告诉计算机以特定顺序执行某些操作。可以想象一下，逐行地遍历代码，评估条 件，更新变量，并决定是否再循环一遍。<br>在声明式查询语言（如SQL或关系代数）中，你只需指定所需数据的模式 - 结果必须符合哪些 条件，以及如何将数据转换（例如，排序，分组和集合）<br>但不是如何实现这一目标。数据库 系统的查询优化器决定使用哪些索引和哪些连接方法，以及以何种顺序执行查询的各个部分。</p>\n</blockquote>\n</li>\n<li><p>声明式查询语言是迷人的，因为它通常比命令式API更加简洁和容易。但更重要的是，它还隐<br>藏了数据库引擎的实现细节，这使得数据库系统可以在无需对查询做任何更改的情况下进行<br>性能提升。  </p>\n</li>\n<li><p>最后，声明式语言往往适合并行执行。现在，CPU的速度通过内核的增加变得更快，而不是<br>以比以前更高的时钟速度运行【31】。命令代码很难在多个内核和多个机器之间并行化，因<br>为它指定了指令必须以特定顺序执行。声明式语言更具有并行执行的潜力，因为它们仅指定<br>结果的模式，而不指定用于确定结果的算法。在适当情况下，数据库可以自由使用查询语言<br>的并行实现</p>\n</li>\n<li><p>我们会研究两大类存储引擎：日志结构（log-structured）的存储引擎，以及面向页面（page-oriented）的存储引擎（例如B树）。</p>\n</li>\n<li>冻结段的合并和压缩可以在后台线程中完成，在进行时，我们仍然可以继续使用旧的段文件来正常提供读写请求。合并过程完成后，我们将读取请求转换为<br>使用新的合并段 而不是旧段然后可以简单地删除旧的段文件。</li>\n<li><strong>简而言之，一些真正实施中重要的问题是:</strong><ul>\n<li><strong>文件格式</strong>:</li>\n<li><strong>删除记录</strong>:</li>\n<li><strong>崩溃恢复</strong>:</li>\n<li><strong>部分写入记录</strong>:</li>\n<li><strong>并发控制</strong>: 乍一看，只有追加日志看起来很浪费：为什么不更新文件，用新值覆盖旧值？但是只能追加设计的原因有几个:<ul>\n<li>追加和分段合并是顺序写入操作，通常比随机写入快得多，尤其是在磁盘旋转硬盘上。</li>\n<li>在某种程度上，顺序写入在基于闪存的固态硬盘（SSD）上也是优选的【4】。我们将在</li>\n<li>第83页的“比较B-树和LSM-树”中进一步讨论这个问题。</li>\n<li>如果段文件是附加的或不可变的，并发和崩溃恢复就简单多了。例如，您不必担心在覆</li>\n<li>盖值时发生崩溃的情况，而将包含旧值和新值的一部分的文件保留在一起。</li>\n<li>合并旧段可以避免数据文件随着时间的推移而分散的问题。  </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>与往常一样，大量的细节使得存储引擎在实践中表现良好。例如，当查找数据库中<strong>不存在的键</strong>时，LSM树算法可能会很慢：您必须检查内存表，然后将这些段一<br>直回到最老的（这可能必须从磁盘读取每一个），然后才能确定键不存在。为了优化这种访问，存储引擎通常使用额外的Bloom过滤器</li>\n<li>布隆过滤器是用于近似集合内容的内存高效数据结构，它可以告诉您数据库中是否出现键，从而为不存在的键节省许多不必要的磁盘读取操作。<br>(布隆过滤有这样的特性：没有那就一定是没有，有，有百分之95%以上的几率是有的，用很小的错误率，和很小的空间获得特别大的效率)</li>\n<li>即使有许多微妙的东西，LSM树的基本思想 —— 保存一系列在后台合并的SSTables —— 简 单而有效。即使数据集比可用内存大得多，它仍能继续正常工作。<br>由于数据按排序顺序存储， 因此可以高效地执行范围查询（扫描所有高于某些最小值和最高值的所有键），并且因 为磁盘写入是连续的，所以LSM树可以支持<br>非常高的写入吞吐量。</li>\n<li>在B树的一个页面中对子页面的引用的数量称为分支因子。例如，在图3-6中，分支因子是 6 。在实践中，分支因子取决于存储页面参考和范围边界所需的空间量，<br>但通常是几百个。</li>\n<li>日志结构化的方法在这方面更简单，因为它们在后台进行所有的合并，而不会干扰传入的查询，并且不时地将旧的分段原子交换为新的分段。</li>\n<li>这种差异在磁性硬盘驱动器上尤其重要，顺序写入比随机写入快得多。</li>\n<li>在许多关系数据库中，事务隔离是通过在键范围上使用锁来实现的，在B树索引中，这些锁可以直接连接到树</li>\n<li>在新的数据存储中，<strong>日志结构化索引</strong>变得越来越流行。没有快速和容易的规则来确定哪种类型的存储引擎对你的场景更好，所以值得进行一些经验上的测试.</li>\n<li>索引中的关键字是查询搜索的内容，但是该值可以是以下两种情况之一：它可以是所讨论的实际行（文档，顶点），也可以是对存储在别处的行的引用。在后一种<br>情况下，行被存储的 地方被称为堆文件（heap file），并且存储的数据没有特定的顺序（它可以是仅附加的，或 者可以跟踪被删除的行以便用新数据覆盖它们后来）</li>\n<li>在聚集索引（在索引中存储所有行数据）和非聚集索引（仅在索引中存储对数据的引用）之间的折衷被称为包含列的索引或覆盖索引，其存储表的一部分在索引内。<br>这允许通过单独使用索引来回答一些查询（这种情况叫做：索引覆盖（cover）了查询）</li>\n<li>某些内存中的键值存储（如Memcached）仅用于缓存，在重新启动计算机时丢失的数据是可 以接受的。但其他内存数据库的目标是持久性，可以通过特殊的硬件<br>（例如电池供电的 RAM），将更改日志写入磁盘，将定时快照写入磁盘或通过复制内存来实现，记忆状态到其他机器。<blockquote>\n<p>诸如VoltDB，MemSQL和Oracle TimesTen等产品是具有关系模型的内存数据库，供应商声称，通过消除与管理磁盘上的数据结构相关的所有开销，<br>他们可以提供巨大的性能改进【41,42】。 RAM Cloud是一个开源的内存键值存储器，具有持久性（对存储器中的数据以及磁盘上的数据使用日志结构化方法）<br>【43】。 Redis和Couchbase通过异步写入磁盘提供了较弱的持久性。</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>磁盘的顺序读速度能打到在100MB/S上下使用列式存储，分析的时候，可以只扫描需要的那部分数据的时候，减少CPU和磁盘的访问量。同时面向列的存储通常<br>很适合压缩，使用压缩，可以综合CPU和磁盘，发挥最大的效能。<br>面向行的存储将每一行保存在一个地方（在堆文件或聚簇索引中）<br>在OLTP方面，我们看到了来自两大主流学派的存储引擎： 日志结构学派<br>只允许附加到文件和删除过时的文件，但不会更新已经写入的文件。 Bitcask，SSTables，LSM树，LevelDB，Cassandra，HBase，Lucene等都属于这个组。<br>原地更新学派将磁盘视为一组可以覆盖的固定大小的页面。 B树是这种哲学的最大的例子，被用在所有主要的关系数据库中，还有许多非关系数据库。</p>\n</blockquote>\n<h3 id=\"第三章：存储与检索\"><a href=\"#第三章：存储与检索\" class=\"headerlink\" title=\"第三章：存储与检索\"></a>第三章：存储与检索</h3><blockquote>\n<p>日志结构的存储引擎是相对较新的发展。他们的主要想法是，他们系统地将随机访问写入顺<br>序写入磁盘，由于硬盘驱动器和固态硬盘的性能特点，可以实现更高的写入吞吐量。在完成<br>OLTP方面，我们通过一些更复杂的索引结构和为保留所有数据而优化的数据库做了一个简短<br>的介绍。 然后，我们从存储引擎的内部绕开，看看典型数据仓库的高级架构。这一背景说明了为什么<br>分析工作负载与OLTP差别很大：当您的查询需要在大量行中顺序扫描时，索引的相关性就会<br>降低很多。相反，非常紧凑地编码数据变得非常重要，以最大限度地减少查询需要从磁盘读<br>取的数据量。我们讨论了列式存储如何帮助实现这一目标。<br>作为一名应用程序开发人员，如果您掌握了有关存储引擎内部的知识，那么您就能更好地了<br>解哪种工具最适合您的特定应用程序。 如果您需要调整数据库的调整参数，这种理解可以让<br>您设想一个更高或更低的值可能会产生什么效果。<br>尽管本章不能让你成为一个特定存储引擎的调参专家，但它至少有大概率使你有了足够的概<br>念与词汇储备去读懂数据库的文档，从而选择合适的数据库。</p>\n</blockquote>\n<blockquote>\n</blockquote>\n<ul>\n<li>作为程序员，为什么要关心数据库内部存储与检索的机理？你可能不会去从头开始实现自己的存储引擎，但是你确实需要从许多可用的存储引擎中选择一个合适的。<br>而且为了协调存储引擎以适配应用工作负载，你也需要大致了解存储引擎在底层究竟做什么。</li>\n<li><p>特别需要注意，针对事务性负载和分析性负载优化的存储引擎之间存在巨大差异。稍后我们<br>将在 “事务处理还是分析？” 一节中探讨这一区别，并在 “列存储”中讨论一系列针对分析优化存储引擎。   </p>\n<blockquote>\n<p>世界上最简单的数据库可以用两个Bash函数实现：<br>#!/bin/bash<br>db_set () {<br>echo “$1,$2” &gt;&gt; database<br>}<br>db_get () {<br>grep “^$1,” database | sed -e “s/^$1,//“ | tail -n 1<br>}<br>这两个函数实现了键值存储的功能。执行  db_set key value  ，会将 键（key）和值<br>（value） 存储在数据库中。</p>\n</blockquote>\n</li>\n<li><p>db_set<br>函数对于极其简单的场景其实有非常好的性能，因为在文件尾部追加写入通常是非常高效的。与<br>db_set 做的事情类似，许多数据库在内部使用了日志（log），也就是一个仅追<br>加（append-only）的数据文件。真正的数据库有更多的问题需要处理（如并发控制，回收<br>磁盘空间以避免日志无限增长，处理错误与部分写入的记录），但基本原理是一样的。日志<br>极其有用，我们还将在本书的其它部分重复见到它好几次。</p>\n<blockquote>\n<p>日志（log）这个词通常指应用日志：即应用程序输出的描述发生事情的文本。本书在更<br>普遍的意义下使用日志这一词：一个仅追加的记录序列。它可能压根就不是给人类看<br>的，使用二进制格式，并仅能由其他程序读取。 </p>\n</blockquote>\n</li>\n<li><p>索引背后的大致思想是，保存一些额外的元数据作为路<br>标，帮助你找到想要的数据。如果您想在同一份数据中以几种不同的方式进行搜索，那么你<br>也许需要不同的索引，建在数据的不同部分上。</p>\n</li>\n<li><p>索引是从主数据衍生的附加（additional）结构。许多数据库允许添加与删除索引，这不会影<br>响数据的内容，它只影响查询的性能。维护额外的结构会产生开销，特别是在写入时。写入<br>性能很难超过简单地追加写入文件，因为追加写入是最简单的写入操作。任何类型的索引通<br>常都会减慢写入速度，因为每次写入数据时都需要更新索引。 </p>\n<blockquote>\n<p>这是存储系统中一个重要的权衡：精心选择的索引加快了读查询的速度，但是每个索引都会<br>拖慢写入速度。因为这个原因，数据库默认并不会索引所有的内容，而需要你（程序员或<br>DBA）通过对应用查询模式的了解来手动选择索引。你可以选择能为应用带来最大收益，同<br>时又不会引入超出必要开销的索引。</p>\n</blockquote>\n</li>\n<li><p>哈希索引: 很常见与字典（dictionary）类型非常相似   </p>\n</li>\n<li>所以如何避免最终用完磁盘空间？一种好的解决<br>方案是，将日志分为特定大小的段，当日志增长到特定尺寸时关闭当前段文件，并开始写入<br>一个新的段文件。然后，我们就可以对这些段进行压缩（compaction），如图3-2所示。压<br>缩意味着在日志中丢弃重复的键，只保留每个键的最近更新。</li>\n</ul>\n<blockquote>\n<p>乍一看，只有追加日志看起来很浪费：为什么不更新文件，用新值覆盖旧值？但是只能追加设计的原因有几个：</p>\n<ul>\n<li>追加和分段合并是顺序写入操作，通常比随机写入快得多，尤其是在磁盘旋转硬盘上。</li>\n<li>在某种程度上，顺序写入在基于闪存的固态硬盘（SSD）上也是优选的【4】。我们将在</li>\n<li>第83页的“比较B-树和LSM-树”中进一步讨论这个问题。</li>\n<li>如果段文件是附加的或不可变的，并发和崩溃恢复就简单多了。例如，您不必担心在覆</li>\n<li>盖值时发生崩溃的情况，而将包含旧值和新值的一部分的文件保留在一起。</li>\n<li>合并旧段可以避免数据文件随着时间的推移而分散的问题。 </li>\n</ul>\n</blockquote>\n<blockquote>\n<p>但是，哈希表索引也有局限性：<br> <strong>散列表必须能放进内存</strong>如果你有非常多的键，那真是倒霉。原则上可以在磁盘上保留一个哈希映射，不幸的是 <strong>磁盘哈希映射很难表现优秀</strong>。它需要<br> <strong>大量的随机访问I/O</strong>，当它变<strong>满时增长是很昂贵的</strong>， 并且解决散列冲突需要很多的逻辑 范围查询效率不高。例如，您无法轻松扫描kitty00000<br> 和kitty99999 之间的所有键—您 必须在散列映射中单独查找每个键。 </p>\n</blockquote>\n<h3 id=\"第四章：编码与演化\"><a href=\"#第四章：编码与演化\" class=\"headerlink\" title=\"第四章：编码与演化\"></a>第四章：编码与演化</h3><blockquote>\n<p>本章中将介绍几种编码数据的格式，包括 JSON，XML，Protocol Buffers，Thrift和 Avro。</p>\n</blockquote>\n<ul>\n<li>需要在两种表示之间进行某种类型的翻译。 从内存中表示到字节序列的转换称为编码（Encoding）（也称为序列化（serialization）<br>或编组（marshalling）），反过来称为解码<br>（Decoding） （解析（Parsing），反序列化（deserialization），反编组() unmarshalling）） 。</li>\n<li>Java的内置序列化由于其糟糕的性能和臃肿的编码而臭名昭着【8】</li>\n</ul>\n<blockquote>\n<p>程序通常（至少）使用两种形式的数据：<br>1.在内存中，数据保存在对象，结构体，列表，数组，哈希表，树等中。 这些数据结构针<br>对CPU的高效访问和操作进行了优化（通常使用指针）。<br>2.如果要将数据写入文件，或通过网络发送，则必须将其编码（encode）为某种自包含的<br>字节序列（例如，JSON文档）。 由于每个进程都有自己独立的地址空间，一个进程中<br>的指针对任何其他进程都没有意义，所以这个字节序列表示会与通常在内存中使用的数<br>据结构完全不同 。</p>\n</blockquote>\n<blockquote>\n<p>语言特定的格式<br>许多编程语言都内建了将内存对象编码为字节序列的支持。例如，Java<br>有 java.io.Serializable  【1】，Ruby有 Marshal  【2】，Python有 pickle【3】等等。许多<br>第三方库也存在，例如 Kryo for Java  【4】。<br>这些编码库非常方便，可以用很少的额外代码实现内存对象的保存与恢复。但是它们也有一些深层次的问题：这类编码通常与特定的编程语言深度绑定，其他语言<br>很难读取这种数据。如果以这类编码存储或传输数据，那你就和这门语言绑死在一起了。并且很难将系统与其他组织的系统（可能用的是不同的语言）进行集成。<br>为了恢复相同对象类型的数据，解码过程需要实例化任意类的能力，这通常是安全问题的一个来源【5】：如果攻击者可以让应用程序解码任意的字节序列，他们<br>就能实例化任意的类，这会允许他们做可怕的事情，如远程执行任意代码【6,7】。在这些库中，数据版本控制通常是事后才考虑的。因为它们旨在快速简便地<br>对数据进行编码，所以往往忽略了前向后向兼容性带来的麻烦问题。效率（编码或解码所花费的CPU时间，以及编码结构的大小）往往也是事后才考虑的。<br>例如，Java的内置序列化由于其糟糕的性能和臃肿的编码而臭名昭着【8】。<br><strong>因此，除非临时使用，采用语言内置编码通常是一个坏主意。</strong></p>\n</blockquote>\n<h2 id=\"第二部分：分布式数据\"><a href=\"#第二部分：分布式数据\" class=\"headerlink\" title=\"第二部分：分布式数据\"></a>第二部分：分布式数据</h2><h3 id=\"第五章：复制\"><a href=\"#第五章：复制\" class=\"headerlink\" title=\"第五章：复制\"></a>第五章：复制</h3><h3 id=\"第六章：分区\"><a href=\"#第六章：分区\" class=\"headerlink\" title=\"第六章：分区\"></a>第六章：分区</h3><h3 id=\"第七章：事务\"><a href=\"#第七章：事务\" class=\"headerlink\" title=\"第七章：事务\"></a>第七章：事务</h3><h3 id=\"第八章：分布式系统的麻烦\"><a href=\"#第八章：分布式系统的麻烦\" class=\"headerlink\" title=\"第八章：分布式系统的麻烦\"></a>第八章：分布式系统的麻烦</h3><h3 id=\"第九章：一致性与共识\"><a href=\"#第九章：一致性与共识\" class=\"headerlink\" title=\"第九章：一致性与共识\"></a>第九章：一致性与共识</h3><hr>\n<h2 id=\"第三部分：派生数据\"><a href=\"#第三部分：派生数据\" class=\"headerlink\" title=\"第三部分：派生数据\"></a>第三部分：派生数据</h2><h3 id=\"第十章：批处理\"><a href=\"#第十章：批处理\" class=\"headerlink\" title=\"第十章：批处理\"></a>第十章：批处理</h3><h3 id=\"第十一章：流处理\"><a href=\"#第十一章：流处理\" class=\"headerlink\" title=\"第十一章：流处理\"></a>第十一章：流处理</h3><h3 id=\"第十二章：数据系统的未来\"><a href=\"#第十二章：数据系统的未来\" class=\"headerlink\" title=\"第十二章：数据系统的未来\"></a>第十二章：数据系统的未来</h3>","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"tianqiyu","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"https://tianqiyu119.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://me.csdn.net/jlh912008548","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>拜读大佬的书籍，把重点的语句做个笔记。</p>\n</blockquote>\n<hr>\n<p>书本内容：</p>\n<h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><blockquote>\n<ol>\n<li>近些年的软件工程，特别是服务器端和后端系统开发，大量关于数据存储和处理的时髦词汇涌现出来： <strong>NoSQL！大数据！Web-Scale！分片！最终一致性！<br>ACID！ CAP定理！云服务！MapReduce！实时！</strong></li>\n<li>而<strong>数据密集型应用</strong>（data-intensive applications）正在通过使用这些技术进步来推动可能性的边界。当一个应用被称为<strong>数据密集</strong>型的引用，<br>如果数据是其主要挑战（数据量，数据复杂度或数据变化速度）—— 与之相对的是<strong>计算密集型</strong>，即<strong>处理器速度</strong>是其瓶颈。</li>\n<li>在技术迅速变化的背后总是存在一些持续成立的原则，无论我们使用了特定工具的哪个版本。如果理解了这些原则，就可以领会这些工具的适用场景，如何充分<br>利用它们，以及如何避免其中的陷阱.</li>\n</ol>\n</blockquote>\n<h2 id=\"第一部分：数据系统的基石\"><a href=\"#第一部分：数据系统的基石\" class=\"headerlink\" title=\"第一部分：数据系统的基石\"></a>第一部分：数据系统的基石</h2><ol>\n<li>第一章将介绍本书使用的术语和方法。可靠性，可扩展性和可维护性 ，这些词汇到底意味着什么？如何实现这些目标？</li>\n<li>第二章将对几种不同的数据模型和查询语言进行比较。从程序员的角度看，这是数据库之间最明显的区别。不同的数据模型适用于不同的应用场景。</li>\n<li>第三章将深入存储引擎内部，研究数据库如何在磁盘上摆放数据。不同的存储引擎针对不同的负载进行优化，选择合适的存储引擎对系统性能有巨大影响。</li>\n<li>第四章将对几种不同的 数据编码进行比较。特别研究了这些格式在应用需求经常变化、模式需要随时间演变的环境中表现如何。</li>\n</ol>\n<h3 id=\"第一章：可靠性可，扩展性，可维护性\"><a href=\"#第一章：可靠性可，扩展性，可维护性\" class=\"headerlink\" title=\"第一章：可靠性可，扩展性，可维护性\"></a>第一章：可靠性可，扩展性，可维护性</h3><ul>\n<li>现今很多应用程序都是 <strong>数据密集型（data-intensive）</strong> 的，而非 <strong>计算密集型（compute-intensive）</strong> 的。因此CPU很少成为这类应用的瓶颈，<br>更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。一旦系统的负载被描述好，就可以研究当负载增加会发生什么。我们可以从两种角度来看：  <ul>\n<li>增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？</li>\n<li>增加负载参数并希望保持性能不变时，需要增加多少系统资源？<br>这两个问题都需要性能数据，所以让我们简单地看一下如何描述系统性能。<br>​对于Hadoop这样的<strong>批处理系统</strong>，通常关心的是<strong>吞吐量</strong>（throughput），即每秒可以处理的记录数量，或者在特定规模数据集上运行作业的总时间。<br>对于在线系统，通常更重要的是服务的<strong>响应时间</strong>（response time），即客户端发送请求到接收响应之间的时间。<br>使不断重复发送同样的请求，每次得到的响应时间也都会略有不同。现实世界的系统会处理各式各样的请求，响应时间可能会有很大差异。因此我们需要将<br><strong>响应时间</strong>视为一个可以测量的<strong>数值分布</strong>（distribution），<strong>而不是单个数值</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第二章：数据模型与查询语言\"><a href=\"#第二章：数据模型与查询语言\" class=\"headerlink\" title=\"第二章：数据模型与查询语言\"></a>第二章：数据模型与查询语言</h3><ul>\n<li>数据模型主要分为两种：<strong>关系模型</strong>(sql,典型的如mysql,oracle)与<strong>文档模型</strong>(noSql[Not Only SQL],典型的如mongo) </li>\n<li>采用NoSQL数据库的背后有几个驱动因素，其中包括：<ul>\n<li>需要比关系数据库更好的可扩展性，包括非常大的数据集或非常高的写入吞吐量</li>\n<li>相比商业数据库产品，免费和开源软件更受偏爱。</li>\n<li>关系模型不能很好地支持一些特殊的查询操作</li>\n<li>受挫于关系模型的限制性，渴望一种更具多动态性与表现力的数据模型</li>\n</ul>\n</li>\n<li>文档和关系数据库的融合:自2000年代中期以来，大多数关系数据库都已经开始支持文档结构：如json，xml格式的数据</li>\n<li>随着时间的推移，关系数据库和文档数据库似乎变得越来越相似，这是一件好事：数据模型相互补充 ，如果一个数据库能够处理类似文档的数据，<br>并能够对其执行关系查询，那么应用程序就可以使用最符合其需求的功能组合。</li>\n<li><p>关系模型和文档模型的混合是未来数据库一条很好的路线。</p>\n</li>\n<li><p>文档数据库有时称为无模式（schemaless），但这具有误导性，因为读取数据的代码通常假定某种结构——即存在隐式模式，但不由数据库强制执行。<br>一个更精确的术语是读时模式（schema-on-read）（数据的结构是隐含的，只有在数据被读取时才被解释），相应的是写时模式（schema-on-write）<br>（传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式）</p>\n</li>\n<li>模式变更的速度很慢，而且要求停运。它的这种坏名誉并不是完全应得的：大多数关系数据库系统可在几毫秒内执行 ALTER TABLE  语句。<br>MySQL是一个值得注意的例外，它执行 ALTER TABLE  时会复制整个表，这<strong>可能意味着在更改一个大型表时会花费几分钟甚至几个小时的停机<br>时间，尽管存在各种工具来解决这个限制</strong>。</li>\n<li><p>大型表上运行 UPDATE 语句在任何数据库上都可能会很慢，因为每一行都需要重写。要是不可接受的话，应用程序可以将 first_name  设置为默认值 NULL<br>，并在读取时再填充，就像使用文档数据库一样。</p>\n<blockquote>\n<p>SQL是一种声明式查询语言，而IMS和CODASYL使用命令式代码来查询数据库。那是什么意思？许多常用的编程语言是命令式的。例如，给定一个动物物种的列表，<br>返回列表中的鲨鱼可以这样写：<br>function getSharks() {<br>var sharks = [];<br>for (var i = 0; i &lt; animals.length; i++) {<br>if (animals[i].family === “Sharks”) {<br>sharks.push(animals[i]);<br>}<br>}<br>return sharks;<br>}<br>命令式语言告诉计算机以特定顺序执行某些操作。可以想象一下，逐行地遍历代码，评估条 件，更新变量，并决定是否再循环一遍。<br>在声明式查询语言（如SQL或关系代数）中，你只需指定所需数据的模式 - 结果必须符合哪些 条件，以及如何将数据转换（例如，排序，分组和集合）<br>但不是如何实现这一目标。数据库 系统的查询优化器决定使用哪些索引和哪些连接方法，以及以何种顺序执行查询的各个部分。</p>\n</blockquote>\n</li>\n<li><p>声明式查询语言是迷人的，因为它通常比命令式API更加简洁和容易。但更重要的是，它还隐<br>藏了数据库引擎的实现细节，这使得数据库系统可以在无需对查询做任何更改的情况下进行<br>性能提升。  </p>\n</li>\n<li><p>最后，声明式语言往往适合并行执行。现在，CPU的速度通过内核的增加变得更快，而不是<br>以比以前更高的时钟速度运行【31】。命令代码很难在多个内核和多个机器之间并行化，因<br>为它指定了指令必须以特定顺序执行。声明式语言更具有并行执行的潜力，因为它们仅指定<br>结果的模式，而不指定用于确定结果的算法。在适当情况下，数据库可以自由使用查询语言<br>的并行实现</p>\n</li>\n<li><p>我们会研究两大类存储引擎：日志结构（log-structured）的存储引擎，以及面向页面（page-oriented）的存储引擎（例如B树）。</p>\n</li>\n<li>冻结段的合并和压缩可以在后台线程中完成，在进行时，我们仍然可以继续使用旧的段文件来正常提供读写请求。合并过程完成后，我们将读取请求转换为<br>使用新的合并段 而不是旧段然后可以简单地删除旧的段文件。</li>\n<li><strong>简而言之，一些真正实施中重要的问题是:</strong><ul>\n<li><strong>文件格式</strong>:</li>\n<li><strong>删除记录</strong>:</li>\n<li><strong>崩溃恢复</strong>:</li>\n<li><strong>部分写入记录</strong>:</li>\n<li><strong>并发控制</strong>: 乍一看，只有追加日志看起来很浪费：为什么不更新文件，用新值覆盖旧值？但是只能追加设计的原因有几个:<ul>\n<li>追加和分段合并是顺序写入操作，通常比随机写入快得多，尤其是在磁盘旋转硬盘上。</li>\n<li>在某种程度上，顺序写入在基于闪存的固态硬盘（SSD）上也是优选的【4】。我们将在</li>\n<li>第83页的“比较B-树和LSM-树”中进一步讨论这个问题。</li>\n<li>如果段文件是附加的或不可变的，并发和崩溃恢复就简单多了。例如，您不必担心在覆</li>\n<li>盖值时发生崩溃的情况，而将包含旧值和新值的一部分的文件保留在一起。</li>\n<li>合并旧段可以避免数据文件随着时间的推移而分散的问题。  </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>与往常一样，大量的细节使得存储引擎在实践中表现良好。例如，当查找数据库中<strong>不存在的键</strong>时，LSM树算法可能会很慢：您必须检查内存表，然后将这些段一<br>直回到最老的（这可能必须从磁盘读取每一个），然后才能确定键不存在。为了优化这种访问，存储引擎通常使用额外的Bloom过滤器</li>\n<li>布隆过滤器是用于近似集合内容的内存高效数据结构，它可以告诉您数据库中是否出现键，从而为不存在的键节省许多不必要的磁盘读取操作。<br>(布隆过滤有这样的特性：没有那就一定是没有，有，有百分之95%以上的几率是有的，用很小的错误率，和很小的空间获得特别大的效率)</li>\n<li>即使有许多微妙的东西，LSM树的基本思想 —— 保存一系列在后台合并的SSTables —— 简 单而有效。即使数据集比可用内存大得多，它仍能继续正常工作。<br>由于数据按排序顺序存储， 因此可以高效地执行范围查询（扫描所有高于某些最小值和最高值的所有键），并且因 为磁盘写入是连续的，所以LSM树可以支持<br>非常高的写入吞吐量。</li>\n<li>在B树的一个页面中对子页面的引用的数量称为分支因子。例如，在图3-6中，分支因子是 6 。在实践中，分支因子取决于存储页面参考和范围边界所需的空间量，<br>但通常是几百个。</li>\n<li>日志结构化的方法在这方面更简单，因为它们在后台进行所有的合并，而不会干扰传入的查询，并且不时地将旧的分段原子交换为新的分段。</li>\n<li>这种差异在磁性硬盘驱动器上尤其重要，顺序写入比随机写入快得多。</li>\n<li>在许多关系数据库中，事务隔离是通过在键范围上使用锁来实现的，在B树索引中，这些锁可以直接连接到树</li>\n<li>在新的数据存储中，<strong>日志结构化索引</strong>变得越来越流行。没有快速和容易的规则来确定哪种类型的存储引擎对你的场景更好，所以值得进行一些经验上的测试.</li>\n<li>索引中的关键字是查询搜索的内容，但是该值可以是以下两种情况之一：它可以是所讨论的实际行（文档，顶点），也可以是对存储在别处的行的引用。在后一种<br>情况下，行被存储的 地方被称为堆文件（heap file），并且存储的数据没有特定的顺序（它可以是仅附加的，或 者可以跟踪被删除的行以便用新数据覆盖它们后来）</li>\n<li>在聚集索引（在索引中存储所有行数据）和非聚集索引（仅在索引中存储对数据的引用）之间的折衷被称为包含列的索引或覆盖索引，其存储表的一部分在索引内。<br>这允许通过单独使用索引来回答一些查询（这种情况叫做：索引覆盖（cover）了查询）</li>\n<li>某些内存中的键值存储（如Memcached）仅用于缓存，在重新启动计算机时丢失的数据是可 以接受的。但其他内存数据库的目标是持久性，可以通过特殊的硬件<br>（例如电池供电的 RAM），将更改日志写入磁盘，将定时快照写入磁盘或通过复制内存来实现，记忆状态到其他机器。<blockquote>\n<p>诸如VoltDB，MemSQL和Oracle TimesTen等产品是具有关系模型的内存数据库，供应商声称，通过消除与管理磁盘上的数据结构相关的所有开销，<br>他们可以提供巨大的性能改进【41,42】。 RAM Cloud是一个开源的内存键值存储器，具有持久性（对存储器中的数据以及磁盘上的数据使用日志结构化方法）<br>【43】。 Redis和Couchbase通过异步写入磁盘提供了较弱的持久性。</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>磁盘的顺序读速度能打到在100MB/S上下使用列式存储，分析的时候，可以只扫描需要的那部分数据的时候，减少CPU和磁盘的访问量。同时面向列的存储通常<br>很适合压缩，使用压缩，可以综合CPU和磁盘，发挥最大的效能。<br>面向行的存储将每一行保存在一个地方（在堆文件或聚簇索引中）<br>在OLTP方面，我们看到了来自两大主流学派的存储引擎： 日志结构学派<br>只允许附加到文件和删除过时的文件，但不会更新已经写入的文件。 Bitcask，SSTables，LSM树，LevelDB，Cassandra，HBase，Lucene等都属于这个组。<br>原地更新学派将磁盘视为一组可以覆盖的固定大小的页面。 B树是这种哲学的最大的例子，被用在所有主要的关系数据库中，还有许多非关系数据库。</p>\n</blockquote>\n<h3 id=\"第三章：存储与检索\"><a href=\"#第三章：存储与检索\" class=\"headerlink\" title=\"第三章：存储与检索\"></a>第三章：存储与检索</h3><blockquote>\n<p>日志结构的存储引擎是相对较新的发展。他们的主要想法是，他们系统地将随机访问写入顺<br>序写入磁盘，由于硬盘驱动器和固态硬盘的性能特点，可以实现更高的写入吞吐量。在完成<br>OLTP方面，我们通过一些更复杂的索引结构和为保留所有数据而优化的数据库做了一个简短<br>的介绍。 然后，我们从存储引擎的内部绕开，看看典型数据仓库的高级架构。这一背景说明了为什么<br>分析工作负载与OLTP差别很大：当您的查询需要在大量行中顺序扫描时，索引的相关性就会<br>降低很多。相反，非常紧凑地编码数据变得非常重要，以最大限度地减少查询需要从磁盘读<br>取的数据量。我们讨论了列式存储如何帮助实现这一目标。<br>作为一名应用程序开发人员，如果您掌握了有关存储引擎内部的知识，那么您就能更好地了<br>解哪种工具最适合您的特定应用程序。 如果您需要调整数据库的调整参数，这种理解可以让<br>您设想一个更高或更低的值可能会产生什么效果。<br>尽管本章不能让你成为一个特定存储引擎的调参专家，但它至少有大概率使你有了足够的概<br>念与词汇储备去读懂数据库的文档，从而选择合适的数据库。</p>\n</blockquote>\n<blockquote>\n</blockquote>\n<ul>\n<li>作为程序员，为什么要关心数据库内部存储与检索的机理？你可能不会去从头开始实现自己的存储引擎，但是你确实需要从许多可用的存储引擎中选择一个合适的。<br>而且为了协调存储引擎以适配应用工作负载，你也需要大致了解存储引擎在底层究竟做什么。</li>\n<li><p>特别需要注意，针对事务性负载和分析性负载优化的存储引擎之间存在巨大差异。稍后我们<br>将在 “事务处理还是分析？” 一节中探讨这一区别，并在 “列存储”中讨论一系列针对分析优化存储引擎。   </p>\n<blockquote>\n<p>世界上最简单的数据库可以用两个Bash函数实现：<br>#!/bin/bash<br>db_set () {<br>echo “$1,$2” &gt;&gt; database<br>}<br>db_get () {<br>grep “^$1,” database | sed -e “s/^$1,//“ | tail -n 1<br>}<br>这两个函数实现了键值存储的功能。执行  db_set key value  ，会将 键（key）和值<br>（value） 存储在数据库中。</p>\n</blockquote>\n</li>\n<li><p>db_set<br>函数对于极其简单的场景其实有非常好的性能，因为在文件尾部追加写入通常是非常高效的。与<br>db_set 做的事情类似，许多数据库在内部使用了日志（log），也就是一个仅追<br>加（append-only）的数据文件。真正的数据库有更多的问题需要处理（如并发控制，回收<br>磁盘空间以避免日志无限增长，处理错误与部分写入的记录），但基本原理是一样的。日志<br>极其有用，我们还将在本书的其它部分重复见到它好几次。</p>\n<blockquote>\n<p>日志（log）这个词通常指应用日志：即应用程序输出的描述发生事情的文本。本书在更<br>普遍的意义下使用日志这一词：一个仅追加的记录序列。它可能压根就不是给人类看<br>的，使用二进制格式，并仅能由其他程序读取。 </p>\n</blockquote>\n</li>\n<li><p>索引背后的大致思想是，保存一些额外的元数据作为路<br>标，帮助你找到想要的数据。如果您想在同一份数据中以几种不同的方式进行搜索，那么你<br>也许需要不同的索引，建在数据的不同部分上。</p>\n</li>\n<li><p>索引是从主数据衍生的附加（additional）结构。许多数据库允许添加与删除索引，这不会影<br>响数据的内容，它只影响查询的性能。维护额外的结构会产生开销，特别是在写入时。写入<br>性能很难超过简单地追加写入文件，因为追加写入是最简单的写入操作。任何类型的索引通<br>常都会减慢写入速度，因为每次写入数据时都需要更新索引。 </p>\n<blockquote>\n<p>这是存储系统中一个重要的权衡：精心选择的索引加快了读查询的速度，但是每个索引都会<br>拖慢写入速度。因为这个原因，数据库默认并不会索引所有的内容，而需要你（程序员或<br>DBA）通过对应用查询模式的了解来手动选择索引。你可以选择能为应用带来最大收益，同<br>时又不会引入超出必要开销的索引。</p>\n</blockquote>\n</li>\n<li><p>哈希索引: 很常见与字典（dictionary）类型非常相似   </p>\n</li>\n<li>所以如何避免最终用完磁盘空间？一种好的解决<br>方案是，将日志分为特定大小的段，当日志增长到特定尺寸时关闭当前段文件，并开始写入<br>一个新的段文件。然后，我们就可以对这些段进行压缩（compaction），如图3-2所示。压<br>缩意味着在日志中丢弃重复的键，只保留每个键的最近更新。</li>\n</ul>\n<blockquote>\n<p>乍一看，只有追加日志看起来很浪费：为什么不更新文件，用新值覆盖旧值？但是只能追加设计的原因有几个：</p>\n<ul>\n<li>追加和分段合并是顺序写入操作，通常比随机写入快得多，尤其是在磁盘旋转硬盘上。</li>\n<li>在某种程度上，顺序写入在基于闪存的固态硬盘（SSD）上也是优选的【4】。我们将在</li>\n<li>第83页的“比较B-树和LSM-树”中进一步讨论这个问题。</li>\n<li>如果段文件是附加的或不可变的，并发和崩溃恢复就简单多了。例如，您不必担心在覆</li>\n<li>盖值时发生崩溃的情况，而将包含旧值和新值的一部分的文件保留在一起。</li>\n<li>合并旧段可以避免数据文件随着时间的推移而分散的问题。 </li>\n</ul>\n</blockquote>\n<blockquote>\n<p>但是，哈希表索引也有局限性：<br> <strong>散列表必须能放进内存</strong>如果你有非常多的键，那真是倒霉。原则上可以在磁盘上保留一个哈希映射，不幸的是 <strong>磁盘哈希映射很难表现优秀</strong>。它需要<br> <strong>大量的随机访问I/O</strong>，当它变<strong>满时增长是很昂贵的</strong>， 并且解决散列冲突需要很多的逻辑 范围查询效率不高。例如，您无法轻松扫描kitty00000<br> 和kitty99999 之间的所有键—您 必须在散列映射中单独查找每个键。 </p>\n</blockquote>\n<h3 id=\"第四章：编码与演化\"><a href=\"#第四章：编码与演化\" class=\"headerlink\" title=\"第四章：编码与演化\"></a>第四章：编码与演化</h3><blockquote>\n<p>本章中将介绍几种编码数据的格式，包括 JSON，XML，Protocol Buffers，Thrift和 Avro。</p>\n</blockquote>\n<ul>\n<li>需要在两种表示之间进行某种类型的翻译。 从内存中表示到字节序列的转换称为编码（Encoding）（也称为序列化（serialization）<br>或编组（marshalling）），反过来称为解码<br>（Decoding） （解析（Parsing），反序列化（deserialization），反编组() unmarshalling）） 。</li>\n<li>Java的内置序列化由于其糟糕的性能和臃肿的编码而臭名昭着【8】</li>\n</ul>\n<blockquote>\n<p>程序通常（至少）使用两种形式的数据：<br>1.在内存中，数据保存在对象，结构体，列表，数组，哈希表，树等中。 这些数据结构针<br>对CPU的高效访问和操作进行了优化（通常使用指针）。<br>2.如果要将数据写入文件，或通过网络发送，则必须将其编码（encode）为某种自包含的<br>字节序列（例如，JSON文档）。 由于每个进程都有自己独立的地址空间，一个进程中<br>的指针对任何其他进程都没有意义，所以这个字节序列表示会与通常在内存中使用的数<br>据结构完全不同 。</p>\n</blockquote>\n<blockquote>\n<p>语言特定的格式<br>许多编程语言都内建了将内存对象编码为字节序列的支持。例如，Java<br>有 java.io.Serializable  【1】，Ruby有 Marshal  【2】，Python有 pickle【3】等等。许多<br>第三方库也存在，例如 Kryo for Java  【4】。<br>这些编码库非常方便，可以用很少的额外代码实现内存对象的保存与恢复。但是它们也有一些深层次的问题：这类编码通常与特定的编程语言深度绑定，其他语言<br>很难读取这种数据。如果以这类编码存储或传输数据，那你就和这门语言绑死在一起了。并且很难将系统与其他组织的系统（可能用的是不同的语言）进行集成。<br>为了恢复相同对象类型的数据，解码过程需要实例化任意类的能力，这通常是安全问题的一个来源【5】：如果攻击者可以让应用程序解码任意的字节序列，他们<br>就能实例化任意的类，这会允许他们做可怕的事情，如远程执行任意代码【6,7】。在这些库中，数据版本控制通常是事后才考虑的。因为它们旨在快速简便地<br>对数据进行编码，所以往往忽略了前向后向兼容性带来的麻烦问题。效率（编码或解码所花费的CPU时间，以及编码结构的大小）往往也是事后才考虑的。<br>例如，Java的内置序列化由于其糟糕的性能和臃肿的编码而臭名昭着【8】。<br><strong>因此，除非临时使用，采用语言内置编码通常是一个坏主意。</strong></p>\n</blockquote>\n<h2 id=\"第二部分：分布式数据\"><a href=\"#第二部分：分布式数据\" class=\"headerlink\" title=\"第二部分：分布式数据\"></a>第二部分：分布式数据</h2><h3 id=\"第五章：复制\"><a href=\"#第五章：复制\" class=\"headerlink\" title=\"第五章：复制\"></a>第五章：复制</h3><h3 id=\"第六章：分区\"><a href=\"#第六章：分区\" class=\"headerlink\" title=\"第六章：分区\"></a>第六章：分区</h3><h3 id=\"第七章：事务\"><a href=\"#第七章：事务\" class=\"headerlink\" title=\"第七章：事务\"></a>第七章：事务</h3><h3 id=\"第八章：分布式系统的麻烦\"><a href=\"#第八章：分布式系统的麻烦\" class=\"headerlink\" title=\"第八章：分布式系统的麻烦\"></a>第八章：分布式系统的麻烦</h3><h3 id=\"第九章：一致性与共识\"><a href=\"#第九章：一致性与共识\" class=\"headerlink\" title=\"第九章：一致性与共识\"></a>第九章：一致性与共识</h3><hr>\n<h2 id=\"第三部分：派生数据\"><a href=\"#第三部分：派生数据\" class=\"headerlink\" title=\"第三部分：派生数据\"></a>第三部分：派生数据</h2><h3 id=\"第十章：批处理\"><a href=\"#第十章：批处理\" class=\"headerlink\" title=\"第十章：批处理\"></a>第十章：批处理</h3><h3 id=\"第十一章：流处理\"><a href=\"#第十一章：流处理\" class=\"headerlink\" title=\"第十一章：流处理\"></a>第十一章：流处理</h3><h3 id=\"第十二章：数据系统的未来\"><a href=\"#第十二章：数据系统的未来\" class=\"headerlink\" title=\"第十二章：数据系统的未来\"></a>第十二章：数据系统的未来</h3>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck0hkxqgs0002ektv1n7ny2jx","category_id":"ck0hkxqh80007ektvm7vcvndt","_id":"ck0hkxqhm000hektvxwad1u82"},{"post_id":"ck0hkxqh30005ektv3wgz6qi7","category_id":"ck0hkxqhh000dektvtn5sb4j1","_id":"ck0hkxqhp000oektvtqzqysew"},{"post_id":"ck0hkxqhn000kektve6mjwiqr","category_id":"ck0hkxqhs000qektveb55ytkp","_id":"ck0hkxqhy000yektv4jlclb3p"},{"post_id":"ck0hkxqhv000uektvlsn0x6tl","category_id":"ck0hkxqhs000qektveb55ytkp","_id":"ck0hkxqhz0010ektvgm8mbjdz"},{"post_id":"ck0hkxqho000nektvzjd7alhy","category_id":"ck0hkxqhw000vektvhanhasfu","_id":"ck0hkxqi00013ektvot8de4gd"},{"post_id":"ck0hkxqhi000eektv890au0hl","category_id":"ck0hkxqhm000jektv6d2z55uk","_id":"ck0hkxqi10016ektvzyzpx7f2"},{"post_id":"ck0hkxqhi000eektv890au0hl","category_id":"ck0hkxqhz000zektv28cw5m84","_id":"ck0hkxqi20017ektvefbq6nwm"},{"post_id":"ck0hkxqiy0024ektvdrkcfdoq","category_id":"ck0hkxqhh000dektvtn5sb4j1","_id":"ck0hkxqj10026ektvq6riuz0f"},{"post_id":"ck0hkxqmj0028ektvimhyon4d","category_id":"ck0hkxqmk0029ektvio96apm6","_id":"ck0hkxqml002cektvpnwj4p1n"}],"PostTag":[{"post_id":"ck0hkxqgj0000ektvbzvxya7j","tag_id":"ck0hkxqgz0004ektve523hcfk","_id":"ck0hkxqhm000iektv248bo7gx"},{"post_id":"ck0hkxqgj0000ektvbzvxya7j","tag_id":"ck0hkxqhe000bektv6zse4szg","_id":"ck0hkxqho000lektvtwub1k1z"},{"post_id":"ck0hkxqgs0002ektv1n7ny2jx","tag_id":"ck0hkxqhk000fektvau7gt1dq","_id":"ck0hkxqhu000tektvkcf07r55"},{"post_id":"ck0hkxqgs0002ektv1n7ny2jx","tag_id":"ck0hkxqho000mektvt3vk0n83","_id":"ck0hkxqhx000wektvfws910v0"},{"post_id":"ck0hkxqh30005ektv3wgz6qi7","tag_id":"ck0hkxqhs000rektv10rh673n","_id":"ck0hkxqi00012ektvh48xe9g0"},{"post_id":"ck0hkxqh30005ektv3wgz6qi7","tag_id":"ck0hkxqhx000xektvwyrcmusf","_id":"ck0hkxqi10014ektvp7c5xmx0"},{"post_id":"ck0hkxqh90008ektvxjfhi4qq","tag_id":"ck0hkxqhz0011ektvbvbi7m7v","_id":"ck0hkxqi30019ektvuqcjzs71"},{"post_id":"ck0hkxqh90008ektvxjfhi4qq","tag_id":"ck0hkxqi10015ektvpfadagkk","_id":"ck0hkxqi3001aektvxs9g8yun"},{"post_id":"ck0hkxqhb000aektvbf2vuz6o","tag_id":"ck0hkxqi20018ektvnoc8cflx","_id":"ck0hkxqi4001cektv09v1vc4p"},{"post_id":"ck0hkxqhi000eektv890au0hl","tag_id":"ck0hkxqi3001bektvwwjv0x9h","_id":"ck0hkxqi6001gektva6sengzl"},{"post_id":"ck0hkxqhi000eektv890au0hl","tag_id":"ck0hkxqi4001dektvt5wfg9ej","_id":"ck0hkxqi6001hektvu729dg1b"},{"post_id":"ck0hkxqhi000eektv890au0hl","tag_id":"ck0hkxqi4001eektvc6l28mms","_id":"ck0hkxqi7001jektv91g0s5sf"},{"post_id":"ck0hkxqhl000gektvu7hqyanu","tag_id":"ck0hkxqi20018ektvnoc8cflx","_id":"ck0hkxqi7001kektvfa9saabz"},{"post_id":"ck0hkxqhn000kektve6mjwiqr","tag_id":"ck0hkxqi7001iektvmwrj7smf","_id":"ck0hkxqi8001mektvvviytznw"},{"post_id":"ck0hkxqho000nektvzjd7alhy","tag_id":"ck0hkxqi3001bektvwwjv0x9h","_id":"ck0hkxqi9001oektvdcbz90dl"},{"post_id":"ck0hkxqhq000pektva04us2wi","tag_id":"ck0hkxqi8001nektvhq60v1m6","_id":"ck0hkxqia001rektvz0fymchm"},{"post_id":"ck0hkxqhq000pektva04us2wi","tag_id":"ck0hkxqi7001iektvmwrj7smf","_id":"ck0hkxqia001sektvwckw7hzk"},{"post_id":"ck0hkxqht000sektvlkvkkeww","tag_id":"ck0hkxqi9001qektvr4cx0rql","_id":"ck0hkxqid001yektvfi0qwcll"},{"post_id":"ck0hkxqht000sektvlkvkkeww","tag_id":"ck0hkxqia001tektvez61ec9x","_id":"ck0hkxqid001zektv8dsqzspq"},{"post_id":"ck0hkxqht000sektvlkvkkeww","tag_id":"ck0hkxqib001uektv689bd5gj","_id":"ck0hkxqid0020ektvv6pyxg54"},{"post_id":"ck0hkxqht000sektvlkvkkeww","tag_id":"ck0hkxqib001vektvv23do7pa","_id":"ck0hkxqid0021ektvyxy701zn"},{"post_id":"ck0hkxqht000sektvlkvkkeww","tag_id":"ck0hkxqic001wektv54g3ruri","_id":"ck0hkxqid0022ektv3x0br5v2"},{"post_id":"ck0hkxqhv000uektvlsn0x6tl","tag_id":"ck0hkxqi7001iektvmwrj7smf","_id":"ck0hkxqie0023ektv444g8int"},{"post_id":"ck0hkxqiy0024ektvdrkcfdoq","tag_id":"ck0hkxqj00025ektvn14pkltc","_id":"ck0hkxqj10027ektva7rp0nda"},{"post_id":"ck0hkxqmj0028ektvimhyon4d","tag_id":"ck0hkxqmk002aektvm9wlwcvl","_id":"ck0hkxqml002bektvkuhdklzi"}],"Tag":[{"name":"springFramework3.1","_id":"ck0hkxqgz0004ektve523hcfk"},{"name":"rabbitMq","_id":"ck0hkxqhe000bektv6zse4szg"},{"name":"源码","_id":"ck0hkxqhk000fektvau7gt1dq"},{"name":"springMVC","_id":"ck0hkxqho000mektvt3vk0n83"},{"name":"算法","_id":"ck0hkxqhs000rektv10rh673n"},{"name":"leetcode","_id":"ck0hkxqhx000xektvwyrcmusf"},{"name":"springboot","_id":"ck0hkxqhz0011ektvbvbi7m7v"},{"name":"springCloud","_id":"ck0hkxqi10015ektvpfadagkk"},{"name":"正则","_id":"ck0hkxqi20018ektvnoc8cflx"},{"name":"数据结构","_id":"ck0hkxqi3001bektvwwjv0x9h"},{"name":"mysql","_id":"ck0hkxqi4001dektvt5wfg9ej"},{"name":"索引","_id":"ck0hkxqi4001eektvc6l28mms"},{"name":"分布式","_id":"ck0hkxqi7001iektvmwrj7smf"},{"name":"paxos","_id":"ck0hkxqi8001nektvhq60v1m6"},{"name":"多线程","_id":"ck0hkxqi9001qektvr4cx0rql"},{"name":"并发","_id":"ck0hkxqia001tektvez61ec9x"},{"name":"dubbo","_id":"ck0hkxqib001uektv689bd5gj"},{"name":"callable","_id":"ck0hkxqib001vektvv23do7pa"},{"name":"future","_id":"ck0hkxqic001wektv54g3ruri"},{"name":"Algorithm","_id":"ck0hkxqj00025ektvn14pkltc"},{"name":"阅读","_id":"ck0hkxqmk002aektvm9wlwcvl"}]}}
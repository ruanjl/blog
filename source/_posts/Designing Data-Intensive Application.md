---
title: 读 Designing Data-Intensive Application
date: 2019-02-13 16:57:48
tags: 阅读
categories: [设计思想]
---

## 前言
> 拜读大佬的书籍，做个笔记，记录下重点的语句。
---
书本内容：
## 序言
>1. 近些年的软件工程，特别是服务器端和后端系统开发，大量关于数据存储和处理的时髦词汇涌现出来： **NoSQL！大数据！Web-Scale！分片！最终一致性！
ACID！ CAP定理！云服务！MapReduce！实时！**
2. 而**数据密集型应用**（data-intensive applications）正在通过使用这些技术进步来推动可能性的边界。当一个应用被称为**数据密集**型的引用，
如果数据是其主要挑战（数据量，数据复杂度或数据变化速度）—— 与之相对的是**计算密集型**，即**处理器速度**是其瓶颈。
3. 在技术迅速变化的背后总是存在一些持续成立的原则，无论我们使用了特定工具的哪个版本。如果理解了这些原则，就可以领会这些工具的适用场景，如何充分
利用它们，以及如何避免其中的陷阱.

## 第一部分：数据系统的基石
1. 第一章将介绍本书使用的术语和方法。可靠性，可扩展性和可维护性 ，这些词汇到底意味着什么？如何实现这些目标？
2. 第二章将对几种不同的数据模型和查询语言进行比较。从程序员的角度看，这是数据库之间最明显的区别。不同的数据模型适用于不同的应用场景。
3. 第三章将深入存储引擎内部，研究数据库如何在磁盘上摆放数据。不同的存储引擎针对不同的负载进行优化，选择合适的存储引擎对系统性能有巨大影响。
4. 第四章将对几种不同的 数据编码进行比较。特别研究了这些格式在应用需求经常变化、模式需要随时间演变的环境中表现如何。

### 第一章：可靠性可，扩展性，可维护性
- 现今很多应用程序都是 **数据密集型（data-intensive）** 的，而非 **计算密集型（compute-intensive）** 的。因此CPU很少成为这类应用的瓶颈，
更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。一旦系统的负载被描述好，就可以研究当负载增加会发生什么。我们可以从两种角度来看：  
    - 增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？
    - 增加负载参数并希望保持性能不变时，需要增加多少系统资源？
这两个问题都需要性能数据，所以让我们简单地看一下如何描述系统性能。
​ 对于Hadoop这样的**批处理系统**，通常关心的是**吞吐量**（throughput），即每秒可以处理的记录数量，或者在特定规模数据集上运行作业的总时间iii。
对于在线系统，通常更重要的是服务的**响应时间**（response time），即客户端发送请求到接收响应之间的时间。

​ 即使不断重复发送同样的请求，每次得到的响应时间也都会略有不同。现实世界的系统会处理各式各样的请求，响应时间可能会有很大差异。因此我们需要将
**响应时间**视为一个可以测量的**数值分布**（distribution），**而不是单个数值**

### 第二章：数据模型与查询语言
- 数据模型主要分为两种：**关系模型**(sql,典型的如mysql,oracle)与**文档模型**(noSql[Not Only SQL],典型的如mongo) 
- 采用NoSQL数据库的背后有几个驱动因素，其中包括：
  - 需要比关系数据库更好的可扩展性，包括非常大的数据集或非常高的写入吞吐量
  - 相比商业数据库产品，免费和开源软件更受偏爱。
  - 关系模型不能很好地支持一些特殊的查询操作
  - 受挫于关系模型的限制性，渴望一种更具多动态性与表现力的数据模型
- 文档和关系数据库的融合:自2000年代中期以来，大多数关系数据库都已经开始支持文档结构：如json，xml格式的数据
- 随着时间的推移，关系数据库和文档数据库似乎变得越来越相似，这是一件好事：数据模型
  相互补充 ，如果一个数据库能够处理类似文档的数据，并能够对其执行关系查询，那么应用
  程序就可以使用最符合其需求的功能组合。
- 关系模型和文档模型的混合是未来数据库一条很好的路线。

- 文档数据库有时称为无模式（schemaless），但这具有误导性，因为读取数据的代码通常假定某种结构——即存在隐式模式，但不由数据库强制执行【20】。
一个更精确的术语是读时模式（schema-on-read）（数据的结构是隐含的，只有在数据被读取时才被解释），相应的是写时模式（schema-on-write）
（传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式）【21】  
-  模式变更的速度很慢，而且要求停运。它的这种坏名誉并不是完全应得的：大多数关系数据库系统可在几毫秒内执行 ALTER TABLE  语句。
MySQL是一个值得注意的例外，它执行 ALTER TABLE  时会复制整个表，这**可能意味着在更改一个大型表时会花费几分钟甚至几个小时的停机
时间，尽管存在各种工具来解决这个限制【24,25,26】**。
- 大型表上运行 UPDATE 语句在任何数据库上都可能会很慢，因为每一行都需要重写。要是不可接受的话，应用程序可以将 first_name  设置为默认值 NULL
  ，并在读取时再填充，就像使用文档数据库一样。
> SQL是一种声明式查询语言，而IMS和CODASYL使用命令式代码来查询数据库。那是什么意思？
许多常用的编程语言是命令式的。例如，给定一个动物物种的列表，返回列表中的鲨鱼可以
这样写：
function getSharks() {
var sharks = [];
for (var i = 0; i < animals.length; i++) {
if (animals[i].family === "Sharks") {
sharks.push(animals[i]);
}
}
return sharks;
}  
命令式语言告诉计算机以特定顺序执行某些操作。可以想象一下，逐行地遍历代码，评估条
件，更新变量，并决定是否再循环一遍。
在声明式查询语言（如SQL或关系代数）中，你只需指定所需数据的模式 - 结果必须符合哪些
条件，以及如何将数据转换（例如，排序，分组和集合） - 但不是如何实现这一目标。数据库
系统的查询优化器决定使用哪些索引和哪些连接方法，以及以何种顺序执行查询的各个部
分。

- 声明式查询语言是迷人的，因为它通常比命令式API更加简洁和容易。但更重要的是，它还隐
藏了数据库引擎的实现细节，这使得数据库系统可以在无需对查询做任何更改的情况下进行
性能提升。  

- 最后，声明式语言往往适合并行执行。现在，CPU的速度通过内核的增加变得更快，而不是
以比以前更高的时钟速度运行【31】。命令代码很难在多个内核和多个机器之间并行化，因
为它指定了指令必须以特定顺序执行。声明式语言更具有并行执行的潜力，因为它们仅指定
结果的模式，而不指定用于确定结果的算法。在适当情况下，数据库可以自由使用查询语言
的并行实现【32】。

### 第三章：存储与检索
- 作为程序员，为什么要关心数据库内部存储与检索的机理？你可能不会去从头开始实现自己的存储引擎，但是你确实需要从许多可用的存储引擎中选择一个合适的。
而且为了协调存储引擎以适配应用工作负载，你也需要大致了解存储引擎在底层究竟做什么。
- 特别需要注意，针对事务性负载和分析性负载优化的存储引擎之间存在巨大差异。稍后我们
  将在 “事务处理还是分析？” 一节中探讨这一区别，并在 “列存储”中讨论一系列针对分析优化存储引擎。   
>世界上最简单的数据库可以用两个Bash函数实现：
> \#!/bin/bash
> db_set () {
 echo "$1,$2" >> database
 }
 db_get () {
 grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
 }
 这两个函数实现了键值存储的功能。执行  db_set key value  ，会将 键（key）和值
 （value） 存储在数据库中。
   
- db_set  函数对于极其简单的场景其实有非常好的性能，因为在文件尾部追加写入通常是非常高效的。   
与 db_set  做的事情类似，许多数据库在内部使用了日志（log），也就是一个仅追
加（append-only）的数据文件。真正的数据库有更多的问题需要处理（如并发控制，回收
磁盘空间以避免日志无限增长，处理错误与部分写入的记录），但基本原理是一样的。日志
极其有用，我们还将在本书的其它部分重复见到它好几次。
>日志（log）这个词通常指应用日志：即应用程序输出的描述发生事情的文本。本书在更
 普遍的意义下使用日志这一词：一个仅追加的记录序列。它可能压根就不是给人类看
 的，使用二进制格式，并仅能由其他程序读取。 
 
- 索引背后的大致思想是，保存一些额外的元数据作为路
  标，帮助你找到想要的数据。如果您想在同一份数据中以几种不同的方式进行搜索，那么你
  也许需要不同的索引，建在数据的不同部分上。
  
- 索引是从主数据衍生的附加（additional）结构。许多数据库允许添加与删除索引，这不会影
响数据的内容，它只影响查询的性能。维护额外的结构会产生开销，特别是在写入时。写入
性能很难超过简单地追加写入文件，因为追加写入是最简单的写入操作。任何类型的索引通
常都会减慢写入速度，因为每次写入数据时都需要更新索引。 
> 这是存储系统中一个重要的权衡：精心选择的索引加快了读查询的速度，但是每个索引都会
  拖慢写入速度。因为这个原因，数据库默认并不会索引所有的内容，而需要你（程序员或
  DBA）通过对应用查询模式的了解来手动选择索引。你可以选择能为应用带来最大收益，同
  时又不会引入超出必要开销的索引。

- 哈希索引: 很常见与字典（dictionary）类型非常相似   
- 所以如何避免最终用完磁盘空间？一种好的解决
  方案是，将日志分为特定大小的段，当日志增长到特定尺寸时关闭当前段文件，并开始写入
  一个新的段文件。然后，我们就可以对这些段进行压缩（compaction），如图3-2所示。压
  缩意味着在日志中丢弃重复的键，只保留每个键的最近更新。
  
> 乍一看，只有追加日志看起来很浪费：为什么不更新文件，用新值覆盖旧值？但是只能追加设计的原因有几个：
- 追加和分段合并是顺序写入操作，通常比随机写入快得多，尤其是在磁盘旋转硬盘上。
- 在某种程度上，顺序写入在基于闪存的固态硬盘（SSD）上也是优选的【4】。我们将在
- 第83页的“比较B-树和LSM-树”中进一步讨论这个问题。
- 如果段文件是附加的或不可变的，并发和崩溃恢复就简单多了。例如，您不必担心在覆
- 盖值时发生崩溃的情况，而将包含旧值和新值的一部分的文件保留在一起。
- 合并旧段可以避免数据文件随着时间的推移而分散的问题。 

>但是，哈希表索引也有局限性：
 散列表必须能放进内存
 如果你有非常多的键，那真是倒霉。原则上可以在磁盘上保留一个哈希映射，不幸的是
 磁盘哈希映射很难表现优秀。它需要大量的随机访问I/O，当它变满时增长是很昂贵的，
 并且散列冲突需要很多的逻辑【5】。
 范围查询效率不高。例如，您无法轻松扫描kitty00000和kitty99999之间的所有键——您
 必须在散列映射中单独查找每个键。 
### 第四章：编码与演化

---
## 第二部分：分布式数据
### 第五章：复制
### 第六章：分区
### 第七章：事务
### 第八章：分布式系统的麻烦
### 第九章：一致性与共识  

---
## 第三部分：派生数据
### 第十章：批处理
### 第十一章：流处理
### 第十二章：数据系统的未来